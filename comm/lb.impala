struct Neighborhood {
    nranks: i32,
    ranks: Buffer,
    naabbs: Buffer,
    offsets: Buffer,
    aabbs_cpu: Buffer,
    aabbs_dev: Buffer,
    rank_capacity: i32,
    aabb_capacity: i32
};

static mut neighborhood : Neighborhood;

fn @get_number_of_neighbor_ranks() -> i32 { neighborhood.nranks }
fn @get_neighborhood_rank(index: i32) -> i32 { bitcast[&[i32]](neighborhood.ranks.data)(index) }
fn @get_rank_number_of_aabbs(index: i32) -> i32 { bitcast[&[i32]](neighborhood.naabbs.data)(index) }
fn @get_rank_offset(index: i32) -> i32 { bitcast[&[i32]](neighborhood.offsets.data)(index) }
fn @get_neighborhood_aabb(index: i32) -> AABB {
    let aabbs = device().get_array_real(neighborhood.aabbs_cpu);

    AABB {
        xmin: aabbs(index * 6 + 0),
        xmax: aabbs(index * 6 + 1),
        ymin: aabbs(index * 6 + 2),
        ymax: aabbs(index * 6 + 3),
        zmin: aabbs(index * 6 + 4),
        zmax: aabbs(index * 6 + 5)
    }
}

fn initialize_neighborhood() -> () {
    let rank_capacity = get_initial_maximum_neighbor_ranks();
    let aabb_capacity = rank_capacity * 8;

    neighborhood = Neighborhood {
        nranks: 0,
        ranks: alloc_cpu(rank_capacity * sizeof[i32]()),
        naabbs: alloc_cpu(rank_capacity * sizeof[i32]()),
        offsets: alloc_cpu(rank_capacity * sizeof[i32]()),
        aabbs_cpu: alloc_cpu(aabb_capacity * 6 * sizeof[real_t]()),
        aabbs_dev: device().alloc(aabb_capacity * 6 * sizeof[real_t]()),
        rank_capacity: rank_capacity,
        aabb_capacity: aabb_capacity
    };
}

fn release_neighborhood() -> () {
    release(neighborhood.ranks);
    release(neighborhood.naabbs);
    release(neighborhood.offsets);
    release(neighborhood.aabbs_cpu);
    release(neighborhood.aabbs_dev);
}

extern fn md_update_neighborhood(nranks: i32, total_aabbs: i32, ranks: &[i32], naabbs: &[i32], aabbs: &[real_t]) -> () {
    let dev = device();
    let mut offset = 0;

    neighborhood.nranks = nranks;

    if nranks > neighborhood.rank_capacity {
        let new_capacity = nranks + 10;
        release(neighborhood.ranks);
        release(neighborhood.naabbs);
        release(neighborhood.offsets);
        neighborhood.ranks = alloc_cpu(new_capacity * sizeof[i32]());
        neighborhood.naabbs = alloc_cpu(new_capacity * sizeof[i32]());
        neighborhood.offsets = alloc_cpu(new_capacity * sizeof[i32]());
        neighborhood.rank_capacity = new_capacity;
    }

    if total_aabbs > neighborhood.aabb_capacity {
        let new_capacity = total_aabbs + 10;
        release(neighborhood.aabbs_cpu);
        release(neighborhood.aabbs_dev);
        neighborhood.aabbs_cpu = alloc_cpu(new_capacity * 6 * sizeof[real_t]());
        neighborhood.aabbs_dev = dev.alloc(new_capacity * 6 * sizeof[real_t]());
        neighborhood.aabb_capacity = new_capacity;
    }

    range(0, nranks, |r| {
        bitcast[&mut[i32]](neighborhood.ranks.data)(r) = ranks(r);
        bitcast[&mut[i32]](neighborhood.naabbs.data)(r) = naabbs(r);
        bitcast[&mut[i32]](neighborhood.offsets.data)(r) = offset;
        offset += naabbs(r);
    });

    range(0, total_aabbs * 6, |i| {
        bitcast[&mut[real_t]](neighborhood.aabbs_cpu.data)(i) = aabbs(i);
    });

    dev.transfer(neighborhood.aabbs_cpu, neighborhood.aabbs_dev);
}

fn distance_point_line(point: real_t, min: real_t, max: real_t) -> real_t {
    let square = @|x: real_t| { x * x };

    if point < min {
        square(min - point)
    } else if point > max {
        square(point - max)
    } else {
        0.0
    }
}

fn distance_point_aabb(point: Vector3D, aabb: AABB) -> real_t {
    distance_point_line(point.x, aabb.xmin, aabb.xmax) +
    distance_point_line(point.y, aabb.ymin, aabb.ymax) +
    distance_point_line(point.z, aabb.zmin, aabb.zmax)
}

fn serialize_particles(grid: &mut Grid, comm_offsets: &mut CommOffsets, aabb: AABB, c_aabb: AABB, check_child: bool) -> i32 {
    if check_child {
        serialize_and_remove(grid, comm_offsets, @|p| {
            p.x > aabb.xmin && p.x < aabb.xmax && p.y > aabb.ymin && p.y < aabb.ymax && p.y > aabb.zmin && p.z < aabb.zmax &&
            p.x > c_aabb.xmin && p.x < c_aabb.xmax && p.y > c_aabb.ymin && p.y < c_aabb.ymax && p.y > c_aabb.zmin && p.z < c_aabb.zmax
        })
    } else { 
        serialize_and_remove(grid, comm_offsets, @|p| {
            p.x > aabb.xmin && p.x < aabb.xmax && p.y > aabb.ymin && p.y < aabb.ymax && p.z > aabb.zmin && p.z < aabb.zmax
        })
    }
}

fn serialize_and_remove(grid: &mut Grid, comm_offsets: &mut CommOffsets, check: fn(Vector3D) -> bool) -> i32 {
    let dev = device();
    let mut resize = 1;

    grid.nghost = 0;

    while resize > 0 {
        let const_grid = *grid;
        let const_comm_offsets = *comm_offsets;
        let world_aabb = const_grid.world_aabb;

        set_counter(0, const_comm_offsets);
        reset_resize(const_grid);

        particles(const_grid, |i, _, _, _| {
            let masses = get_masses(const_grid);
            let resize_buf = get_resize_buffer(const_grid);
            let send_flags = get_send_flags(const_grid);
            let buffer = get_send_buffer(const_comm_offsets);
            let send_offsets = get_send_offsets(const_comm_offsets);
            let pos = get_position(i, const_grid);

            if check(pos) {
                let counter = add_counter(const_comm_offsets);

                if counter >= const_comm_offsets.send_capacity {
                    if resize_buf(0) < counter {
                        resize_buf(0) = counter;
                    }
                } else {
                    let vel = get_velocity(i, const_grid);
                    let index = counter * 7;

                    buffer(index + 0) = masses(i);
                    buffer(index + 1) = pos.x;
                    buffer(index + 2) = pos.y;
                    buffer(index + 3) = pos.z;
                    buffer(index + 4) = vel.x;
                    buffer(index + 5) = vel.y;
                    buffer(index + 6) = vel.z;
                    send_offsets(counter) = i;
                    send_flags(i) = 1 as i8;
                }
            } else {
                send_flags(i) = 0 as i8;
            }
        });

        resize = get_resize(const_grid);

        if resize > 0 {
            resize_send_capacity(comm_offsets, resize * 2);
        }
    }

    dev.transfer(comm_offsets.send_offsets_accelerator, comm_offsets.send_offsets);
    dev.transfer(grid.send_flags_accelerator, grid.send_flags_cpu);

    let packed = get_counter(*comm_offsets);
    let nparticles = grid.nparticles - packed;
    let send_flags_host = get_array_of_i8(grid.send_flags_cpu);
    let send_offsets_host = get_array_of_i32(comm_offsets.send_offsets);
    let copy_list_host = get_array_of_i32(comm_offsets.copy_list);
    let mut send_pos = grid.nparticles - 1;

    range(0, packed, |i| {
        if send_offsets_host(i) < nparticles {
            while(send_flags_host(send_pos) == 1 as i8) {
                send_pos--;
            }

            copy_list_host(i) = send_pos;
            send_pos--;
        } else {
            copy_list_host(i) = -1;
        }
    });

    dev.transfer(comm_offsets.copy_list, comm_offsets.copy_list_accelerator);

    let const_comm_offsets = *comm_offsets;
    let const_grid = *grid;

    copy_list_iterate(const_comm_offsets, packed, |i, copy_list, send_offsets| {
        let masses = get_masses(const_grid);

        if copy_list(i) > 0 {
            let src = copy_list(i);
            let dst = send_offsets(i);

            masses(dst) = masses(src);
            set_position(dst, const_grid, get_position(src, const_grid));
            set_velocity(dst, const_grid, get_velocity(src, const_grid));
        }
    });

    grid.nparticles -= packed;
    packed
}

fn deserialize_particles(grid: &mut Grid, comm_offsets: &mut CommOffsets, array: &[real_t], nparticles: i32) -> () {
    grid.nghost = 0;

    let start = add_local_slots(nparticles, grid);
    let const_grid = *grid;

    array_iterate(array, nparticles, |index, data| {
        let buffer_index = index * 7 + 1; 
        let offset = start + index;
        let masses = get_masses(const_grid);
        let position = Vector3D {
            x: data(buffer_index + 1),
            y: data(buffer_index + 2),
            z: data(buffer_index + 3) 
        };

        let velocity = Vector3D {
            x: data(buffer_index + 4),
            y: data(buffer_index + 5),
            z: data(buffer_index + 6) 
        };

        masses(offset) = data(buffer_index);
        set_position(offset, const_grid, position);
        set_velocity(offset, const_grid, velocity);
    });
}
