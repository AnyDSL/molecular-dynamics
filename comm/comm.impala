// Communication offsets (for gather and scatter kernels)
struct CommOffsets {
    // Rank of current process
    me: i32,

    // Local offsets
    local_start: i32,

    // Host send data
    send_buffer: Buffer,
    send_neighbors: Buffer,
    send_rank_offsets: Buffer,
    send_rank_lengths: Buffer,
    send_offsets: Buffer,
    send_pbc: Buffer,
    copy_list: Buffer,
    send_capacity: i32,
    send_noffsets: i32,

    // Host receive data
    recv_buffer: Buffer,
    recv_neighbors: Buffer,
    recv_rank_offsets: Buffer,
    recv_rank_lengths: Buffer,
    recv_capacity: i32,
    recv_noffsets: i32,

    // Host counter buffer
    counter_buffer: Buffer,

    // Accelerator send data
    send_buffer_accelerator: Buffer,
    send_offsets_accelerator: Buffer,
    send_pbc_accelerator: Buffer,
    copy_list_accelerator: Buffer,

    // Accelerator receive data
    recv_buffer_accelerator: Buffer,

    // Host counter buffer
    counter_buffer_accelerator: Buffer,

    // Maximun and current number of neighbors
    max_neighs: i32,
    neighs: i32
};

// Cartesian info
static mut xprev: i32;
static mut xnext: i32;
static mut yprev: i32;
static mut ynext: i32;
static mut zprev: i32;
static mut znext: i32;

// Does the PBC changes in particle positions must be performed before checking
// their border condition?
fn @apply_pbc_before_border_check() -> bool { select(use_walberla(), true, false) }

// Maximum number of neighbor ranks
fn @get_initial_maximum_neighbor_ranks() -> i32 { select(use_walberla(), 30, 6) }

// Initialize and finalize MPI
fn mpi_initialize() -> () { mpi().init(); }
fn mpi_finalize() -> () { mpi().finalize(); }

// Types for condition and communication functions
type CondFunc = fn(Vector3D, fn(Vector3D, PBCFlags) -> ()) -> ();
type CommFunc = fn(i32, i32, i32, i32, i32, CondFunc, CondFunc) -> ();

// Communication pattern using walberla or 6-stencil neighbors
fn communication_ranks(grid: Grid, body: CommFunc) -> () {
    let nbh = neighborhood;
    let world_aabb = grid.world_aabb;
    let spacing = grid.spacing;
    let no_pbc_flags = PBCFlags { x: 0 as i8, y: 0 as i8, z: 0 as i8 };

    if use_walberla() {
        let nranks = get_number_of_neighbor_ranks();
        let sizes = Vector3D {
            x: world_aabb.xmax - world_aabb.xmin,
            y: world_aabb.ymax - world_aabb.ymin,
            z: world_aabb.zmax - world_aabb.zmin
        };

        range(0, nranks as i32, |i| {
            let rank = get_neighborhood_rank(i);
            let naabbs = get_rank_number_of_aabbs(i);
            let offset = get_rank_offset(i);

            body(rank, rank, 0, 0, 0,
                @|p, f| {
                    if is_within_aabb_radius(p, world_aabb, spacing) {
                        let mut i = 0;
                        while i < naabbs {
                            if distance_point_aabb(p, get_neighborhood_aabb(nbh, offset + i)) < spacing * spacing {
                                f(p, no_pbc_flags);
                                break()
                            }

                            i++;
                        }
                    } else {
                        let mut i = 0;
                        while i < naabbs {
                            distance_point_aabb_periodic(p, get_neighborhood_aabb(nbh, offset + i), sizes, @|dis, p_adj, pbc_flags| {
                                if dis < spacing * spacing {
                                    f(p_adj, pbc_flags);
                                    break()
                                }
                            });

                            i++;
                        }
                    }
                },
                @|p, f| {
                    let mut i = 0;
                    while i < naabbs {
                        let corrected_pos = pbc_corrected_position_if(true, p, grid);
                        if is_within_domain(corrected_pos, get_neighborhood_aabb(nbh, offset + i)) {
                            f(corrected_pos, no_pbc_flags);
                            break()
                        }

                        i++;
                    }
                }
            );
        });
    } else {
        let dspacing = spacing * 2.0;

        body(xnext, xprev, -1, 0, 0,
             @|p, f| { if p.x > grid.aabb.xmax - dspacing { f(p, no_pbc_flags); }},
             @|p, f| { if p.x > grid.aabb.xmax - spacing  { f(p, no_pbc_flags); }});

        body(xprev, xnext, 1, 0, 0,
             @|p, f| { if p.x < grid.aabb.xmin + dspacing { f(p, no_pbc_flags); }},
             @|p, f| { if p.x < grid.aabb.xmin + spacing  { f(p, no_pbc_flags); }});

        body(ynext, yprev, 0, -1, 0,
             @|p, f| { if p.y > grid.aabb.ymax - dspacing { f(p, no_pbc_flags); }},
             @|p, f| { if p.y > grid.aabb.ymax - spacing  { f(p, no_pbc_flags); }});

        body(yprev, ynext, 0, 1, 0,
             @|p, f| { if p.y < grid.aabb.ymin + dspacing { f(p, no_pbc_flags); }},
             @|p, f| { if p.y < grid.aabb.ymin + spacing  { f(p, no_pbc_flags); }});

        body(znext, zprev, 0, 0, -1,
             @|p, f| { if p.z > grid.aabb.zmax - dspacing { f(p, no_pbc_flags); }},
             @|p, f| { if p.z > grid.aabb.zmax - spacing  { f(p, no_pbc_flags); }});

        body(zprev, znext, 0, 0, 1,
             @|p, f| { if p.z < grid.aabb.zmin + dspacing { f(p, no_pbc_flags); }},
             @|p, f| { if p.z < grid.aabb.zmin + spacing  { f(p, no_pbc_flags) }});
    }
}

fn communication_local(me: i32, grid: Grid, body: CommFunc) -> () {
    communication_ranks(grid, |send_rank, recv_rank, pbc_x, pbc_y, pbc_z, border_positions, exchange_positions| {
        if send_rank == me {
            body(send_rank, recv_rank, pbc_x, pbc_y, pbc_z, border_positions, exchange_positions);
        }
    });
}

fn communication_remote(me: i32, grid: Grid, body: CommFunc) -> () {
    communication_ranks(grid, |send_rank, recv_rank, pbc_x, pbc_y, pbc_z, border_positions, exchange_positions| {
        if send_rank != me {
            body(send_rank, recv_rank, pbc_x, pbc_y, pbc_z, border_positions, exchange_positions);
        }
    });
}

fn communication_sep(me: i32, grid: Grid, body: CommFunc) -> () {
    @@communication_remote(me, grid, body);
    @@communication_local(me, grid, body);
}

fn @pbc_corrected_position_if(@cond: bool, pos: Vector3D, grid: Grid) -> Vector3D {
    if !cond {
        pos
    } else {
        let world_aabb = grid.world_aabb;
        let mut corrected_pos = pos;

        if pos.x < world_aabb.xmin { corrected_pos.x += grid.xlength; }
        if pos.x > world_aabb.xmax { corrected_pos.x -= grid.xlength; }
        if pos.y < world_aabb.ymin { corrected_pos.y += grid.ylength; }
        if pos.y > world_aabb.ymax { corrected_pos.y -= grid.ylength; }
        if pos.z < world_aabb.zmin { corrected_pos.z += grid.zlength; }
        if pos.z > world_aabb.zmax { corrected_pos.z -= grid.zlength; }

        corrected_pos
    }
}

// Get world size
fn get_world_size() -> i32 {
    let mpih = mpi();
    let mut world_size: i32;

    mpih.comm_size(mpih.comms.world, &mut world_size);
    world_size
}

// Get process rank
fn get_process_rank() -> i32 {
    let mpih = mpi();
    let mut rank: i32;

    mpih.comm_rank(mpih.comms.world, &mut rank);
    rank
}

// MPI barrier
fn barrier() -> () {
    let mpih = mpi();
    let mut request: MPI_Request;

    mpih.barrier(mpih.comms.world, &mut request);
}

// Release communication buffers
fn release_comm_offsets(comm_offsets: CommOffsets) -> () {
    release(comm_offsets.send_buffer);
    release(comm_offsets.send_offsets);
    release(comm_offsets.send_pbc);
    release(comm_offsets.recv_buffer);
    release(comm_offsets.copy_list);

    if comm_offsets.send_capacity > 0 {
        release(comm_offsets.send_neighbors);
        release(comm_offsets.send_rank_offsets);
        release(comm_offsets.send_rank_lengths);
        release(comm_offsets.send_buffer_accelerator);
        release(comm_offsets.send_offsets_accelerator);
        release(comm_offsets.send_pbc_accelerator);
        release(comm_offsets.copy_list_accelerator);
    }

    if comm_offsets.recv_capacity > 0 {
        release(comm_offsets.recv_neighbors);
        release(comm_offsets.recv_rank_offsets);
        release(comm_offsets.recv_rank_lengths);
        release(comm_offsets.recv_buffer_accelerator);
    }

    release(comm_offsets.counter_buffer);
    release(comm_offsets.counter_buffer_accelerator);
}

fn resize_max_neighbors_capacity(comm_offsets: &mut CommOffsets, max_neighs: i32) -> () {
    print_i32_with_rank("resize_max_neighbors_capacity()", max_neighs);

    reallocate_buffer(&mut comm_offsets.send_neighbors, max_neighs, sizeof[i32](), true, alloc_cpu);
    reallocate_buffer(&mut comm_offsets.send_rank_offsets, max_neighs, sizeof[i32](), true, alloc_cpu);
    reallocate_buffer(&mut comm_offsets.send_rank_lengths, max_neighs, sizeof[i32](), true, alloc_cpu);
    reallocate_buffer(&mut comm_offsets.recv_neighbors, max_neighs, sizeof[i32](), true, alloc_cpu);
    reallocate_buffer(&mut comm_offsets.recv_rank_offsets, max_neighs, sizeof[i32](), true, alloc_cpu);
    reallocate_buffer(&mut comm_offsets.recv_rank_lengths, max_neighs, sizeof[i32](), true, alloc_cpu);

    comm_offsets.max_neighs = max_neighs;
}

fn resize_send_capacity(comm_offsets: &mut CommOffsets, send_capacity: i32) -> () {
    print_i32_with_rank("resize_send_capacity()", send_capacity);

    let dev = device();

    reallocate_buffer(&mut comm_offsets.send_buffer, send_capacity * 7, sizeof[real_t](), true, alloc_cpu);
    reallocate_buffer(&mut comm_offsets.send_offsets, send_capacity, sizeof[i32](), true, alloc_cpu);
    reallocate_buffer(&mut comm_offsets.send_pbc, send_capacity * 3, sizeof[i8](), true, alloc_cpu);
    reallocate_buffer(&mut comm_offsets.copy_list, send_capacity, sizeof[i32](), true, alloc_cpu);

    release(comm_offsets.send_buffer_accelerator);
    release(comm_offsets.send_offsets_accelerator);
    release(comm_offsets.send_pbc_accelerator);
    release(comm_offsets.copy_list_accelerator);

    comm_offsets.send_buffer_accelerator = dev.alloc(send_capacity * 3 * sizeof[real_t]());
    comm_offsets.send_offsets_accelerator = dev.alloc(send_capacity * sizeof[i32]());
    comm_offsets.send_pbc_accelerator = dev.alloc(send_capacity * 3 * sizeof[i8]());
    comm_offsets.copy_list_accelerator = dev.alloc(send_capacity * sizeof[i32]());
    comm_offsets.send_capacity = send_capacity;
}

fn resize_recv_capacity(comm_offsets: &mut CommOffsets, recv_capacity: i32) -> () {
    print_i32_with_rank("resize_recv_capacity()", recv_capacity);

    reallocate_buffer(&mut comm_offsets.recv_buffer, recv_capacity * 7, sizeof[real_t](), true, alloc_cpu);
    release(comm_offsets.recv_buffer_accelerator);

    comm_offsets.recv_buffer_accelerator = device().alloc(recv_capacity * 3 * sizeof[real_t]());
    comm_offsets.recv_capacity = recv_capacity;
}

// Get configuration for nodes according to world size and number of
// cells in each dimension
fn get_node_config(xlength: real_t, ylength: real_t, zlength: real_t, destx: &mut i32, desty: &mut i32, destz: &mut i32) -> () {
    let mpih = mpi();
    let areax = xlength * ylength;
    let areay = xlength * zlength;
    let areaz = ylength * zlength;
    let mut bestsurf = 2.0 * (areax + areay + areaz) as f64;
    let mut world_size: i32;

    *destx = 1;
    *desty = 1;
    *destz = 1;

    mpih.comm_size(mpih.comms.world, &mut world_size);

    for i in range(1, world_size) {
        if world_size % i == 0 {
            let rem_yz = world_size / i;

            for j in range(1, rem_yz) {
                if rem_yz % j == 0 {
                    let k = rem_yz / j;
                    let surf = areax / i as f64 / j as f64 + areay / i as f64 / k as f64 + areaz / j as f64 / k as f64;

                    if surf < bestsurf {
                        *destx = i;
                        *desty = j;
                        *destz = k;
                        bestsurf = surf;
                    }
                }
            }
        }
    }
}

// Get bounding box for current node
fn get_node_bounding_box(aabb: AABB) -> AABB {
    let mpih = mpi();
    let mut gx: i32;
    let mut gy: i32;
    let mut gz: i32;

    // Number of cells in each dimension
    let xtotallength = aabb.xmax - aabb.xmin;
    let ytotallength = aabb.ymax - aabb.ymin;
    let ztotallength = aabb.zmax - aabb.zmin;

    // Get configuration of nodes
    get_node_config(xtotallength, ytotallength, ztotallength, &mut gx, &mut gy, &mut gz);

    // Dimensions length for each rank
    let xlength = xtotallength / (gx as real_t);
    let ylength = ytotallength / (gy as real_t);
    let zlength = ztotallength / (gz as real_t);

    let mut locx: i32;
    let mut locy: i32;
    let mut locz: i32;

    // 3D cartesian position of current rank
    mpih.cart(gx, gy, gz, &mut locx, &mut locy, &mut locz, &mut xprev, &mut xnext, &mut yprev, &mut ynext, &mut zprev, &mut znext);

    // Calculate boundaries using lengths in each dimension
    let xmin = aabb.xmin + xlength * locx as real_t;
    let xmax = xmin + xlength;
    let ymin = aabb.ymin + ylength * locy as real_t;
    let ymax = ymin + ylength;
    let zmin = aabb.zmin + zlength * locz as real_t;
    let zmax = zmin + zlength;

    AABB {
        xmin: xmin,
        xmax: xmax,
        ymin: ymin,
        ymax: ymax,
        zmin: zmin,
        zmax: zmax
    }
}

// Initialize grid communication
fn alloc_comm_offsets(grid: Grid) -> CommOffsets {
    let mpih = mpi();
    let dev = device();
    let max_neighs = get_initial_maximum_neighbor_ranks();
    let max_faces_dim = math.max(math.max(grid.nx * grid.ny, grid.nx * grid.nz), grid.ny * grid.nz);
    let send_capacity = max_neighs * max_faces_dim * 20;
    let recv_capacity = max_neighs * max_faces_dim * 20;
    let null_buf = Buffer {
        device: 0,
        data: 0 as &[i8],
        size: 0 as i64
    };

    let mut world_rank: i32;

    mpih.comm_rank(mpih.comms.world, &mut world_rank);

    CommOffsets {
        // Rank of current process
        me: world_rank,

        // Local offsets
        local_start: 0,

        // Host send data
        send_buffer: alloc_cpu(send_capacity * 7 * sizeof[real_t]()),
        send_neighbors: alloc_cpu(max_neighs * sizeof[i32]()),
        send_rank_offsets: alloc_cpu(max_neighs * sizeof[i32]()),
        send_rank_lengths: alloc_cpu(max_neighs * sizeof[i32]()),
        send_offsets: alloc_cpu(send_capacity * sizeof[i32]()),
        send_pbc: alloc_cpu(send_capacity * 3 * sizeof[i8]()),
        copy_list: alloc_cpu(send_capacity * sizeof[i32]()),
        send_capacity: send_capacity,
        send_noffsets: 0,

        // Host receive data
        recv_buffer: alloc_cpu(recv_capacity * 7 * sizeof[real_t]()),
        recv_neighbors: alloc_cpu(max_neighs * sizeof[i32]()),
        recv_rank_offsets: alloc_cpu(max_neighs * sizeof[i32]()),
        recv_rank_lengths: alloc_cpu(max_neighs * sizeof[i32]()),
        recv_capacity: recv_capacity,
        recv_noffsets: 0,

        // Host counter buffer
        counter_buffer: alloc_cpu(sizeof[i32]()),

        // Accelerator send data
        send_buffer_accelerator: dev.alloc(send_capacity * 7 * sizeof[real_t]()),
        send_offsets_accelerator: dev.alloc(send_capacity * sizeof[i32]()),
        send_pbc_accelerator: dev.alloc(send_capacity * 7 * sizeof[i8]()),
        copy_list_accelerator: dev.alloc(send_capacity * sizeof[i32]()),

        // Accelerator receive data
        recv_buffer_accelerator: dev.alloc(recv_capacity * 7 * sizeof[real_t]()),

        // Accelerator counter buffer
        counter_buffer_accelerator: dev.alloc(sizeof[i32]()),

        // Maximum and current number of neighbor ranks
        max_neighs: max_neighs,
        neighs: 0
    }
}

// Synchronize ghost layer cells with neighbor ranks
fn synchronize_ghost_layer(grid: Grid, comm_offsets: CommOffsets) -> () {
    let dev = device();
    let mpih = mpi();
    let mut request: MPI_Request;
    let mut status: MPIStatus;

    let send_buffer = comm_offsets.send_buffer;
    let recv_buffer = comm_offsets.recv_buffer;
    let send_neighbors = get_array_of_i32(comm_offsets.send_neighbors);
    let recv_neighbors = get_array_of_i32(comm_offsets.recv_neighbors);
    let send_rank_offsets = get_array_of_i32(comm_offsets.send_rank_offsets);
    let recv_rank_offsets = get_array_of_i32(comm_offsets.recv_rank_offsets);
    let send_rank_lengths = get_array_of_i32(comm_offsets.send_rank_lengths);
    let recv_rank_lengths = get_array_of_i32(comm_offsets.recv_rank_lengths);
    let nlocal = comm_offsets.send_noffsets - comm_offsets.local_start;

    comm_buffer_iterate(comm_offsets, comm_offsets.send_noffsets, |index, send_data, _| {
        let buffer_index = index * 3;
        let send_offsets = get_send_offsets(comm_offsets);
        let send_pbc = get_send_pbc(comm_offsets);
        let offset = send_offsets(index);
        let position = get_position(offset, grid);

        send_data(buffer_index + 0) = position.x + grid.xlength * send_pbc(buffer_index + 0) as real_t;
        send_data(buffer_index + 1) = position.y + grid.ylength * send_pbc(buffer_index + 1) as real_t;
        send_data(buffer_index + 2) = position.z + grid.zlength * send_pbc(buffer_index + 2) as real_t;
    });

    if comm_offsets.local_start > 0 {
        dev.transfer(comm_offsets.send_buffer_accelerator, comm_offsets.send_buffer);
    }

    range(0, comm_offsets.neighs, |neigh| {
        if send_neighbors(neigh) != comm_offsets.me {
            let send_offset = send_rank_offsets(neigh) * 3 * sizeof[real_t]();
            let recv_offset = recv_rank_offsets(neigh) * 3 * sizeof[real_t]();

            mpih.irecv(
                &recv_buffer.data(recv_offset) as MPI_MutBuf, recv_rank_lengths(neigh) * 3,
                mpih.double_t, recv_neighbors(neigh), 0, mpih.comms.world, &mut request);

            mpih.send(
                &send_buffer.data(send_offset) as MPI_Buf, send_rank_lengths(neigh) * 3,
                mpih.double_t, send_neighbors(neigh), 0, mpih.comms.world);

            mpih.wait(&request, &mut status);
        }
    });

    if comm_offsets.recv_noffsets > 0 {
        dev.transfer(comm_offsets.recv_buffer, comm_offsets.recv_buffer_accelerator);
    }

    comm_buffer_iterate(comm_offsets, comm_offsets.recv_noffsets, |index, _, recv_data| {
        let offset = grid.nparticles + index;
        let position = Vector3D {
            x: recv_data(index * 3 + 0),
            y: recv_data(index * 3 + 1),
            z: recv_data(index * 3 + 2),
        };

        set_position(offset, grid, position);
    });

    comm_buffer_iterate(comm_offsets, nlocal, |index, send_data, _| {
        let buffer_index = (comm_offsets.local_start + index) * 3;
        let offset = grid.nparticles + comm_offsets.recv_noffsets + index;
        let position = Vector3D {
            x: send_data(buffer_index + 0),
            y: send_data(buffer_index + 1),
            z: send_data(buffer_index + 2),
        };

        set_position(offset, grid, position);
    });
}

// Exchange ghost layer particles with neighbor ranks (here the number of
// particles is also updated)
fn exchange_particles(grid: &mut Grid, comm_offsets: &mut CommOffsets) -> () {
    let dev = device();
    let mpih = mpi();
    let mut request: MPI_Request;
    let mut status: MPIStatus;
    let mut iexchg = 0;
    let mut neigh = 0;

    grid.nghost = 0;

    communication_ranks(*grid, |_, _, _, _, _, _, _| {
        if neigh >= comm_offsets.max_neighs {
            resize_max_neighbors_capacity(comm_offsets, neigh + 8);
        }

        let exchg_rank_send_offsets = get_array_of_i32(comm_offsets.send_rank_offsets);
        exchg_rank_send_offsets(neigh) = -1;
        neigh++;
    });

    let exchg_rank_send_offsets = get_array_of_i32(comm_offsets.send_rank_offsets);
    let exchg_rank_send_lengths = get_array_of_i32(comm_offsets.send_rank_lengths);
    let exchg_rank_recv_lengths = get_array_of_i32(comm_offsets.recv_rank_lengths);

    neigh = 0;

    // Pack particles in each direction to exchange
    communication_ranks(*grid, |exchg_rank, _, _, _, _, _, exchange_positions| {
        exchg_rank_send_offsets(neigh) = iexchg;

        // Makes no sense to exchange data with myself, right?
        if exchg_rank != comm_offsets.me {
            let mut resize = 1;

            while resize > 0 {
                let const_grid = *grid;
                let const_comm_offsets = *comm_offsets;
                let const_iexchg = iexchg;
                let world_aabb = const_grid.world_aabb;

                set_counter(iexchg, const_grid);
                reset_resize(const_grid);

                particles(const_grid, |i, _, _, _| {
                    let masses = get_masses(const_grid);
                    let resize_buf = get_resize_buffer(const_grid);
                    let send_flags = get_send_flags(const_grid);
                    let buffer = get_send_buffer(const_comm_offsets);
                    let send_offsets = get_send_offsets(const_comm_offsets);
                    let particle_pos = get_position(i, const_grid);

                    send_flags(i) = 0 as i8;

                    exchange_positions(particle_pos, |pos, _| {
                        let counter = add_counter(const_grid);

                        if counter >= const_comm_offsets.send_capacity {
                            if resize_buf(0) < counter {
                                resize_buf(0) = counter;
                            }
                        } else {
                            let corrected_pos = pbc_corrected_position_if(!apply_pbc_before_border_check(), pos, const_grid);
                            let vel = get_velocity(i, const_grid);
                            let index = counter * 7;

                            buffer(index + 0) = masses(i);
                            buffer(index + 1) = corrected_pos.x;
                            buffer(index + 2) = corrected_pos.y;
                            buffer(index + 3) = corrected_pos.z;
                            buffer(index + 4) = vel.x;
                            buffer(index + 5) = vel.y;
                            buffer(index + 6) = vel.z;

                            send_offsets(counter - const_iexchg) = i;
                            send_flags(i) = 1 as i8;
                        }
                    });
                });

                resize = get_resize(const_grid);

                if resize > 0 {
                    resize_send_capacity(comm_offsets, resize * 2);
                }
            }

            dev.transfer(comm_offsets.send_offsets_accelerator, comm_offsets.send_offsets);
            dev.transfer(grid.send_flags_accelerator, grid.send_flags_cpu);

            let counter = get_counter(*grid);
            let packed = counter - iexchg;
            let nparticles = grid.nparticles - packed;
            let send_flags_host = get_array_of_i8(grid.send_flags_cpu);
            let send_offsets_host = get_array_of_i32(comm_offsets.send_offsets);
            let copy_list_host = get_array_of_i32(comm_offsets.copy_list);
            let mut send_pos = grid.nparticles - 1;

            range(0, packed, |i| {
                if send_offsets_host(i) < nparticles {
                    while(send_flags_host(send_pos) == 1 as i8) {
                        send_pos--;
                    }

                    copy_list_host(i) = send_pos;
                    send_pos--;
                } else {
                    copy_list_host(i) = -1;
                }
            });

            dev.transfer(comm_offsets.copy_list, comm_offsets.copy_list_accelerator);

            let const_comm_offsets = *comm_offsets;
            let const_grid = *grid;

            copy_list_iterate(const_comm_offsets, packed, |i, copy_list, send_offsets| {
                let masses = get_masses(const_grid);

                if copy_list(i) > 0 {
                    let src = copy_list(i);
                    let dst = send_offsets(i);

                    masses(dst) = masses(src);
                    set_position(dst, const_grid, get_position(src, const_grid));
                    set_velocity(dst, const_grid, get_velocity(src, const_grid));
                }
            });

            grid.nparticles -= packed;
            iexchg = counter;
        }

        exchg_rank_send_lengths(neigh) = iexchg - exchg_rank_send_offsets(neigh);
        neigh++;
    });

    dev.transfer(comm_offsets.send_buffer_accelerator, comm_offsets.send_buffer);

    iexchg = 0;
    neigh = 0;

    // Exchange particles with other ranks
    communication_ranks(*grid, |send_rank, recv_rank, _, _, _, _, _| {
        if send_rank != comm_offsets.me {
            let exchg_send_offset = exchg_rank_send_offsets(neigh) * 7 * sizeof[real_t]();
            let exchg_recv_offset = iexchg * 7 * sizeof[real_t]();

            // Exchange sizes
            mpih.send(&exchg_rank_send_lengths(neigh) as MPI_Buf, 1, mpih.int_t, send_rank, 0, mpih.comms.world);
            mpih.recv(&mut exchg_rank_recv_lengths(neigh) as MPI_MutBuf, 1, mpih.int_t, recv_rank, 0, mpih.comms.world, &mut status);

            // Readjust receive capacity if it is not enough
            if iexchg + exchg_rank_recv_lengths(neigh) >= comm_offsets.recv_capacity {
                resize_recv_capacity(comm_offsets, (iexchg + exchg_rank_recv_lengths(neigh)) * 2);
            }

            // Exchange data
            mpih.irecv(
                &comm_offsets.recv_buffer.data(exchg_recv_offset) as MPI_MutBuf, exchg_rank_recv_lengths(neigh) * 7,
                mpih.double_t, recv_rank, 0, mpih.comms.world, &mut request);

            mpih.send(
                &comm_offsets.send_buffer.data(exchg_send_offset) as MPI_Buf, exchg_rank_send_lengths(neigh) * 7,
                mpih.double_t, send_rank, 0, mpih.comms.world);

            mpih.wait(&request, &mut status);

            // Adjust exchange offset data
            iexchg += exchg_rank_recv_lengths(neigh);
        }

        neigh++;
    });

    dev.transfer(comm_offsets.recv_buffer, comm_offsets.recv_buffer_accelerator);

    // Unpack received particles
    let exchg_start = add_local_slots(iexchg, grid);
    let const_grid = *grid;
    let const_comm_offsets = *comm_offsets;

    comm_buffer_iterate(const_comm_offsets, iexchg, |index, _, recv_data| {
        let buffer_index = index * 7;
        let offset = exchg_start + index;
        let masses = get_masses(const_grid);
        let position = Vector3D {
            x: recv_data(buffer_index + 1),
            y: recv_data(buffer_index + 2),
            z: recv_data(buffer_index + 3)
        };

        let velocity = Vector3D {
            x: recv_data(buffer_index + 4),
            y: recv_data(buffer_index + 5),
            z: recv_data(buffer_index + 6)
        };

        masses(offset) = recv_data(buffer_index);
        set_position(offset, const_grid, position);
        set_velocity(offset, const_grid, velocity);
    });
}

// Define particle borders to synchronize during next iterations
fn borders(grid: &mut Grid, comm_offsets: &mut CommOffsets) -> () {
    let dev = device();
    let mpih = mpi();
    let mut request: MPI_Request;
    let mut status: MPIStatus;
    let mut ilocal = 0;
    let mut isend = 0;
    let mut irecv = 0;
    let mut nremote = 0;
    let mut neigh = 0;

    grid.nghost = 0;

    communication_ranks(*grid, |send_rank, _, _, _, _, _, _| {
        if neigh >= comm_offsets.max_neighs {
            resize_max_neighbors_capacity(comm_offsets, neigh + 8);
        }

        let send_rank_offsets = get_array_of_i32(comm_offsets.send_rank_offsets);
        let recv_rank_offsets = get_array_of_i32(comm_offsets.recv_rank_offsets);

        send_rank_offsets(neigh) = -1;
        recv_rank_offsets(neigh) = -1;

        if send_rank != comm_offsets.me {
            nremote++;
        }

        neigh++;
    });

    let send_rank_offsets = get_array_of_i32(comm_offsets.send_rank_offsets);
    let send_rank_lengths = get_array_of_i32(comm_offsets.send_rank_lengths);

    neigh = 0;

    // Pack particles in each direction to send during next iterations
    communication_sep(comm_offsets.me, *grid, |_, _, pbc_x, pbc_y, pbc_z, border_positions, _| {
        let mut resize = 1;

        send_rank_offsets(neigh) = isend;

        while resize > 0 {
            let const_grid = *grid;
            let const_comm_offsets = *comm_offsets;
            let const_isend = isend;

            set_counter(isend, const_grid);
            reset_resize(const_grid);

            particles(const_grid, |i, _, _, _| {
                let masses = get_masses(const_grid);
                let resize_buf = get_resize_buffer(const_grid);
                let send_flags = get_send_flags(const_grid);
                let buffer = get_send_buffer(const_comm_offsets);
                let send_offsets = get_send_offsets(const_comm_offsets);
                let send_pbc = get_send_pbc(const_comm_offsets);
                let particle_pos = get_position(i, const_grid);

                border_positions(particle_pos, |pos, pbc| {
                    let counter = add_counter(const_grid);

                    if counter >= const_comm_offsets.send_capacity {
                        if resize_buf(0) < counter {
                            resize_buf(0) = counter;
                        }
                    } else {
                        let buf_index = counter * 4;
                        let pbc_index = counter * 3;
                        let mut adj_pos = pos;
                        let mut adj_pbc = pbc;

                        // When it is not necessary to apply PBC before border check, we want to avoid calculating
                        // PBC coordinates for particles that do not need to be communicated
                        if !apply_pbc_before_border_check() {
                            adj_pbc = get_pbc_flags_from_position(pos, pbc_x, pbc_y, pbc_z, const_grid);
                            adj_pos.x += const_grid.xlength * pbc.x as real_t;
                            adj_pos.y += const_grid.ylength * pbc.y as real_t;
                            adj_pos.z += const_grid.zlength * pbc.z as real_t;
                        }

                        send_pbc(pbc_index + 0) = adj_pbc.x;
                        send_pbc(pbc_index + 1) = adj_pbc.y;
                        send_pbc(pbc_index + 2) = adj_pbc.z;

                        buffer(buf_index + 0) = masses(i);
                        buffer(buf_index + 1) = adj_pos.x;
                        buffer(buf_index + 2) = adj_pos.y;
                        buffer(buf_index + 3) = adj_pos.z;

                        send_offsets(counter) = i;
                    }
                });
            });

            resize = get_resize(const_grid);

            if resize > 0 {
                resize_send_capacity(comm_offsets, resize * 2);
            }
        }

        isend = get_counter(*grid);
        send_rank_lengths(neigh) = isend - send_rank_offsets(neigh);
        neigh++;
    });

    let recv_rank_offsets = get_array_of_i32(comm_offsets.recv_rank_offsets);
    let recv_rank_lengths = get_array_of_i32(comm_offsets.recv_rank_lengths);
    let send_neighbors = get_array_of_i32(comm_offsets.send_neighbors);
    let recv_neighbors = get_array_of_i32(comm_offsets.recv_neighbors);

    neigh = 0;

    if nremote > 0 {
        dev.transfer(comm_offsets.send_buffer_accelerator, comm_offsets.send_buffer);
    }

    // Synchronize borders with other ranks
    communication_remote(comm_offsets.me, *grid, |send_rank, recv_rank, _, _, _, _, _| {
        // Rank receive offset
        recv_rank_offsets(neigh) = irecv;

        // Offsets to send and receive
        let send_offset = send_rank_offsets(neigh) * 4 * sizeof[real_t]();
        let recv_offset = recv_rank_offsets(neigh) * 4 * sizeof[real_t]();

        // Send sizes
        mpih.send(&send_rank_lengths(neigh) as MPI_Buf, 1, mpih.int_t, send_rank, 0, mpih.comms.world);
        mpih.recv(&mut recv_rank_lengths(neigh) as MPI_MutBuf, 1, mpih.int_t, recv_rank, 0, mpih.comms.world, &mut status);

        // Readjust receive capacity if it is not enough
        if irecv + recv_rank_lengths(neigh) >= comm_offsets.recv_capacity {
            resize_recv_capacity(comm_offsets, (irecv + recv_rank_lengths(neigh)) * 2);
        }

        mpih.irecv(
            &comm_offsets.recv_buffer.data(recv_offset) as MPI_MutBuf, recv_rank_lengths(neigh) * 4,
            mpih.double_t, recv_rank, 0, mpih.comms.world, &mut request);

        mpih.send(
            &comm_offsets.send_buffer.data(send_offset) as MPI_Buf, send_rank_lengths(neigh) * 4,
            mpih.double_t, send_rank, 0, mpih.comms.world);

        mpih.wait(&request, &mut status);

        // Update ranks to send and receive during synchronization
        send_neighbors(neigh) = send_rank;
        recv_neighbors(neigh) = recv_rank;

        ilocal += send_rank_lengths(neigh);
        irecv += recv_rank_lengths(neigh);
        neigh++;
    });

    let const_grid = *grid;
    let const_comm_offsets = *comm_offsets;
    let const_ilocal = ilocal;
    let const_irecv = irecv;
    let nlocal = isend - ilocal;

    add_ghost_slots(irecv + nlocal, grid);

    if irecv > 0 {
        dev.transfer(comm_offsets.recv_buffer, comm_offsets.recv_buffer_accelerator);
    }

    comm_buffer_iterate(const_comm_offsets, irecv, |index, _, recv_data| {
        let buffer_index = index * 4;
        let offset = const_grid.nparticles + index;
        let masses = get_masses(const_grid);
        let position = Vector3D {
            x: recv_data(buffer_index + 1),
            y: recv_data(buffer_index + 2),
            z: recv_data(buffer_index + 3)
        };

        masses(offset) = recv_data(buffer_index);
        set_position(offset, const_grid, position);
    });

    comm_buffer_iterate(const_comm_offsets, nlocal, |index, send_data, _| {
        let buffer_index = (const_ilocal + index) * 4;
        let offset = const_grid.nparticles + const_irecv + index;
        let masses = get_masses(const_grid);
        let position = Vector3D {
            x: send_data(buffer_index + 1),
            y: send_data(buffer_index + 2),
            z: send_data(buffer_index + 3),
        };

        masses(offset) = send_data(buffer_index);
        set_position(offset, const_grid, position);
    });

    comm_offsets.local_start = ilocal;
    comm_offsets.send_noffsets = isend;
    comm_offsets.recv_noffsets = irecv;
    comm_offsets.neighs = neigh;
}

fn reduce_time(local_time: f64, global_time: &mut f64) -> () {
    let mpih = mpi();
    let mut local = local_time;
    mpih.allreduce(&mut local as MPI_MutBuf, global_time as MPI_MutBuf, 1, mpih.double_t, mpih.ops.max, mpih.comms.world);
}

fn reduce_i32_sum(local_value: i32, global_value: &mut i32) -> () {
    let mpih = mpi();
    let mut local = local_value;
    mpih.allreduce(&mut local as MPI_MutBuf, global_value as MPI_MutBuf, 1, mpih.int_t, mpih.ops.sum, mpih.comms.world);
}

fn reduce_i64_sum(local_value: i64, global_value: &mut i64) -> () {
    let mpih = mpi();
    let mut local = local_value;
    mpih.allreduce(&mut local as MPI_MutBuf, global_value as MPI_MutBuf, 1, mpih.int64_t, mpih.ops.sum, mpih.comms.world);
}
