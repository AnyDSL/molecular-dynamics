type real_t = f64;
static math = cpu_intrinsics;
static real_floor = math.floor;
static atomic_op_real = atomic_op_f64;

struct Vector3D {
    x: real_t,
    y: real_t,
    z: real_t
}

struct PBCFlags {
    x: i8,
    y: i8,
    z: i8
}

fn @swap_real(i: i32, j: i32, buf: Buffer) -> () {
    let data = get_array_of_reals(buf);
    let tmp = data(i);
    data(i) = data(j);
    data(j) = tmp;
}

// nearest multiple of num
fn @round_up(num: i32, multiple: i32) -> i32 { ((num + multiple - 1) / multiple) * multiple }
fn @round_down(n: i32, d: i32) -> i32 { (n / d) * d }

// array bitcast functions
fn @get_array_of_reals(buf: Buffer) -> &mut[real_t] { bitcast[&mut[real_t]](buf.data) }
fn @get_array_of_i32(buf: Buffer) -> &mut[i32] { bitcast[&mut[i32]](buf.data) }
fn @get_array_of_i8(buf: Buffer) -> &mut[i8] { bitcast[&mut[i8]](buf.data) }
fn @get_array_of_aabb(buf: Buffer) -> &mut[AABB] { bitcast[&mut[AABB]](buf.data) }
fn @get_array_of_reals_accelerator(buf: Buffer) -> &mut[1][real_t] { bitcast[&mut[1][real_t]](buf.data) }
fn @get_array_of_i8_accelerator(buf: Buffer) -> &mut[1][i8] { bitcast[&mut[1][i8]](buf.data) }
fn @get_array_of_i32_accelerator(buf: Buffer) -> &mut[1][i32] { bitcast[&mut[1][i32]](buf.data) }
fn @get_array_of_aabb_accelerator(buf: Buffer) -> &mut[1][AABB] { bitcast[&mut[1][AABB]](buf.data) }

// vector functions
fn @vector_map(a: Vector3D, f: fn (real_t) -> real_t) -> Vector3D { Vector3D { x: f(a.x), y: f(a.y), z: f(a.z) } }
fn @vector_zip(a: Vector3D, b: Vector3D, f: fn (real_t, real_t) -> real_t) -> Vector3D { Vector3D { x: f(a.x, b.x), y: f(a.y, b.y), z: f(a.z, b.z) } }
fn @vector_add(a: Vector3D, b: Vector3D) -> Vector3D { vector_zip(a, b, @ |x, y| x + y) }
fn @vector_sub(a: Vector3D, b: Vector3D) -> Vector3D { vector_zip(a, b, @ |x, y| x - y) }
fn @vector_mul(a: Vector3D, b: Vector3D) -> Vector3D { vector_zip(a, b, @ |x, y| x * y) }
fn @vector_div(a: Vector3D, b: Vector3D) -> Vector3D { vector_zip(a, b, @ |x, y| x / y) }
fn @vector_dot(a: Vector3D, b: Vector3D) -> real_t { a.x * b.x + a.y * b.y + a.z * b.z }
fn @vector_len2(a: Vector3D) -> real_t { vector_dot(a, a) }
fn @vector_scale(a: real_t, b: Vector3D) -> Vector3D { vector_map(b, @ |x| x * a) }
