struct ParticleSystem {
    np: fn() -> size_t,
    nc: fn() -> [size_t * 3],
    ghost_layer: fn() -> size_t,
    start: fn() -> [size_t * 3],
    end: fn() -> [size_t * 3],
    l: fn() -> Vector,
    tmp: fn() -> Vector,
    offset: fn() -> real,
    head: fn(size_t) -> &mut &ParticleList,
    constants: fn() -> Constants,
    addresses: fn() -> ArrayOfAddresses,
    data_cells: fn() -> &[i8],
    data_addresses: fn() -> &[i8]
}



fn get_particle_system(np: size_t, nc: [size_t * 3], ghost_layer: size_t, l: Vector, data_cells: &[i8], constants: Constants, data_addresses: &[i8]) -> ParticleSystem {
    ParticleSystem {
        np: || {np},
        nc: || {nc},
        ghost_layer: || {ghost_layer},
        start: || {
            let mut start : [size_t * 3];
            for d in @map_range(0 as size_t, dimension()) {
                start(d) = ghost_layer;
            }
            start
        },
        end: || {
            let mut end : [size_t * 3];
            for d in @map_range(0 as size_t, dimension()) {
                end(d) = nc(d) - ghost_layer;
            }
            end
        },
        l: || {l},
        tmp: ||{
            let a = get_vector([nc(0) as real, nc(1) as real, nc(2) as real]);
            div_vectors(a, l)
        },
        offset: || {ghost_layer as real * constants.r_cut},
        head: |i| {&mut bitcast[&mut[&ParticleList]](data_cells)(i)},
        constants: || {constants},
        addresses: || {get_array_of_addresses(np, data_addresses)},
        data_cells: || {data_cells},
        data_addresses: || {data_addresses}
    }
}

struct ParticleSystemData {
    np: size_t,
    nc: [size_t * 3],
    ghost_layer: size_t,
    l: [real * 3],
    constants: Constants,
    data_cells: &[i8],
    data_addresses: &[i8]
}

fn get_particle_system_from_data_struct(P_data: ParticleSystemData) -> ParticleSystem {
    get_particle_system(P_data.np, P_data.nc, P_data.ghost_layer, get_vector(P_data.l), P_data.data_cells, P_data.constants, P_data.data_addresses)
}

fn get_data_struct_from_particle_system(P: ParticleSystem) -> ParticleSystemData {
    ParticleSystemData {
        np: P.np(),
        nc: P.nc(),
        ghost_layer: P.ghost_layer(),
        l: P.l().get(),
        constants: P.constants(),
        data_cells: P.data_cells(),
        data_addresses: P.data_addresses()
    }
}


fn insert_particle(node: &mut ParticleList, i: size_t, P: ParticleSystem) -> () {
    let p = get_particle_from_node(*node, true);
    let kc = compute_cell_position(p, P);
    let root = P.head(index(kc, P.nc()));
    insert(root, node);
}

fn push_node(node: &mut ParticleList, P: ParticleSystem) -> () {
    let mut pos : [size_t * 3];
    for d in @map_range(0 as size_t, dimension()) {
        pos(d) = P.nc()(d) / 2 as size_t;
    }
    let root = P.head(index(pos, P.nc()));
    insert(root, node);
}

fn allocate_particle_system(np: size_t, ghost_layer: size_t, l: Vector, constants: Constants) -> ParticleSystem {
    let mut nc : [size_t * 3];
    let mut pnc = 1 as size_t;
    let l_extended = increase_vector(l, 2.0*(ghost_layer as real)*constants.r_cut); 
    for d in @map_range(0 as size_t, dimension()){
        nc(d) = math.floor(l.get()(d)/constants.r_cut) as size_t + (2 as size_t * ghost_layer);
        pnc *= nc(d);
    }
    let data_cells = allocate_and_initialize(pnc * sizeof[&ParticleList]() as size_t, 0);
    //print_string("Data size: ");
    //print_double((pnc * sizeof[&ParticleList]() as size_t + np * (SIZEOFPARTICLE + sizeof[ParticleList]() as size_t) ) as real / 1e6);
    //print_string(" MB\n");
    let data_addresses = allocate(np * sizeof[&[i8]]() as size_t);
    let P = get_particle_system(np, nc, ghost_layer, l_extended, data_cells, constants, data_addresses);
    P
}

fn deallocate_particle_system(P: ParticleSystem) -> () {
    let z = 0 as size_t;
    let start = [z,z,z];
    let end = P.nc();
    for i in map_range(start(0), end(0)) {
        for j in map_range(start(1), end(1)) {
            for k in map_range(start(2), end(2)) {
                let ic = [i,j,k];
                let head = P.head(index(ic, P.nc()));
                delete_list(head);
            }
        }
    }
    deallocate(P.data_cells());
    deallocate(P.data_addresses());
}

/*fn print_particle_system(P: ParticleSystem) -> (){    
    let mut ic_start : [size_t * 3];
    let ic_end = P.nc();
    for d in @map_range(0 as size_t, dimension()) {
        ic_start(d) = 0 as size_t;
    }

    for k in map_range(ic_start(2), ic_end(2)) {
        for j in map_range(ic_start(1), ic_end(1)) {
            for i in map_range(ic_start(0), ic_end(0)) {
                let ic = [i,j,k];
                if(*P.head(index(ic, P.nc())) != 0 as &ParticleList) {
                    print_string("Cell (");
                    print_long(i as i64);
                    print_string(", ");
                    print_long(j as i64);
                    print_string(", ");
                    print_long(k as i64);
                    print_string("): ");
                    print_string(" (Index: ");
                    print_long(index(ic, P.nc()) as i64);
                    print_string(" ) ");
                    for pl in map_list(*P.head(index(ic, P.nc()))) {
                        print_long((*pl).data as i64);
                        print_char(' ');
                    }
                    print_char('\n');
                }
            }
        }
    }
}*/

fn compute_cell_position(p: Particle, P: ParticleSystem) -> [size_t * 3] {
    let mut kc : [size_t * 3];
    let coordinates_x = p.getCoordinates().get();
    let tmp = P.tmp().get();
    let nc = P.nc();
    for d in @map_range((0 as size_t), dimension()) {
        kc(d) = math.floor((coordinates_x(d) + P.offset()) * tmp(d)) as size_t;
    }
    kc
}



struct ArrayOfAddresses {
    size: fn() -> size_t,
    get: fn(size_t) -> &[i8],
    set: fn(size_t, &[i8]) -> () 
}

fn get_array_of_addresses(size: size_t, data: &[i8]) -> ArrayOfAddresses {
    ArrayOfAddresses {
        size: || {size},
        get: |i| {bitcast[&[&[i8]]](data)(i)},
        set: |i, ptr| {
            bitcast[&mut[&[i8]]](data)(i) = ptr;
        }
    }
}

fn init_addresses(P: ParticleSystem) -> () {
    let z = 0 as size_t;
    let mut ic_start : [size_t * 3];
    for d in @map_range(0 as size_t, dimension()) {
        ic_start(d) = z;
    }
    let ic_end = P.nc();
    let mut pos = 0 as size_t;
    let addresses = P.addresses();
    for ic, pl in map_particle_system(ic_start, ic_end, P) {
        if(pl != 0 as &ParticleList) {
            let p : ParticleList = *pl;
            addresses.set(pos++, p.data);
        }
    }
}

fn map_particle_cells(start: [size_t * 3], end: [size_t * 3], P: ParticleSystem, f: fn([size_t * 3], &ParticleList) -> ()) -> () {
    for k in map_range(start(2), end(2)) {
        for j in map_range(start(1), end(1)) {
            for i in map_range(start(0), end(0)){
                let ic = [i,j,k];
                f(ic, *P.head(index(ic, P.nc())));
            }
        }
    }
}
fn parallel_map_particle_cells(start: [size_t * 3], end: [size_t * 3], P: ParticleSystem, numthreads: int, f: fn([size_t * 3], &ParticleList) -> ()) -> () {
    for k in parallel_map_range(start(2), end(2), numthreads) {
        for j in map_range(start(1), end(1)) {
            for i in map_range(start(0), end(0)){
                let ic = [i,j,k];
                f(ic, *P.head(index(ic, P.nc())));
            }
        }
    }
}

fn map_particle_system(start: [size_t * 3], end: [size_t * 3], P: ParticleSystem, f: fn([size_t * 3], &ParticleList) -> ()) -> () {
    for ic, head in map_particle_cells(start, end, P) {
        for pl in map_list(head) {
            f(ic, pl);
        }
    }
}

fn count_ghost_particles(P: ParticleSystem) -> size_t {
    let mut count : size_t = 0 as size_t;
    for i in map_range(0 as size_t, P.np()) {
        let p = get_particle(P.addresses().get(i));
        let kc = compute_cell_position(p, P);
        let mut ghost = false;
        for d in map_range(0 as size_t, dimension()) {
            if(kc(d) < P.start()(d) || kc(d) >= P.end()(d)) {
                ghost = true;
            }
        }
        if(ghost) {++count;}
    }
    count
}

fn parallel_map_particle_system(start: [size_t * 3], end: [size_t * 3], P: ParticleSystem, numthreads: int, f: fn([size_t * 3], &ParticleList) -> ()) -> () {
    for ic, head in parallel_map_particle_cells(start, end, P, numthreads) {
        for pl in map_list(head) {
            f(ic, pl);
        }
    }
}

fn map_particle_system_with_ghost_layers(start: [size_t * 3], end: [size_t * 3], lower_boundary: [size_t * 3], upper_boundary :[size_t * 3], P: ParticleSystem, f: fn([size_t * 3], &ParticleList, bool) -> ()) -> () {
    for ic, head in map_particle_cells(start, end, P) {
        let mut write = true;
        for d in @map_range(0 as size_t, dimension()) {
            if(ic(d) < lower_boundary(d) || ic(d) >= upper_boundary(d)) {
                write = false;
            }
        }
        for pl in map_list(head) {
            f(ic, pl, write);
        }
    }
}

