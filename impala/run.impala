static mut P_data_ : ParticleSystemData;
static mut array : [i32];
extern 
fn initialize_system(np: size_t, l: &[real]) -> () {
    let mut P = get_particle_system_from_data_struct(P_data_);
    let constants = init_constants();
    let v = get_vector([l(0), l(1), l(2)]);    
    P = init_particle_system(np, v, constants);
    let status = check_invariants(P);
    P_data_ = get_data_struct_from_particle_system(P);
}

extern
fn deallocate_system() -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    deallocate_particle_system(P);
    P_data_ = get_data_struct_from_particle_system(P);
}

extern 
fn time_integration(t_start: real, t_end: real, dt: real, numthreads: int, vtk: bool) -> ()
{
    let P : ParticleSystem = get_particle_system_from_data_struct(P_data_);
    let mut pnc = 1 as size_t;
    for d in @map_range(@null(), @dimension()) {
        pnc *= P.nc()(d);
    }
    let buf = alloc_cpu((pnc * sizeof[Cell]() as size_t) as i32);
   
    let mut t : real = t_start; 
    let mut count = 0 as size_t;
    let mut i = 0 as size_t;
    let mut str : [u8 * 32];
    if(vtk == true && count % (1 as size_t) == (0 as size_t)) {
        let lang = "impala";
        generate_filename(i, "impala", &mut str, 32 as size_t);
        fprint_particle_system(str, i, P);
        ++i;
    }
    let vector : ParticleVector = get_particle_vector(buf, P.nc());
    init_particle_vector(vector, P, false);
    compute_force_vector(P, vector, force_vector);
    while(t < t_end) {
    
        t += dt;        
        integrate_vector(vector, P.start(), P.end(), dt, integrate_x_vector);
        write_back_particle_vector(vector, P);
        move_particles(P);
        init_particle_vector(vector, P, true);
        compute_force_vector(P, vector, force_vector);
        integrate_vector(vector, P.start(), P.end(), dt, integrate_v_vector);
        if(vtk == true && count % (1 as size_t) == (0 as size_t)) {
            write_back_particle_vector(vector, P);
            let lang = "impala";
            generate_filename(i, "impala", &mut str, 32 as size_t);
            fprint_particle_system(str, i, P);
            ++i;
        }
        let status = check_invariants(P);
        ++count;
    }
    clean_up_particle_vector(vector);
    release(buf);
    P_data_ = get_data_struct_from_particle_system(P); 
}

fn print_particle_vector(vector: ParticleVector) -> () {
    for ic, cell in map_particle_vector([@null(),..3], vector.nc(), vector) {
        print_string("Cell \t");
        for d in map_range(@null(), @dimension()) {
            print_i64(ic(d) as i64);
            print_string(" \t");
        }
        print_string("\n");
        let positions = get_array_of_real(cell.positions);
        let forces = get_array_of_real(cell.forces);
        for i in map_range(@null(), cell.size) {
            print_string("Position: \t");
            for d in map_range(@null(), @dimension()) {
                print_f64(positions(i * @dimension() + d));
                print_string(" \t");
            }
            print_string("\n");
            print_string("Force: \t");
            for d in map_range(@null(), @dimension()) {
                print_f64(forces(i * @dimension() + d));
                print_string(" \t");
            }
            print_string("\n");

        }
        print_string("\n");
    }
}

fn print_particle_system(P: ParticleSystem) -> () {
    for ic, head in map_particle_cells([@null(),..3], P.nc(), P) {
        if(head != 0 as &mut ParticleList) { 
            print_string("Cell \t");
            for d in map_range(@null(), @dimension()) {
                print_i64(ic(d) as i64);
                print_string(" \t");
            }
            print_string("\n");
            for pl in map_list(head) {
                let p = get_particle_from_node(pl);
                let pos = p.getCoordinates().get();
                let force = p.getForces().get();
                print_string("Position: \t");
                for d in map_range(@null(), @dimension()) {
                    print_f64(pos(d));
                    print_string(" \t");
                }
                print_string("\n");
                print_string("Force: \t");
                for d in map_range(@null(), @dimension()) {
                    print_f64(force(d));
                    print_string(" \t");
                }

                print_string("\n");
            }

            print_string("\n");
        }
    }
}
