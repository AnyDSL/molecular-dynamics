extern "C"
{
    fn size_t_to_string(size_t, &mut[u8], size_t) -> ();
    fn generate_filename(size_t , &[u8], &mut[u8], size_t) -> ();
    fn open_file(&[u8]) -> u64;
    fn close_file(u64) -> ();
    fn fprint_string(u64, &[u8]) -> ();
    fn fprint_line(u64, &[u8]) -> ();
    fn fprint_double(u64, f64) -> ();
    fn fprint_float(u64, f32) -> ();
    fn fprint_int(u64, i32) -> ();
    fn fprint_size_t(u64, size_t) -> ();
    fn fprint_char(u64, u8) -> ();
    fn allocate(size_t) -> &u8;
    fn allocate_and_initialize(size_t, i32) -> &u8;
    fn initialize(&u8, size_t, i32) -> ();
    fn deallocate(&u8) -> ();
    fn c_random_seed(i64) -> ();
    fn c_random() -> f64;
}

type size_t = u64;
type ptr_t = u64;
type real = f64;
fn dimension() -> size_t {3 as size_t}
fn epsilon() -> real {1e-12}
fn size_of_particle() -> size_t {((1 as size_t) + (4 as size_t) * dimension()) * (sizeof[real]() as size_t)} 

struct Vector
{
    get: fn() -> [real * 3],
    combine: fn(fn(real, real) -> real, Vector) -> Vector,
    map: fn(fn(real) -> real) -> Vector,
    reduce: fn(fn(real, real) -> real, real) -> real,
    print: fn() -> (),
    fprint: fn(u64) -> ()
}


fn get_vector(data: [real * 3]) -> Vector
{
    Vector { 
        get: || {data},
        combine: |f: fn(real, real) -> real, v: Vector| {
            let mut res : [real * 3];
            let v_data = v.get();
            for d in @loop((0 as size_t), dimension()) {
                    res(d) = f(data(d), v_data(d)); 
            }
            get_vector(res)
        },
        map: |f: fn(real) -> real| {
            let mut res : [real * 3];
            for d in @loop(0 as size_t, dimension()) {
                res(d) = f(data(d)); 
            }
            get_vector(res)
        },
        reduce: |f: fn(real, real) -> real, empty: real| {
            let mut acc = empty;
            for d in @loop(0 as size_t, dimension()) {
                acc = f(acc, data(d)); 
            }
            acc
        },
        print: || { 
            for d in @loop(0 as size_t, dimension()-(1 as size_t)) {
                 print_double(data(d));
                 print_char(' ');
            }
            print_double(data(dimension()-(1 as size_t)));
        },
        fprint: |fp| { 
            for d in @loop(0 as size_t, dimension()-(1 as size_t)) {
                 fprint_double(fp, data(d));
                 fprint_char(fp, ' ');
            }
            fprint_double(fp, data(dimension()-(1 as size_t)));
        }

    }
}

fn get_null_vector() -> Vector {get_vector([0 as real,..3])};

fn add_vectors(a: Vector, b: Vector) -> Vector {
    a.combine(|x,y|{x+y}, b)
}

fn sub_vectors(a: Vector, b: Vector) -> Vector {
    a.combine(|x,y|{x-y}, b)
}

fn div_vectors(a: Vector, b: Vector) -> Vector {
    a.combine(|x,y|{x/y}, b)
}

fn scale_vector(alpha: real, v: Vector) -> Vector {
    v.map(|x|{alpha*x})
}

fn increase_vector(v: Vector, alpha: real) -> Vector {
    v.map(|x|{x + alpha})
}

fn square_vector(v: Vector) -> Vector {
    v.map(|x|{x*x})
}

fn vector_sum(v : Vector) -> real {
    v.reduce(|x,y|{x+y}, 0 as real)
}

struct Particle {
    getMass: fn() -> real,
    getCoordinates: fn() -> Vector,
    getVelocities: fn() -> Vector,
    getForces: fn() -> Vector,
    getForces_old: fn() -> Vector,
    setMass: fn(real) -> (),
    setCoordinates: fn(Vector) -> (),
    setVelocities: fn(Vector) -> (),
    setForces: fn(Vector) -> (),
    setForces_old: fn(Vector) -> ()
}

fn get_particle(data: &u8) -> Particle {
    Particle {
        getMass: || {bitcast[&[real]](data)(0)},
        getCoordinates: || {
            let mut res : [real * 3];
            for d in @loop(0 as size_t, dimension()) {
                res(d) = bitcast[&[real]](data)(1 as size_t + d); 
            }
            get_vector(res)
        },
        getVelocities: || {
            let mut res : [real * 3];
            for d in @loop(0 as size_t, dimension()) {
                res(d) = bitcast[&[real]](data)( 1 as size_t + dimension() + d); 
            }
            get_vector(res)
        },
        getForces: || {
            let mut res : [real * 3];
            for d in @loop(0 as size_t, dimension()) {
                res(d) = bitcast[&[real]](data)(1 as size_t + 2 as size_t * dimension() + d); 
            }
            get_vector(res)
        },
        getForces_old: || {
            let mut res : [real * 3];
            for d in @loop(0 as size_t, dimension()) {
                res(d) = bitcast[&[real]](data)( 1 as size_t + 3 as size_t * dimension() + d); 
            }
            get_vector(res)
        },
        setMass: |m| {bitcast[&mut[real]](data)(0) = m;}, 
        setCoordinates: |v| {
            let x = v.get();
            for d in @loop(0 as size_t, dimension()) {
                bitcast[&mut[real]](data)(1 as size_t + d) = x(d); 
            }
        },
        setVelocities: |v| {
            let x = v.get();
            for d in @loop(0 as size_t, dimension()) {
                bitcast[&mut[real]](data)(1 as size_t + dimension() + d) = x(d); 
            }
        },
        setForces: |v| {
            let x = v.get();
            for d in @loop(0 as size_t, dimension()) {
                bitcast[&mut[real]](data)(1 as size_t + 2 as size_t * dimension() + d) = x(d); 
            }
        },
        setForces_old: |v| {
            let x = v.get();
            for d in @loop(0 as size_t, dimension()) {
                bitcast[&mut[real]](data)(1 as size_t + 3 as size_t * dimension() + d) = x(d); 
            }
        }
    }
}

fn print_particle(p: Particle) -> () {
    print_string("Particle\n");
    print_string("Mass: ");
    print_double(p.getMass() as double);
    print_string("\nCoordinates: ");
    p.getCoordinates().print();
    print_string("\nVelocities: ");
    p.getVelocities().print();
    print_string("\nForces: ");
    p.getForces().print();
    print_string("\nForces_old: ");
    p.getForces_old().print();
    print_char('\n');
}


struct ParticleList {
    data: &u8,
    next: &ParticleList
}

fn allocate_particle_node() -> &mut ParticleList {
    let ptr = allocate(sizeof[ParticleList]() as size_t * sizeof[u8]() as size_t) as &mut ParticleList;
    (*ptr).data = allocate(size_of_particle()*(sizeof[u8]() as size_t)); 
    (*ptr).next = 0 as &ParticleList; 
    ptr
}

fn deallocate_particle_node(ptr: &ParticleList) -> () {
    deallocate((*ptr).data);
    deallocate(ptr as &u8);
}

fn get_particle_from_node(pl: &ParticleList) -> Particle {
    get_particle((*pl).data)
}

fn print_particle_node(pl: &ParticleList) -> () {
    let p = get_particle_from_node(*pl);
    print_string("ParticleList\n");
    print_long(pl as i64);
    print_particle(p);
}


fn insert(root: &mut &ParticleList, pl: &mut ParticleList) -> () {

    //print_string("*root: ");
    //print_long(*root as i64);
    //print_char('\n');
    (*pl).next = *root;
    *root = pl;
}

fn remove(root: &mut &ParticleList) -> &mut ParticleList {
    if(*root != 0 as &ParticleList) {
        let retval : &mut ParticleList  = *root;
        *root = (**root).next;
        retval
    }
    else {
        0 as &mut ParticleList
    }
}

fn delete_list(root: &mut &ParticleList) -> () {
    let mut ptr = remove(root);
    while(ptr != 0 as &mut ParticleList)
    {
        deallocate_particle_node(ptr);        
        ptr = remove(root);
    }
}

fn iterate_over_list(ptr: &ParticleList, body: fn(&ParticleList) -> ()) -> () {
    if((ptr) != (0 as & ParticleList)) { 
        body(ptr);
        iterate_over_list((*ptr).next, body, return)
    }
}


fn loop(lower: size_t, upper: size_t, body: fn(size_t) -> ()) -> () {
    if lower < upper {
        body(lower);
        loop(lower+(1 as size_t), upper, body, return)
    }
}

fn par_loop(lower: size_t, upper: size_t, numthreads: int, body: fn(size_t) -> ()) -> () {
    for i in parallel(numthreads, lower as i32, upper as i32) {
        body(i as size_t);
    }
}

fn index(ic: [size_t * 3], nc: [size_t * 3]) -> size_t {
    fn rec(i: size_t) -> size_t {
        if(i == dimension() - 1 as size_t) {ic(i)}
        else {ic(i) + nc(i) * rec(i + 1 as size_t)} 
    }
    @rec(0 as size_t)
    //ic(0) + nc(0)*(ic(1) + nc(1)*ic(2))
}
