extern "C"
{
    fn size_t_to_string(size_t, &mut[u8], size_t) -> ();
    fn generate_filename(size_t , &[u8], &mut[u8], size_t) -> ();
    fn open_file(&[u8]) -> u64;
    fn close_file(u64) -> ();
    fn fprint_string(u64, &[u8]) -> ();
    fn fprint_line(u64, &[u8]) -> ();
    fn fprint_double(u64, f64) -> ();
    fn fprint_float(u64, f32) -> ();
    fn fprint_int(u64, i32) -> ();
    fn fprint_size_t(u64, size_t) -> ();
    fn fprint_char(u64, u8) -> ();
    fn allocate(size_t) -> &u8;
    fn allocate_and_initialize(size_t, i32) -> &u8;
    fn initialize(&u8, size_t, i32) -> ();
    fn deallocate(&u8) -> ();
    fn c_random_seed(u32) -> ();
    fn c_random() -> f64;
}

type size_t = u64;
type ptr_t = u64;
type real = f64;
static INF = 1e308f64;
static EPS = 1e-12;
static DIM = 3 as size_t;
static SIZEOFPARTICLE = ((1 as size_t) + (4 as size_t) * DIM) * (sizeof[real]() as size_t); 


struct Vector
{
    x: fn() -> [real * 3],
    append: fn(fn(real, real) -> real, Vector) -> Vector,
    map: fn(fn(real) -> real) -> Vector,
    reduce: fn(fn(real) -> real, fn(real, real) -> real, real) -> real,
    print: fn() -> (),
    fprint: fn(u64) -> ()
}

fn get_vector(x: [real * 3]) -> Vector
{
    Vector { 
        x: || {x},
        append: |f: fn(real, real) -> real, v: Vector| {
            let mut res : [real * 3];
            let v_x = v.x();
            @loop((0 as size_t), DIM, |d| {
                    res(d) = f(x(d), v_x(d)); 
            });
            get_vector(res)
        },
        map: |f: fn(real) -> real| {
            let mut res : [real * 3];
            @loop(0 as size_t, DIM, |d| {
                res(d) = f(x(d)); 
            });
            get_vector(res)
        },
        reduce: |f: fn(real) -> real, g: fn(real, real) -> real, empty: real| {
            let mut acc = empty;
            @loop(0 as size_t, DIM, |d| {
                acc = g(acc, f(x(d))); 
            });
            acc
        },
        print: || { 
            @loop(0 as size_t, DIM-(1 as size_t), |d| {
                 print_double(x(d));
                 print_char(' ');
            });
            print_double(x(DIM-(1 as size_t)));
        },
        fprint: |fp| { 
            @loop(0 as size_t, DIM-(1 as size_t), |d| {
                 fprint_double(fp, x(d));
                 fprint_char(fp, ' ');
            });
            fprint_double(fp, x(DIM-(1 as size_t)));
        }

    }
}

fn get_null_vector() -> Vector
{
    let mut res : [real * 3];
    @loop(0 as size_t, DIM, |d| {
        res(d) = 0.0; 
    });
    get_vector(res)
}

fn add_vectors(a: Vector, b: Vector) -> Vector {
    a.append(|x,y|{x+y}, b)
}

fn sub_vectors(a: Vector, b: Vector) -> Vector {
    a.append(|x,y|{x-y}, b)
}

fn div_vectors(a: Vector, b: Vector) -> Vector {
    a.append(|x,y|{x/y}, b)
}

fn scale_vector(alpha: real, v: Vector) -> Vector {
    v.map(|x|{alpha*x})
}

fn increase_vector(alpha: real, v: Vector) -> Vector {
    v.map(|x|{x + alpha})
}

struct Particle {
    getMass: fn() -> real,
    getCoordinates: fn() -> Vector,
    getVelocities: fn() -> Vector,
    getForces: fn() -> Vector,
    getForces_old: fn() -> Vector,
    setMass: fn(real) -> (),
    setCoordinates: fn(Vector) -> (),
    setVelocities: fn(Vector) -> (),
    setForces: fn(Vector) -> (),
    setForces_old: fn(Vector) -> ()
}

fn get_particle(data: &u8) -> Particle 
{
    Particle {
        getMass: || {bitcast[&[real]](data)(0)},
        getCoordinates: || {
            let mut res : [real * 3];
            @loop(0 as size_t, DIM, |d| {
                res(d) = bitcast[&[real]](data)((1 as size_t)+d); 
            });
            get_vector(res)
        },
        getVelocities: || {
            let mut res : [real * 3];
            @loop(0 as size_t, DIM, |d| {
                res(d) = bitcast[&[real]](data)((1 as size_t)+DIM+d); 
            });
            get_vector(res)
        },
        getForces: || {
            let mut res : [real * 3];
            @loop(0 as size_t, DIM, |d| {
                res(d) = bitcast[&[real]](data)((1 as size_t)+(2 as size_t)*DIM+d); 
            });
            get_vector(res)
        },
        getForces_old: || {
            let mut res : [real * 3];
            @loop(0 as size_t, DIM, |d| {
                res(d) = bitcast[&[real]](data)((1 as size_t)+(3 as size_t)*DIM+d); 
            });
            get_vector(res)
        },
        setMass: |m| {bitcast[&mut[real]](data)(0) = m;}, 
        setCoordinates: |v| {
            let x = v.x();
            @loop(0 as size_t, DIM, |d| {
                bitcast[&mut[real]](data)((1 as size_t)+d) = x(d); 
            });
        },
        setVelocities: |v| {
            let x = v.x();
            @loop(0 as size_t, DIM, |d| {
                bitcast[&mut[real]](data)((1 as size_t)+DIM+d) = x(d); 
            });
        },
        setForces: |v| {
            let x = v.x();
            @loop(0 as size_t, DIM, |d| {
                bitcast[&mut[real]](data)((1 as size_t)+(2 as size_t)*DIM+d) = x(d); 
            });
        },
        setForces_old: |v| {
            let x = v.x();
            @loop(0 as size_t, DIM, |d| {
                bitcast[&mut[real]](data)((1 as size_t)+(3 as size_t)*DIM+d) = x(d); 
            });
        }
    }
}

fn print_particle(p: Particle) -> () {
    print_string("Particle\n");
    print_string("Mass: ");
    print_double(p.getMass() as double);
    print_string("\nCoordinates: ");
    p.getCoordinates().print();
    print_string("\nVelocities: ");
    p.getVelocities().print();
    print_string("\nForces: ");
    p.getForces().print();
    print_string("\nForces_old: ");
    p.getForces_old().print();
    print_char('\n');
}


struct ParticleList {
    data: &u8,
    next: &ParticleList
}

fn allocate_particle_node() -> &mut ParticleList {
    let ptr = allocate(sizeof[ParticleList]() as size_t * sizeof[u8]() as size_t) as &mut ParticleList;
    (*ptr).data = allocate(SIZEOFPARTICLE*(sizeof[u8]() as size_t)); 
    (*ptr).next = 0 as &ParticleList; 
    ptr
}

fn deallocate_particle_node(ptr: &ParticleList) -> () {
    deallocate((*ptr).data);
    deallocate(ptr as &u8);
}

fn get_particle_from_node(pl: &ParticleList) -> Particle {
    get_particle((*pl).data)
}

fn print_particle_node(pl: &ParticleList) -> () {
    let p = get_particle_from_node(*pl);
    print_string("ParticleList\n");
    print_long(pl as i64);
    print_particle(p);
}


fn insert(root: &mut &ParticleList, pl: &mut ParticleList) -> () {

    //print_string("*root: ");
    //print_long(*root as i64);
    //print_char('\n');
    (*pl).next = *root;
    *root = pl;
}

fn remove(root: &mut &ParticleList) -> &mut ParticleList {
    if(*root != 0 as &ParticleList) {
        let retval : &mut ParticleList  = *root;
        *root = (**root).next;
        retval
    }
    else {
        0 as &mut ParticleList
    }
}

fn delete_list(root: &mut &ParticleList) -> () {
    let mut ptr = remove(root);
    while(ptr != 0 as &mut ParticleList)
    {
        deallocate_particle_node(ptr);        
        ptr = remove(root);
    }
}

fn iterate_over_list(ptr: &ParticleList, body: fn(&ParticleList) -> ()) -> () {
    if((ptr) != (0 as & ParticleList)) { 
        body(ptr);
        iterate_over_list((*ptr).next, body, return)
    }
}


fn loop(lower: size_t, upper: size_t, body: fn(size_t) -> ()) -> () {
    if lower < upper {
        body(lower);
        loop(lower+(1 as size_t), upper, body, return)
    }
}

fn par_loop(lower: size_t, upper: size_t, numthreads: int, body: fn(size_t) -> ()) -> () {
    for i in parallel(numthreads, lower as i32, upper as i32) {
        body(i as size_t);
    }
}

fn index(ic: [size_t * 3], nc: [size_t * 3]) -> size_t {
    ic(0) + nc(0)*(ic(1) + nc(1)*ic(2))
}

