fn init_particle_system(np: size_t, l: Vector, constants: Constants) -> ParticleSystem {
    c_random_seed(89 as u32);
    let ghost_layer = 1 as size_t;
    let mut limit : [size_t * 3];
    let N = math.floor(math.pow(np as real, 1.0/3.0));
    let mut domain : [real * 3];
    let spacing = 2.0 * constants.r_cut;
    let v_max : real = 200.0;
    for d in @loop(0 as size_t, DIM) {
        domain(d) = (N+2.0) * spacing;
        limit(d) = N as size_t;
    }
    let P = allocate_particle_system(limit(0)*limit(1)*limit(2), ghost_layer, get_vector(domain), constants);
    let mut ip : [size_t * 3];
    for d in @loop(0 as size_t, DIM) {
        ip(d) = 0 as size_t;
    }
    while(ip(0) < limit(0)) {
        while(ip(1) < limit(1)) {
            while(ip(2) < limit(2)) {
                let node = allocate_particle_node();
                let p = get_particle_from_node(node);
                p.setMass(1.0);
                let mut X : [real * 3];
                for d in @loop(0 as size_t, DIM) {
                    X(d) = spacing + ip(d) as real * spacing;
                }
                let mut V : [real * 3];
                for d in @loop(0 as size_t, DIM) {
                    let tmp = v_max*c_random() as real;
                    if(flip_coin()) {
                        V(d) = tmp;
                    }
                    else {
                        V(d) = -tmp;
                    }
                }
                p.setCoordinates(get_vector(X));
                p.setVelocities(get_vector(V));
                let pos = ip(2)*limit(0)*limit(1) + ip(1)*limit(1) + ip(0);
                insert_particle(node, pos, P); 
                ++ip(2);
            }
            ++ip(1);
            ip(2) = 0 as size_t;
        }
        ++ip(0);
        ip(1) = 0 as size_t;
    }
    /*
    let mut i = (ip(2)*limit(0)*limit(1) + ip(1)*limit(1) + ip(0))+1 as size_t;
    while(i < np) {
        let node = allocate_particle_node();
        let p = get_particle_from_node(node);
        p.setMass(1.0);
        let mut X : [real * 3];
        let mut V : [real * 3];
        for d in @loop(0 as size_t, DIM) {
            X(d) = get_vector(domain).x()(d) * c_random() as real;
            let tmp = v_max*c_random() as real;
            if(flip_coin()) {
                V(d) = tmp;
            }
            else {
                V(d) = -tmp;
            }
        }
        p.setCoordinates(get_vector(X));
        p.setVelocities(get_vector(V));
        let pos = i;
        insert_particle(node, pos, P); 
        ++i;
    }*/
    init_addresses(P);
    P
}

fn flip_coin() -> bool {
    if(c_random() > 0.5) { true } else {false}
}

