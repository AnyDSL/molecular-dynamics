/*fn print_particle_system(P: ParticleSystem) -> (){    
    let mut ic_start : [size_t * 3];
    let ic_end = P.nc();
    for d in @map_range(0 as size_t, @dimension()) {
        ic_start(d) = 0 as size_t;
    }

    for k in map_range(ic_start(2), ic_end(2)) {
        for j in map_range(ic_start(1), ic_end(1)) {
            for i in map_range(ic_start(0), ic_end(0)) {
                let ic = [i,j,k];
                if(*P.head(index(ic, P.nc())) != 0 as &mut ParticleList) {
                    print_string("Cell (");
                    print_i64(i as i64);
                    print_string(", ");
                    print_i64(j as i64);
                    print_string(", ");
                    print_i64(k as i64);
                    print_string("): ");
                    print_string(" (Index: ");
                    print_i64(index(ic, P.nc()) as i64);
                    print_string(" ) ");
                    for pl in map_list(*P.head(index(ic, P.nc()))) {
                        print_i64((*pl).data as i64);
                        print_char(' ');
                    }
                    print_char('\n');
                }
            }
        }
    }
}*/

fn compute_cell_position(p: Particle, P: ParticleSystem) -> [size_t * 3] {
    let mut kc : [size_t * 3];
    let coordinates_x = p.getCoordinates().get();
    let tmp = P.tmp().get();
    let nc = P.nc();
    for d in @map_range((0 as size_t), @dimension()) {
        kc(d) = math.floor((coordinates_x(d) + P.offset()) * tmp(d)) as size_t;
    }
    kc
}




fn map_particle_cells(start: [size_t * 3], end: [size_t * 3], P: ParticleSystem, f: fn([size_t * 3], &mut ParticleList) -> ()) -> () {
    for k in map_range(start(2), end(2)) {
        for j in map_range(start(1), end(1)) {
            for i in map_range(start(0), end(0)){
                let ic = [i,j,k];
                f(ic, *P.head(index(ic, P.nc())));
            }
        }
    }
}
fn parallel_map_particle_cells(start: [size_t * 3], end: [size_t * 3], P: ParticleSystem, numthreads: int, f: fn([size_t * 3], &mut ParticleList) -> ()) -> () {
    for k in parallel_map_range(start(2), end(2), numthreads) {
        for j in map_range(start(1), end(1)) {
            for i in map_range(start(0), end(0)){
                let ic = [i,j,k];
                f(ic, *P.head(index(ic, P.nc())));
            }
        }
    }
}

fn map_particle_system(start: [size_t * 3], end: [size_t * 3], P: ParticleSystem, f: fn([size_t * 3], &mut ParticleList) -> ()) -> () {
    for ic, head in map_particle_cells(start, end, P) {
        for pl in map_list(head) {
            f(ic, pl);
        }
    }
}

fn count_ghost_particles(P: ParticleSystem) -> size_t {
    let mut count : size_t = @null();
    for ic, pl, isLocal in map_particle_system_with_ghost_layers([@null(),..3], P.np(), P.start(), P.end(), P) {
        let p = get_particle_from_node(pl, isLocal);
        let kc = compute_cell_position(p, P);
        let mut ghost = false;
        for d in map_range(@null(), @dimension()) {
            if(kc(d) < P.start()(d) || kc(d) >= P.end()(d)) {
                ghost = true;
            }
        }
        if(ghost) {++count;}
    }
    count
}

fn parallel_map_particle_system(start: [size_t * 3], end: [size_t * 3], P: ParticleSystem, numthreads: int, f: fn([size_t * 3], &mut ParticleList) -> ()) -> () {
    for ic, head in parallel_map_particle_cells(start, end, P, numthreads) {
        for pl in map_list(head) {
            f(ic, pl);
        }
    }
}

fn map_particle_system_with_ghost_layers(start: [size_t * 3], end: [size_t * 3], lower_boundary: [size_t * 3], upper_boundary :[size_t * 3], P: ParticleSystem, f: fn([size_t * 3], &mut ParticleList, bool) -> ()) -> () {
    for ic, head in map_particle_cells(start, end, P) {
        let mut write = true;
        for d in @map_range(0 as size_t, @dimension()) {
            if(ic(d) < lower_boundary(d) || ic(d) >= upper_boundary(d)) {
                write = false;
            }
        }
        for pl in map_list(head) {
            f(ic, pl, write);
        }
    }
}

