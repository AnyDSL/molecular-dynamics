fn compute_force(P: ParticleSystem, force: fn(InteractionVector, Constants, size_t) -> (), numthreads: int) -> () {
    let vcapacity = 4 as size_t;
    let mut vindex = @null();
    let interaction_vector = allocate_interaction_vector(vcapacity);

    //for ic, pl1 in $parallel_map_particle_system(P.start(), P.end(), P, numthreads) @{
    for ic, pl1 in $map_particle_system(P.start(), P.end(), P) @{
        let p1 = get_particle_from_node(pl1);
        p1.setForces(@get_null_vector());
    }

    let mut ic_start : [size_t * 3];
    for d in @map_range(@null(), @dimension()) {
        ic_start(d) = @null();
    }
    let ic_end = P.nc();
    //for ic, head in $parallel_map_particle_cells(ic_start, ic_end, P, numthreads) @{ 
    for ic, head in $map_particle_cells(ic_start, ic_end, P) @{
        let mut jc_start : [size_t * 3]; 
        let mut jc_end : [size_t * 3];
        let mut write_i = true;
        for d in @map_range(@null(), @dimension()) {
            if(ic(d) >= P.start()(d)) {
                jc_start(d) = ic(d) - @one();
            } 
            else {
                jc_start(d) = ic(d) + @one();
                write_i = false;
            };
            if(ic(d) < P.end()(d)) { 
                jc_end(d) = ic(d) + @two(); 
            } 
            else {
                jc_end(d) = ic(d);
                write_i = false;
            };
        }

        let positions1  = get_array_of_real_vector(interaction_vector.positions1);
        let forces1     = get_array_of_real_vector(interaction_vector.forces1);
        let positions2  = get_array_of_real_vector(interaction_vector.positions2);
        let forces2     = get_array_of_real_vector(interaction_vector.forces2);
        let nodes2      = get_array_of_nodes(interaction_vector.nodes);
        let writeBack2  = get_array_of_bools(interaction_vector.writeBack); 

        for pl1 in $map_list(head) @{

            let p1 = get_particle_from_node(pl1);
            for i in @map_range(@null(), vcapacity) {
                for d in @map_range(@null(), @dimension()) {
                    positions1(i * VECTOR_LENGTH + d) = p1.getCoordinates().get()(d);
                }
                for d in @map_range(@dimension(), VECTOR_LENGTH) {
                    positions1(i * VECTOR_LENGTH + d) = 0.0;
                }
                for d in @map_range(@null(), VECTOR_LENGTH) {
                    forces1(i * VECTOR_LENGTH + d) = 0.0;
                }
            }
            for jc, pl2, write_j in $map_particle_system_with_ghost_layers(jc_start, jc_end, P.start(), P.end(), P) @{
                if(vindex == vcapacity) {
                    // compute force
                    force(interaction_vector, P.constants(), vindex);
                    for j in $map_range(@null(), vindex) @{
                        let p2 = get_particle_from_node(nodes2(j));
                        if(writeBack2(j)) {
                            let mut F_new : [real * 3];
                            for d in @map_range(@null(), @dimension()) {
                                F_new(d) = forces2(j * VECTOR_LENGTH + d);
                            }
                            p2.setForces(get_vector(F_new));
                        }
                    }
                    vindex = @null();
                }
                if((pl1 as uintptr_t < pl2 as uintptr_t)) {
                    let p2 = get_particle_from_node(pl2);
                    nodes2(vindex) = pl2;
                    writeBack2(vindex) = write_j;
                    let pos2 = p2.getCoordinates().get();
                    let force2 = p2.getForces().get();
                    for d in @map_range(@null(), @dimension()) {
                        positions2(vindex * VECTOR_LENGTH + d) = pos2(d);
                        forces2(vindex * VECTOR_LENGTH + d) = force2(d);
                    }
                    for d in @map_range(@dimension(), VECTOR_LENGTH) {
                        positions2(vindex * VECTOR_LENGTH + d) = 0.0;
                        forces2(vindex * VECTOR_LENGTH + d) = 0.0;
                    }
                    ++vindex;
                }
            }
            force(interaction_vector, P.constants(), vindex);
            if(write_i) {
                let mut F_new = p1.getForces().get();
                for i in @map_range(@null(), vindex) {
                    for d in @map_range(@null(), @dimension()) {
                        F_new(d) += forces1(i * VECTOR_LENGTH + d);
                    }
                }
                p1.setForces(get_vector(F_new));
            }
            for j in $map_range(@null(), vindex) @{
                let p2 = get_particle_from_node(nodes2(j));
                if(writeBack2(j)) {
                    let mut F_new : [real * 3];
                    for d in @map_range(@null(), @dimension()) {
                        F_new(d) = forces2(j * VECTOR_LENGTH + d);
                    }
                    p2.setForces(get_vector(F_new));
                }
            }
            vindex = @null();
        }
    }
    deallocate_interaction_vector(interaction_vector);
}
/*
fn copy_in_vector_for_force_calculation(pl: &mut ParticleList, write1: bool, write2: bool, index: size_t, interaction_vector: ParticleVector) {

    let nodes = get_array_of_nodes(interaction_vector.nodes);
    let positions = get_array_of_real_vector(interaction_vector.positions);
    let forces = get_array_of_real_vector(interaction_vector.forces);
    let writeBack1 = get_array_of_bools(interaction_vector.writeBack1); 
    let writeBack2 = get_array_of_bools(interaction_vector.writeBack2); 

    let p = get_particle_from_node(pl);
    let pos = p.getCoordinates().get();
    let force = p.getForces().get();
    node_array(index) = pl;
    writeBack1(index) = write1;
    writeBack2(index) = write2;
    for d in @map_range(@null(), @dimension()) {
        positions(@dimension() * index + d) = pos1(d);
        forces(@dimension() * index + d) = force1(d);
    }

}*/

