fn compute_force(P: ParticleSystem, force: fn(&[real * 4], &[real * 4], &mut[real * 4], &mut[real * 4], Constants) -> (), numthreads: int) -> () {
    let vcapacity1 = 1 as size_t;
    let vcapacity2 = 4 as size_t;
    let mut vindex1 = @null();
    let mut vindex2 = @null();
    let particle_vector = allocate_particle_vector(vcapacity1, vcapacity2);

    for ic, pl1 in $parallel_map_particle_system(P.start(), P.end(), P, numthreads) @{
        let p1 = get_particle_from_node(pl1);
        p1.setForces(@get_null_vector());
    }

    let mut ic_start : [size_t * 3];
    for d in @map_range(@null(), @dimension()) {
        ic_start(d) = @null();
    }
    let ic_end = P.nc();
    for ic, head in $parallel_map_particle_cells(ic_start, ic_end, P, numthreads) @{
        let mut jc_start : [size_t * 3]; 
        let mut jc_end : [size_t * 3];
        let mut write_i = true;
        for d in @map_range(@null(), @dimension()) {
            if(ic(d) >= P.start()(d)) {
                jc_start(d) = ic(d) - @one();
            } 
            else {
                jc_start(d) = ic(d) + @one();
                write_i = false;
            };
            if(ic(d) < P.end()(d)) { 
                jc_end(d) = ic(d) + @two(); 
            } 
            else {
                jc_end(d) = ic(d);
                write_i = false;
            };
        }
        let nodes1 = get_array_of_nodes(particle_vector.nodes1);
        let positions1 = get_array_of_real_vector(particle_vector.positions1);
        let forces1 = get_array_of_real_vector(particle_vector.forces1);
        let writeBack1 = get_array_of_bools(particle_vector.writeBack1); 

        let nodes2 = get_array_of_nodes(particle_vector.nodes2);
        let positions2 = get_array_of_real_vector(particle_vector.positions2);
        let forces2 = get_array_of_real_vector(particle_vector.forces2);
        let writeBack2 = get_array_of_bools(particle_vector.writeBack2); 

        let start_index = get_array_of_indices(particle_vector.start_index); 
        let end_index = get_array_of_indices(particle_vector.end_index); 

        for pl1 in $map_list(head) @{

            let p1 = get_particle_from_node(pl1);
            if(vindex1 < vcapacity1) {
                nodes1(vindex1) = pl1;
                writeBack1(vindex1) = write_i;
                let pos1 = p1.getCoordinates().get();
                let force1 = p1.getForces().get();
                for d in @map_range(@null(), @dimension()) {
                    positions1(vindex1)(d) = pos1(d);
                    forces1(vindex1)(d) = force1(d);
                }
                positions1(vindex1)(3) = 0.0;
                forces1(vindex1)(3) = 0.0;
                start_index(vindex1) = vindex2;
                ++vindex1;

                for jc, pl2, write_j, in $map_particle_system_with_ghost_layers(jc_start, jc_end, P.start(), P.end(), P) @{
                    if(vindex2 < vcapacity2) {
                        if((pl1 as uintptr_t < pl2 as uintptr_t)) {
                            let p2 = get_particle_from_node(pl2);
                            nodes2(vindex2) = pl2;
                            writeBack2(vindex2) = write_j;
                            let pos2 = p2.getCoordinates().get();
                            let force2 = p2.getForces().get();
                            for d in @map_range(@null(), @dimension()) {
                                positions2(vindex2)(d) = pos2(d);
                                forces2(vindex2)(d) = force2(d);
                            }
                            positions2(vindex2)(3) = 0.0;
                            forces2(vindex2)(3) = 0.0;
                            ++vindex2;
                        }
                    }
                    else {
                        end_index(vindex1 - @one()) = vindex2;
                        // compute force
                        for i in $map_range(@null(), vindex1) @{
                            for j in $map_range(start_index(i), end_index(i)) {
                                force(&positions1(i), &positions2(j), &mut forces1(i), &mut forces2(j), P.constants());
                            }
                        } 

                        for i in $map_range(@null(), vindex1 - @one()) @{
                            if(writeBack1(i)) {
                                let mut F_new : [real * 3];
                                for d in @map_range(@null(), @dimension()) {
                                    F_new(d) = forces1(i)(d);
                                }
                                p1.setForces(get_vector(F_new));
                            }
                            for j in $map_range(start_index(i), end_index(i)) @{
                                let p2 = get_particle_from_node(pl2);
                                if(writeBack2(j)) {
                                    let mut F_new : [real * 3];
                                    for d in @map_range(@null(), @dimension()) @{
                                        F_new(d) = forces2(j)(d);
                                    }
                                    p2.setForces(get_vector(F_new));
                                }
                            }
                        }
                        let i = vindex1 - @one();
                        if(writeBack1(i)) {
                            let mut F_new : [real * 3];
                            for d in @map_range(@null(), @dimension()) @{
                                F_new(d) = forces1(i)(d);
                            }
                            p1.setForces(get_vector(F_new));
                        }
                        for j in $map_range(start_index(i), end_index(i)) @{
                            let p2 = get_particle_from_node(pl2);
                            if(writeBack2(j)) {
                                let mut F_new : [real * 3];
                                for d in @map_range(@null(), @dimension()) {
                                    F_new(d) = forces2(j)(d);
                                }
                                p2.setForces(get_vector(F_new));
                            }
                        }
                        
                        for d in @map_range(@null(), @dimension()) @{
                            forces1(0)(d) = forces1(i)(d);
                            positions1(i)(d) = positions1(i)(d);
                        }
                        writeBack1(0) = writeBack1(i);
                        nodes1(0) = nodes1(i);
                        start_index(0) = @null();
                        vindex1 = @one();
                    }
                }
            }
            else {
                for i in $map_range(@null(), vcapacity1) @{
                    for j in $map_range(start_index(i), end_index(i)) @{
                        force(&positions1(i), &positions2(j), &mut forces1(i), &mut forces2(j), P.constants());
                    }
                } 
                for i in $map_range(@null(), vcapacity2) @{
                    if(writeBack1(i)) {
                        let mut F_new : [real * 3];
                        for d in @map_range(@null(), @dimension()) {
                            F_new(d) = forces1(i)(d);
                        }
                        p1.setForces(get_vector(F_new));
                    }
                    for j in $map_range(start_index(i), end_index(i)) @{
                        let pl2 = nodes2(j);
                        let p2 = get_particle_from_node(pl2);
                        if(writeBack2(j)) {
                            let mut F_new : [real * 3];
                            for d in @map_range(@null(), @dimension()) {
                                F_new(d) = forces2(j)(d);
                            }
                            p2.setForces(get_vector(F_new));
                        }
                    }
                }
                vindex1 = @null();
            }
        }
    }
}
/*
fn copy_in_vector_for_force_calculation(pl: &mut ParticleList, write1: bool, write2: bool, index: size_t, particle_vector: ParticleVector) {

    let nodes = get_array_of_nodes(particle_vector.nodes);
    let positions = get_array_of_real_vector(particle_vector.positions);
    let forces = get_array_of_real_vector(particle_vector.forces);
    let writeBack1 = get_array_of_bools(particle_vector.writeBack1); 
    let writeBack2 = get_array_of_bools(particle_vector.writeBack2); 

    let p = get_particle_from_node(pl);
    let pos = p.getCoordinates().get();
    let force = p.getForces().get();
    node_array(index) = pl;
    writeBack1(index) = write1;
    writeBack2(index) = write2;
    for d in @map_range(@null(), @dimension()) {
        positions(@dimension() * index + d) = pos1(d);
        forces(@dimension() * index + d) = force1(d);
    }

}*/

