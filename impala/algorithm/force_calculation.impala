fn compute_force(P: ParticleSystem, force: fn(&[real * 4], &[real * 4], &mut[real * 4], &mut[real * 4], Constants) -> (), numthreads: int) -> () {
    let vcapacity = 1 as size_t;
    let mut vindex = @null();
    let interaction_vector = allocate_interaction_vector(vcapacity);
    init_interaction_vector_with_zero(interaction_vector);

    //for ic, pl1 in $parallel_map_particle_system(P.start(), P.end(), P, numthreads) @{
    for ic, pl1 in $map_particle_system(P.start(), P.end(), P) @{
        let p1 = get_particle_from_node(pl1);
        p1.setForces(@get_null_vector());
    }

    let mut ic_start : [size_t * 3];
    for d in @map_range(@null(), @dimension()) {
        ic_start(d) = @null();
    }
    let ic_end = P.nc();
    //for ic, head in $parallel_map_particle_cells(ic_start, ic_end, P, numthreads) @{ 
    for ic, head in $map_particle_cells(ic_start, ic_end, P) @{
        let mut jc_start : [size_t * 3]; 
        let mut jc_end : [size_t * 3];
        let mut write_i = true;
        for d in @map_range(@null(), @dimension()) {
            if(ic(d) >= P.start()(d)) {
                jc_start(d) = ic(d) - @one();
            } 
            else {
                jc_start(d) = ic(d) + @one();
                write_i = false;
            };
            if(ic(d) < P.end()(d)) { 
                jc_end(d) = ic(d) + @two(); 
            } 
            else {
                jc_end(d) = ic(d);
                write_i = false;
            };
        }
        let nodes = get_array_of_nodes(interaction_vector.nodes);
        let positions = get_array_of_real_vector(interaction_vector.positions);
        let forces = get_array_of_real_vector(interaction_vector.forces);
        let writeBack = get_array_of_bools(interaction_vector.writeBack); 
        for pl1 in $map_list(head) @{
            let p1 = get_particle_from_node(pl1);
            let mut X1 : [real * 4] = [0.0,..4];
            let mut F1 : [real * 4] = [0.0,..4];
            for d in @map_range(@null(), @dimension()) {
                X1(d) = p1.getCoordinates().get()(d);
                F1(d) = p1.getForces().get()(d);
            }
            for jc, pl2, write_j, in $map_particle_system_with_ghost_layers(jc_start, jc_end, P.start(), P.end(), P) @{
                if(vindex < vcapacity) {
                    if((pl1 as uintptr_t < pl2 as uintptr_t)) {
                        let p2 = get_particle_from_node(pl2);
                        nodes(vindex) = pl2;
                        writeBack(vindex) = write_j;
                        let pos2 = p2.getCoordinates().get();
                        let force2 = p2.getForces().get();
                        for d in @map_range(@null(), @dimension()) {
                            positions(vindex)(d) = pos2(d);
                            forces(vindex)(d) = force2(d);
                        }
                        positions(vindex)(3) = 0.0;
                        forces(vindex)(3) = 0.0;
                        ++vindex;
                    }
                }
                
                else {
                    // compute force
                    //for j in vectorize(4, 64, 0, vindex as i32) {
                    for j in $map_range(@null(), vindex) @{
                        force(&X1, &positions(j), &mut F1, &mut forces(j), P.constants());
                    }
                    for j in $map_range(@null(), vindex) @{
                        let p2 = get_particle_from_node(nodes(j));
                        if(writeBack(j)) {
                            let mut F_new : [real * 3];
                            for d in @map_range(@null(), @dimension()) {
                                F_new(d) = forces(j)(d);
                            }
                            p2.setForces(get_vector(F_new));
                        }
                    }
                    vindex = @null();
                }
            } 
            //for j in vectorize(4, 64, 0, vindex as i32) {
            for j in $map_range(@null(), vindex) @{
                force(&X1, &positions(j), &mut F1, &mut forces(j), P.constants());
            }
            if(write_i) {
                let mut F_new : [real * 3];
                for d in @map_range(@null(), @dimension()) {
                    F_new(d) = F1(d);
                }
                p1.setForces(get_vector(F_new));
            }
            for j in $map_range(@null(), vindex) @{
                let p2 = get_particle_from_node(nodes(j));
                if(writeBack(j)) {
                    let mut F_new : [real * 3];
                    for d in @map_range(@null(), @dimension()) {
                        F_new(d) = forces(j)(d);
                    }
                    p2.setForces(get_vector(F_new));
                }
            }
            vindex = @null();
        }
    }
    deallocate_interaction_vector(interaction_vector);
}
/*
fn copy_in_vector_for_force_calculation(pl: &mut ParticleList, write1: bool, write2: bool, index: size_t, interaction_vector: ParticleVector) {

    let nodes = get_array_of_nodes(interaction_vector.nodes);
    let positions = get_array_of_real_vector(interaction_vector.positions);
    let forces = get_array_of_real_vector(interaction_vector.forces);
    let writeBack1 = get_array_of_bools(interaction_vector.writeBack1); 
    let writeBack2 = get_array_of_bools(interaction_vector.writeBack2); 

    let p = get_particle_from_node(pl);
    let pos = p.getCoordinates().get();
    let force = p.getForces().get();
    node_array(index) = pl;
    writeBack1(index) = write1;
    writeBack2(index) = write2;
    for d in @map_range(@null(), @dimension()) {
        positions(@dimension() * index + d) = pos1(d);
        forces(@dimension() * index + d) = force1(d);
    }

}*/

