
fn compute_force(P: ParticleSystem, force: fn(Particle, Particle, bool, bool, Constants) -> (), numthreads: int) -> () {
    for ic, pl1 in $parallel_iterate_over_particle_system(P.start(), P.end(), P, numthreads) @{
        let p1 = get_particle_from_node(pl1);
        p1.setForces(get_null_vector());
    }
    let z = 0 as size_t;
    let mut ic_start : [size_t * 3];
    for d in @loop(0 as size_t, DIM) {
        ic_start(d) = z;
    }
    let ic_end = P.nc();
    /*
    print_string("ic_start: ");
    print_long(ic_start(0) as i64);
    print_string(", ");
    print_long(ic_start(1) as i64);
    print_string(", ");
    print_long(ic_start(2) as i64);
    print_string("\n");
    print_string("ic_end: ");
    print_long(ic_end(0) as i64);
    print_string(", ");
    print_long(ic_end(1) as i64);
    print_string(", ");
    print_long(ic_end(2) as i64);
    print_string("\n");
    */
    for ic, head in $parallel_iterate_over_particle_cells(ic_start, ic_end, P, numthreads) @{
        let mut jc_start : [size_t * 3]; 
        let mut jc_end : [size_t * 3];
        let mut write_i = true;
        for d in @loop(0 as size_t, DIM) {
            if(ic(d) >= P.start()(d)) {
                jc_start(d) = ic(d) - 1 as size_t;
            } 
            else {
                jc_start(d) = ic(d) + 1 as size_t;
                write_i = false;
            };
            if(ic(d) < P.end()(d)) { 
                jc_end(d) = ic(d) + 2 as size_t; 
            } 
            else {
                jc_end(d) = ic(d);
                write_i = false;
            };
        }
        for pl1 in iterate_over_list(head) @{
            let p1 = get_particle_from_node(pl1);
            for jc, pl2, write_j, in $iterate_over_particle_system_with_ghost_layers(jc_start, jc_end, P.start(), P.end(), P) @{
                @count_collision();
                if((pl1 as ptr_t < pl2 as ptr_t)) {
                    let p1 = get_particle_from_node(pl1);
                    let p2 = get_particle_from_node(pl2);
                    force(p1, p2, write_i, write_j, P.constants());
                }
            }
        }
    }
}
fn update(P: ParticleSystem, start: [size_t * 3], end: [size_t * 3], dt: real, numthreads: int, f: fn(Particle, real) -> ()) -> () {
    for ic, pl in $parallel_iterate_over_particle_system(start, end, P, numthreads) @{
        let p = get_particle_from_node(pl);
        f(p, dt);
    }
}
fn move_particles(P: ParticleSystem) -> () {
    let start = P.start();
    let end = P.end();
    for k in loop(start(2), end(2)) {
        for j in loop(start(1), end(1)) {
            for i in loop(start(0), end(0)) @{
                let ic = [i,j,k];
                let mut q : &mut& ParticleList = P.head(index(ic, P.nc()));
                let mut i : &ParticleList = *q;
                while(i != 0 as &ParticleList) {    
                    let p = get_particle_from_node(i); 
                    boundary(p, P);
                    let kc = compute_cell_position(p, P);
                    let mut moving_node : &mut ParticleList;
                    if(ic(0) != kc(0) || ic(1) != kc(1) || ic(2) != kc(2)) {
                        moving_node = remove(q);
                        insert(P.head(index(kc, P.nc())), moving_node);
                    }
                    else {
                        q = &((*i).next) as &mut& ParticleList;
                    }
                    i = (*q);
                }

            }
        }
    }
}
fn fprint_particle_system(fname: &[u8], step: size_t, P: ParticleSystem) -> ()
{
    let start = 0 as size_t;
    let fp = open_file(fname);
    let N = P.np();

    fprint_line(fp, "# vtk DataFile Version 2.0");
    fprint_string(fp, "Step ");
    fprint_size_t(fp, step);
    fprint_line(fp, " data");
    fprint_line(fp, "ASCII");
    fprint_line(fp, "DATASET UNSTRUCTURED_GRID");
    fprint_string(fp, "POINTS ");
    fprint_size_t(fp, N);
    fprint_line(fp, " double");
    
    let addresses = P.addresses();

    for i in loop(start, N) {
        let p = get_particle(addresses.get(i));
        p.getCoordinates().fprint(fp);
        fprint_string(fp, "\n");
    }
    fprint_string(fp, "\n\n");
    fprint_string(fp, "CELLS ");
    fprint_size_t(fp, N);
    fprint_string(fp, " ");
    fprint_size_t(fp, (2 as size_t)*N);

    fprint_string(fp, "\n");
    for i in loop(start, N){
        fprint_string(fp, "1 ");
        fprint_size_t(fp, i);
        fprint_string(fp, "\n");
    }
    fprint_string(fp, "\n\n");


    fprint_string(fp, "CELL_TYPES ");
    fprint_size_t(fp, N);
    fprint_string(fp, "\n");
    for i in loop(start, N) {
        fprint_string(fp, "1");
        fprint_string(fp, "\n");
    }

    fprint_string(fp, "\n\n");


    fprint_string(fp, "POINT_DATA ");
    fprint_size_t(fp, N);
    fprint_string(fp, "\n");
    for d in loop(start, DIM) {
        fprint_string(fp, "SCALARS velocity_dim_");
        fprint_size_t(fp, d);
        fprint_line(fp, " double");
        fprint_line(fp, "LOOKUP_TABLE default");
        for i in loop(start, N) {
            let p = get_particle(addresses.get(i));
            let v = p.getVelocities();
            let x = v.x();
            fprint_double(fp, x(d));
            fprint_string(fp, "\n");
        }
        fprint_string(fp, "\n");
    }
    for d in loop(start, DIM) {
        fprint_string(fp, "SCALARS force_dim_");
        fprint_size_t(fp, d);
        fprint_line(fp, " double");
        fprint_line(fp, "LOOKUP_TABLE default");
        for i in loop(start, N) {
            let p = get_particle(addresses.get(i));
            let v = p.getForces();
            let x = v.x();
            fprint_double(fp, x(d));
            fprint_string(fp, "\n");
        }
        fprint_string(fp, "\n");
    }

    fprint_string(fp, "SCALARS mass");
    fprint_line(fp, " double");
    fprint_line(fp, "LOOKUP_TABLE default");
    for i in loop(start, N) {
        let p = get_particle(addresses.get(i));
        let m = p.getMass();
        fprint_double(fp, m);
        fprint_string(fp, "\n");
    }
    fprint_string(fp, "\n");
    close_file(fp);
}
