struct ParticleSystem {
    np: fn() -> size_t,
    l: fn() -> Vector,
    getParticle: fn(size_t) -> Particle,
    lut: fn() -> LookupTable,
    constants: fn() -> Constants,
    data: fn() -> &u8
}

fn get_particle_system(np: size_t, l: Vector, data: &u8, lut: LookupTable, constants: Constants) -> ParticleSystem {
    ParticleSystem {
        np: || {np},
        l: || {l},
        getParticle: |i| {get_particle(&bitcast[&[u8]](data)(i*SIZEOFPARTICLE))},
        lut: || {lut},
        constants: || {constants},
        data: || {data}
    }
}

fn allocate_particle_system(np: size_t, l: Vector, ghost_layer: size_t, constants: Constants) -> ParticleSystem {
    let data = allocate(np * SIZEOFPARTICLE);
    let lut = allocate_lookup_table(np);
    get_particle_system(np, l, data, lut, constants) 
}

fn deallocate_particle_system(P: ParticleSystem) -> () {
    deallocate(P.data());
    deallocate_lookup_table(P.lut());
}

fn insert_particle(node: &mut ParticleList, i: size_t, P: ParticleSystem) -> () {
    let p = P.getParticle(i);
    let p_new = get_particle_from_node(*node);
    p.setMass(p_new.getMass());
    p.setCoordinates(p_new.getCoordinates());
    p.setVelocities(p_new.getVelocities());
    p.setForces(p_new.getForces());
    p.setForces_old(p_new.getForces_old());
    deallocate_particle_node(node);
}


struct LookupTable {
    rows: fn() -> size_t,
    cols: fn() -> size_t,
    data: &u8
}

fn allocate_lookup_table(size: size_t) -> LookupTable {
    LookupTable {
        rows: || {size/2 as size_t + 0 as size_t},
        //rows: || {size},
        cols: || {size},
        data: {allocate((size * (size / 2 as size_t + 0 as size_t) * sizeof[u8]() as size_t))}
        //data: {allocate(size * size)}
    }
}

fn deallocate_lookup_table(lut: LookupTable) -> () {
    deallocate(lut.data);
}


fn init_addresses(P: ParticleSystem) -> () {}
