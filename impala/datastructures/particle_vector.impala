struct InteractionVector {
    capacity: size_t,
    positions: Buffer, 
    forces: Buffer,
    nodes: Buffer,
    writeBack: Buffer
}

fn allocate_interaction_vector(capacity: size_t) -> InteractionVector {
    InteractionVector {
        capacity: capacity,
        positions: alloc_cpu((capacity * sizeof[[real * 4]]() as size_t) as i32), 
        forces: alloc_cpu((capacity * sizeof[[real * 4]]() as size_t) as i32),
        nodes: alloc_cpu((capacity * sizeof[&mut ParticleList]() as size_t) as i32),
        writeBack: alloc_cpu((capacity * sizeof[bool]() as size_t) as i32)
    }
}

fn deallocate_interaction_vector(vector: InteractionVector) -> () {
    release(vector.positions);
    release(vector.forces);
    release(vector.nodes);
    release(vector.writeBack);
}

fn get_array_of_real_vector(buf: Buffer) -> &mut[[real * 4]] {
    bitcast[&mut[[real * 4]]](buf.data) 
}

fn get_array_of_bools(buf: Buffer) -> &mut[bool] {
    bitcast[&mut[bool]](buf.data) 
}

fn get_array_of_nodes(buf: Buffer) -> &mut[&mut ParticleList] {
    bitcast[&mut[&mut ParticleList]](buf.data) 
}

fn init_interaction_vector_with_zero(vector: InteractionVector) -> () {
    let capacity = vector.capacity;
    let nodes = get_array_of_nodes(vector.nodes);
    let positions = get_array_of_real_vector(vector.positions);
    let forces = get_array_of_real_vector(vector.forces);
    let writeBack = get_array_of_bools(vector.writeBack); 
    for i in $map_range(@null(), capacity) {
        /*nodes(i) = 0 as &mut ParticleList;
        writeBack(i) = false;
        for d in @map_range(@null(), @dimension()) {
            positions(i)(d) = 0.0; 
            forces(i)(d) = 0.0;
        }*/
    }
}
