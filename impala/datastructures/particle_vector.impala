static VECTOR_LENGTH = 4 as size_t;
type index_t = [size_t * 3];
struct ParticleVector {
    nc: fn() -> index_t,
    getCell: fn(size_t) -> Cell,
    setCell: fn(size_t, Cell) -> ()
}


struct Cell {
    size: size_t,
    masses: Buffer,
    positions: Buffer,
    velocities: Buffer,
    forces: Buffer,
    forces_old: Buffer,
    nodes: Buffer
}

fn allocate_cell(size: size_t) -> Cell {
    if(size > @null()) {
        Cell {
            size: size,
            masses: alloc_cpu((@dimension() * size * sizeof[real]() as size_t) as i32), 
            positions: alloc_cpu((@dimension() * size * sizeof[real]() as size_t) as i32), 
            velocities: alloc_cpu((@dimension() * size * sizeof[real]() as size_t) as i32), 
            forces: alloc_cpu((@dimension() * size * sizeof[real]() as size_t) as i32), 
            forces_old: alloc_cpu((@dimension() * size * sizeof[real]() as size_t) as i32), 
            nodes: alloc_cpu((size * sizeof[&mut ParticleList]() as size_t) as i32)
        }
    }
    else {
        Cell {
            size: @null(),
            masses: Buffer {device: 0, data: 0 as &[i8]},
            positions: Buffer {device: 0, data: 0 as &[i8]},
            velocities: Buffer {device: 0, data: 0 as &[i8]},
            forces: Buffer {device: 0, data: 0 as &[i8]},
            forces_old: Buffer {device: 0, data: 0 as &[i8]},
            nodes: Buffer {device: 0, data: 0 as &[i8]}
        }
    }
}

fn get_particle_vector(buf: Buffer, nc: index_t) -> ParticleVector {
    ParticleVector {
        nc: || {nc},
        getCell: |i| {
            bitcast[&[Cell]](buf.data)(i)
        },
        setCell: |i, cell| {
            bitcast[&mut[Cell]](buf.data)(i) = cell;
        }
    }
}

fn init_particle_vector(vector: ParticleVector, P: ParticleSystem, reinit: bool) -> () {
    for ic, head in $map_particle_cells([@null(),..3], P.nc(), P) @{
        let mut count = @null();
        for pl in $map_list(head) {
            ++count;
        }
        let i = index(ic, vector.nc());
        if(reinit) {
            let cell = vector.getCell(i);
            if(count != cell.size) {
                deallocate_cell(cell);
                vector.setCell(i, allocate_cell(count));
            }
        }
        else { 
            vector.setCell(i, allocate_cell(count));
        }
        let cell        = vector.getCell(i);
        if(cell.size != @null()) {
            let masses      = get_array_of_real(cell.masses);
            let positions   = get_array_of_real(cell.positions);
            let velocities  = get_array_of_real(cell.velocities);
            let forces      = get_array_of_real(cell.forces);
            let forces_old  = get_array_of_real(cell.forces_old);
            let nodes       = get_array_of_nodes(cell.nodes);
            let mut j = @null();
            for pl in $map_list(head) @{
                let p = get_particle_from_node(pl);
                let base = j * @dimension();
                for d in @map_range(@null(), @dimension()) {
                    masses(base + d) = p.getMass();
                    positions(base + d) = p.getCoordinates().get()(d);
                    velocities(base + d) = p.getVelocities().get()(d);
                    forces(base + d) = p.getForces().get()(d);
                    forces_old(base + d) = p.getForces_old().get()(d);
                }
                nodes(j) = pl;
                ++j;
            }
        }
    }
}


fn write_back_particle_vector(vector: ParticleVector, P: ParticleSystem) -> () {
    for ic, cell in $map_particle_vector(P.start(), P.end(), vector) @{
        let i = index(ic, vector.nc());
        let cell = vector.getCell(i);
        if(cell.size != @null()) {
            let positions   = get_array_of_real(cell.positions);
            let velocities  = get_array_of_real(cell.velocities);
            let forces      = get_array_of_real(cell.forces);
            let nodes       = get_array_of_nodes(cell.nodes);
            for j in map_range(@null(), cell.size) @{
                let p = get_particle_from_node(nodes(j));
                let base = j * @dimension();
                let mut pos : [real * 3];
                let mut vel : [real * 3];
                let mut force : [real * 3];
                for d in @map_range(@null(), @dimension()) {
                    pos(d) = positions(base + d);
                    vel(d) = velocities(base + d);
                    force(d) = forces(base + d);
                }
                p.setCoordinates(get_vector(pos));
                p.setVelocities(get_vector(vel));
                p.setForces(get_vector(force));
            }
        }
    }
}

fn clean_up_particle_vector(vector: ParticleVector) -> () {
    for ic, cell in $map_particle_vector([@null(),..3], vector.nc(), vector) @{
        deallocate_cell(cell);
    }
}

fn deallocate_cell(cell: Cell) -> () {
    release(cell.masses);
    release(cell.positions);
    release(cell.velocities);
    release(cell.forces);
    release(cell.forces_old);
    release(cell.nodes);
}

fn get_array_of_real(buf: Buffer) -> &mut[real] {
    bitcast[&mut[real]](buf.data) 
}

fn get_array_of_i8(buf: Buffer) -> &mut[i8] {
    bitcast[&mut[i8]](buf.data) 
}

fn get_array_of_nodes(buf: Buffer) -> &mut[&mut ParticleList] {
    bitcast[&mut[&mut ParticleList]](buf.data) 
}

fn map_particle_vector(start: index_t, end: index_t, vector: ParticleVector, f: fn(index_t, Cell) -> ()) -> () { 
    for k in $map_range(start(2), end(2)) {
        for j in $map_range(start(1), end(1)) {
            for i in $map_range(start(0), end(0)) @{
                let ic = [i,j,k];
                let cell = vector.getCell(index(ic, vector.nc()));
                if(cell.size != @null()) {
                    f(ic, cell);
                }
            }
        }
    }
}
