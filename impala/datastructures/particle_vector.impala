struct InteractionVector {
    capacity: size_t,
    positions: &[i8], 
    forces: &[i8],
    nodes: &[i8],
    writeBack: &[i8]
}

fn allocate_interaction_vector(capacity: size_t) -> InteractionVector {
    InteractionVector {
        capacity: capacity,
        positions: allocate(capacity * sizeof[[real * 4]]() as size_t), 
        forces: allocate(capacity * sizeof[[real * 4]]() as size_t),
        nodes: allocate(capacity * sizeof[&mut ParticleList]() as size_t),
        writeBack: allocate(capacity * sizeof[bool]() as size_t)
    }
}

fn deallocate_interaction_vector(vector: InteractionVector) -> () {
    deallocate(vector.positions);
    deallocate(vector.forces);
    deallocate(vector.nodes);
    deallocate(vector.writeBack);
}

fn get_array_of_real_vector(data: &[i8]) -> &mut[[real * 4]] {
    bitcast[&mut[[real * 4]]](data) 
}

fn get_array_of_bools(data: &[i8]) -> &mut[bool] {
    bitcast[&mut[bool]](data) 
}

fn get_array_of_nodes(data: &[i8]) -> &mut[&mut ParticleList] {
    bitcast[&mut[&mut ParticleList]](data) 
}

fn init_interaction_vector_with_zero(vector: InteractionVector) -> () {
    let capacity = vector.capacity;
    let nodes = get_array_of_nodes(vector.nodes);
    let positions = get_array_of_real_vector(vector.positions);
    let forces = get_array_of_real_vector(vector.forces);
    let writeBack = get_array_of_bools(vector.writeBack); 
    for i in $map_range(@null(), capacity) {
        /*nodes(i) = 0 as &mut ParticleList;
        writeBack(i) = false;
        for d in @map_range(@null(), @dimension()) {
            positions(i)(d) = 0.0; 
            forces(i)(d) = 0.0;
        }*/
    }
}
