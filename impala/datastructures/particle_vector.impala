static VECTOR_LENGTH = 4 as size_t;
type index_t = [size_t * 3];
struct ParticleVector {
    nc: fn() -> index_t,
    getCell: fn(size_t) -> Cell,
    setCell: fn(size_t, Cell) -> ()
}


struct Cell {
    size: size_t,
    padded_size: size_t,
    masses: &[i8],
    positions: &[i8],
    velocities: &[i8],
    forces: &[i8],
    forces_old: &[i8],
    nodes: &[i8]
}
fn get_padded_size(n: size_t) -> size_t {
    let mut k = 1 as size_t;
    while (k < n) {
        k *= 2 as size_t;
    }
    k
}

fn allocate_cell(size: size_t) -> Cell {
    if(size > SIZE_T_0) {
        let padded_size = get_padded_size(DIMENSION * size);
        Cell {
            size: size,
            padded_size: padded_size,
            masses: allocate((padded_size * sizeof[real]() as size_t) as size_t), 
            positions: allocate((padded_size * sizeof[real]() as size_t) as size_t), 
            velocities: allocate((padded_size * sizeof[real]() as size_t) as size_t), 
            forces: allocate((padded_size * sizeof[real]() as size_t) as size_t), 
            forces_old: allocate((padded_size * sizeof[real]() as size_t) as size_t), 
            nodes: allocate((size * sizeof[&mut ParticleList]() as size_t) as size_t)
        }
    }
    else {
        Cell {
            size: SIZE_T_0,
            padded_size: SIZE_T_0,
            masses: 0 as &[i8],
            positions: 0 as &[i8],
            velocities: 0 as &[i8],
            forces: 0 as &[i8],
            forces_old: 0 as &[i8],
            nodes: 0 as &[i8]
        }
    }
}

fn get_particle_vector(data: &[i8], nc: index_t) -> ParticleVector {
    ParticleVector {
        nc: || {nc},
        getCell: |i| {
            bitcast[&[Cell]](data)(i)
        },
        setCell: |i, cell| {
            bitcast[&mut[Cell]](data)(i) = cell;
        }
    }
}

fn init_particle_vector(vector: ParticleVector, P: ParticleSystem, reinit: bool) -> () {
    for ic, head in $map_particle_cells([SIZE_T_0,..3], P.nc(), P) @{
        let mut count = SIZE_T_0;
        for pl in $map_list(head) {
            ++count;
        }
        let i = index(ic, vector.nc());
        if(reinit) {
            let cell = vector.getCell(i);
            if(count != cell.size) {
                deallocate_cell(cell);
                vector.setCell(i, allocate_cell(count));
            }
        }
        else { 
            vector.setCell(i, allocate_cell(count));
        }
        let cell        = vector.getCell(i);
        if(cell.size != SIZE_T_0) {
            let masses      = get_array_of_real(cell.masses);
            let positions   = get_array_of_real(cell.positions);
            let velocities  = get_array_of_real(cell.velocities);
            let forces      = get_array_of_real(cell.forces);
            let forces_old  = get_array_of_real(cell.forces_old);
            let nodes       = get_array_of_nodes(cell.nodes);
            let mut j = SIZE_T_0;
            for pl in $map_list(head) @{
                let p = get_particle_from_node(pl);
                let base = j * DIMENSION;
                for d in @map_range(SIZE_T_0, DIMENSION) {
                    masses(base + d) = p.getMass();
                    positions(base + d) = p.getCoordinates().get()(d);
                    velocities(base + d) = p.getVelocities().get()(d);
                    forces(base + d) = p.getForces().get()(d);
                    forces_old(base + d) = p.getForces_old().get()(d);
                }
                nodes(j) = pl;
                ++j;
            }
        }
    }
}


fn write_back_particle_vector(vector: ParticleVector, start: index_t, end: index_t, P: ParticleSystem) -> () {
    for ic, cell in $map_particle_vector(start, end, vector) @{
        let i = index(ic, vector.nc());
        let cell = vector.getCell(i);
        let positions   = get_array_of_real(cell.positions);
        let velocities  = get_array_of_real(cell.velocities);
        let forces      = get_array_of_real(cell.forces);
        let forces_old  = get_array_of_real(cell.forces_old);
        let nodes       = get_array_of_nodes(cell.nodes);
        for j in map_range(SIZE_T_0, cell.size) @{
            let p = get_particle_from_node(nodes(j));
            let base = j * DIMENSION;
            let mut pos : [real * 3];
            let mut vel : [real * 3];
            let mut force : [real * 3];
            let mut force_old : [real * 3];
            for d in @map_range(SIZE_T_0, DIMENSION) {
                pos(d) = positions(base + d);
                vel(d) = velocities(base + d);
                force(d) = forces(base + d);
                force_old(d) = forces_old(base + d);
            }
            p.setCoordinates(get_vector(pos));
            p.setVelocities(get_vector(vel));
            p.setForces(get_vector(force));
            p.setForces_old(get_vector(force_old));
        }
    }
}

fn clean_up_particle_vector(vector: ParticleVector) -> () {
    for ic, cell in $map_particle_vector([SIZE_T_0,..3], vector.nc(), vector) @{
        deallocate_cell(cell);
    }
}

fn deallocate_cell(cell: Cell) -> () {
    if(cell.size == SIZE_T_0) {}
    else {
        deallocate(cell.masses);
        deallocate(cell.positions);
        deallocate(cell.velocities);
        deallocate(cell.forces);
        deallocate(cell.forces_old);
        deallocate(cell.nodes);
    }
}

fn get_array_of_real(data: &[i8]) -> &mut[real] {
    bitcast[&mut[real]](data) 
}

fn get_array_of_i8(data: &[i8]) -> &mut[i8] {
    bitcast[&mut[i8]](data) 
}

fn get_array_of_nodes(data: &[i8]) -> &mut[&mut ParticleList] {
    bitcast[&mut[&mut ParticleList]](data) 
}

fn map_particle_vector(start: index_t, end: index_t, vector: ParticleVector, f: fn(index_t, Cell) -> ()) -> () { 
    for k in $map_range(start(2), end(2)) {
        for j in $map_range(start(1), end(1)) {
            for i in $map_range(start(0), end(0)) @{
                let ic = [i,j,k];
                let cell = vector.getCell(index(ic, vector.nc()));
                if(cell.size != SIZE_T_0) {
                    f(ic, cell);
                }
            }
        }
    }
}

fn print_particle_vector(vector: ParticleVector) -> () {
    for ic, cell in map_particle_vector([SIZE_T_0,..3], vector.nc(), vector) {
        print_string("Cell \t");
        for d in map_range(SIZE_T_0, DIMENSION) {
            print_i64(ic(d) as i64);
            print_string(" \t");
        }
        print_string("\n");
        let positions = get_array_of_real(cell.positions);
        let velocities = get_array_of_real(cell.velocities);
        let forces = get_array_of_real(cell.forces);
        for i in map_range(SIZE_T_0, cell.size) {
            print_string("Position: \t");
            for d in map_range(SIZE_T_0, DIMENSION) {
                print_f64(positions(i * DIMENSION + d));
                print_string(" \t");
            }
            print_string("\n");
            print_string("Velocity: \t");
            for d in map_range(SIZE_T_0, DIMENSION) {
                print_f64(velocities(i * DIMENSION + d));
                print_string(" \t");
            }
            print_string("\n");

            print_string("Force: \t");
            for d in map_range(SIZE_T_0, DIMENSION) {
                print_f64(forces(i * DIMENSION + d));
                print_string(" \t");
            }
            print_string("\n");

        }
        print_string("\n");
    }
}

