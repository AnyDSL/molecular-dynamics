struct ParticleSystem {
    np: fn() -> size_t,
    nc: fn() -> [size_t * 3],
    ghost_layer: fn() -> size_t,
    start: fn() -> [size_t * 3],
    end: fn() -> [size_t * 3],
    l: fn() -> Vector,
    tmp: fn() -> Vector,
    offset: fn() -> real,
    head: fn(size_t) -> &mut &mut ParticleList,
    constants: fn() -> Constants,
    addresses: fn() -> ArrayOfAddresses,
    data_cells: fn() -> &[i8],
    data_addresses: fn() -> &[i8]
}



fn get_particle_system(np: size_t, nc: [size_t * 3], ghost_layer: size_t, l: Vector, data_cells: &[i8], constants: Constants, data_addresses: &[i8]) -> ParticleSystem {
    ParticleSystem {
        np: || {np},
        nc: || {nc},
        ghost_layer: || {ghost_layer},
        start: || {
            let mut start : [size_t * 3];
            for d in @map_range(0 as size_t, @dimension()) {
                start(d) = ghost_layer;
            }
            start
        },
        end: || {
            let mut end : [size_t * 3];
            for d in @map_range(0 as size_t, @dimension()) {
                end(d) = nc(d) - ghost_layer;
            }
            end
        },
        l: || {l},
        tmp: ||{
            let a = get_vector([nc(0) as real, nc(1) as real, nc(2) as real]);
            div_vectors(a, l)
        },
        offset: || {ghost_layer as real * constants.r_cut},
        head: |i| {&mut bitcast[&mut[&mut ParticleList]](data_cells)(i)},
        constants: || {constants},
        addresses: || {get_array_of_addresses(np, data_addresses)},
        data_cells: || {data_cells},
        data_addresses: || {data_addresses}
    }
}

struct ParticleSystemData {
    np: size_t,
    nc: [size_t * 3],
    ghost_layer: size_t,
    l: [real * 3],
    constants: Constants,
    data_cells: &[i8],
    data_addresses: &[i8]
}

fn get_particle_system_from_data_struct(P_data: ParticleSystemData) -> ParticleSystem {
    get_particle_system(P_data.np, P_data.nc, P_data.ghost_layer, get_vector(P_data.l), P_data.data_cells, P_data.constants, P_data.data_addresses)
}

fn get_data_struct_from_particle_system(P: ParticleSystem) -> ParticleSystemData {
    ParticleSystemData {
        np: P.np(),
        nc: P.nc(),
        ghost_layer: P.ghost_layer(),
        l: P.l().get(),
        constants: P.constants(),
        data_cells: P.data_cells(),
        data_addresses: P.data_addresses()
    }
}


fn insert_particle(node: &mut ParticleList, i: size_t, P: ParticleSystem) -> () {
    let p = get_particle_from_node(node);
    let kc = compute_cell_position(p, P);
    let root = P.head(index(kc, P.nc()));
    insert(root, node);
}

fn push_node(node: &mut ParticleList, P: ParticleSystem) -> () {
    let mut pos : [size_t * 3];
    for d in @map_range(0 as size_t, @dimension()) {
        pos(d) = P.nc()(d) / 2 as size_t;
    }
    let root = P.head(index(pos, P.nc()));
    insert(root, node);
}

fn allocate_particle_system(np: size_t, ghost_layer: size_t, l: Vector, constants: Constants) -> ParticleSystem {
    let mut nc : [size_t * 3];
    let mut pnc = 1 as size_t;
    let l_extended = increase_vector(l, 2.0*(ghost_layer as real)*constants.r_cut); 
    for d in @map_range(0 as size_t, @dimension()){
        nc(d) = math.floor(l.get()(d)/constants.r_cut) as size_t + (2 as size_t * ghost_layer);
        pnc *= nc(d);
    }
    let data_cells = allocate_and_initialize(pnc * sizeof[&mut ParticleList]() as size_t, 0);
    //print_string("Data size: ");
    //print_double((pnc * sizeof[&mut ParticleList]() as size_t + np * (SIZEOFPARTICLE + sizeof[ParticleList]() as size_t) ) as real / 1e6);
    //print_string(" MB\n");
    let data_addresses = allocate(np * sizeof[&[i8]]() as size_t);
    let P = get_particle_system(np, nc, ghost_layer, l_extended, data_cells, constants, data_addresses);
    P
}

fn deallocate_particle_system(P: ParticleSystem) -> () {
    let z = 0 as size_t;
    let start = [z,z,z];
    let end = P.nc();
    for i in map_range(start(0), end(0)) {
        for j in map_range(start(1), end(1)) {
            for k in map_range(start(2), end(2)) {
                let ic = [i,j,k];
                let head = P.head(index(ic, P.nc()));
                delete_list(head);
            }
        }
    }
    deallocate(P.data_cells());
    deallocate(P.data_addresses());
}


