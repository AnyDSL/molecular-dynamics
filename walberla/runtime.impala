static mut P_data_ : ParticleSystemData;

extern
fn impala_initialize_particle_system(np: size_t, ghost_layer: size_t, domain: &[real], coordinate_shift: &[real]) -> () { 
    let constants = init_constants();
    let domain_v = get_vector([domain(0), domain(1), domain(2)]);    
    let coordinate_shift_v = get_vector([coordinate_shift(0), coordinate_shift(1), coordinate_shift(2)]);    
    let P = allocate_particle_system(np, ghost_layer, domain_v, coordinate_shift_v, constants); 
    for i in map_range(0 as size_t, np) {
        let node = allocate_particle_node();
        push_node(node, P);
    }
    init_addresses(P);
    P_data_ = get_data_struct_from_particle_system(P);
}

extern
fn impala_reinitialize_particle_system(np: size_t) -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    let np_old = P.np();
    if(np_old != np) {
        let constants = P.constants();
        let data_cells = P.data_cells();
        let ghost_layer = P.ghost_layer();
        let domain = P.domain();
        let coordinate_shift = P.coordinate_shift();
        let nc = P.nc();
        deallocate(P.data_addresses());
        let data_addresses = allocate(np * sizeof[&u8]() as size_t);
        let P_new = get_particle_system(np, nc, ghost_layer, domain, coordinate_shift, data_cells, constants, data_addresses);
        if(np_old > np) {
            let mut end = 1 as size_t;
            for d in @map_range(0 as size_t, dimension()) {
                end *= nc(d);
            }
            let mut j = np_old as size_t;
            let mut c = 0 as size_t;
            while (j > np as size_t && c < end) {
                let head = P_new.head(c);
                let node = remove(head);
                if(node != 0 as &mut ParticleList) {
                    deallocate_particle_node(node);
                    --j;
                }
                else {
                    ++c;
                }
            }
        }
        else {        
            for j in map_range(np_old, np) {
                let node = allocate_particle_node();
                push_node(node, P_new);
            }
        }
        init_addresses(P_new);
        P_data_ = get_data_struct_from_particle_system(P_new);        
    }
}
extern 
fn impala_get_number_of_particles() -> size_t {
    let P = get_particle_system_from_data_struct(P_data_);
    P.np()
}
extern
fn impala_distribute_particles() -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    move_particles(P);
}
extern
fn impala_force_calculation() -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    compute_force(P, force, 1);
}

// TODO Segfault here
/*extern
fn impala_get_number_of_ghost_particles() -> size_t {
    let P = get_particle_system_from_data_struct(P_data_);
    count_ghost_particles(P)
}*/

extern
fn impala_map_particles(np_local: size_t, np_shadow: size_t) -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    let addresses = P.addresses();
    for i in $map_range(@null(), np_local) @{
        let pl = addresses.get(i);
        pl.index = i;
        pl.isLocal = true;
    }
    for i in $map_range(np_local, np_local + np_shadow) @{
        let pl = addresses.get(i);
        pl.index = i - np_local;
        pl.isLocal = false;
    }
}

extern
fn impala_map_particles_and_integrate_position(dt: real, np_local: size_t, np_shadow: size_t) -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    let addresses = P.addresses();
    for i in $map_range(@null(), np_local) @{
        let pl = addresses.get(i);
        pl.index = i;
        pl.isLocal = true;
        let p = get_particle_from_node(pl);
        integrate_x(p, dt);
    }
    for i in $map_range(np_local, np_local + np_shadow) @{
        let pl = addresses.get(i);
        pl.index = i - np_local;
        pl.isLocal = false;
        let p = get_particle_from_node(pl);
        integrate_x(p, dt);
    }
}

extern
fn impala_position_integration(dt: real) -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    integrate_local_particles(P, [@null(),..3], P.nc(), dt, 1, integrate_x);
}

extern
fn impala_velocity_integration(dt: real) -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    integrate(P, P.start(), P.end(), dt, 1, integrate_v);
}


extern
fn impala_deallocate_particle_system() -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    deallocate_particle_system(P);
}

extern
fn impala_fprint_particle_system(i: size_t) -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    let mut str : [u8 * 32];
    generate_filename(i, "impala", &mut str, 32 as size_t);
    fprint_particle_system(str, i, P);
}

extern
fn impala_check_invariants() -> () {
    let P = get_particle_system_from_data_struct(P_data_);
    check_invariants(P);
}
