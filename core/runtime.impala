static mut grid_ : Grid;
static mut comm_offsets_ : CommOffsets;
static mut force_iters : i64;
static mut rsq_iters : i64;
static mut integration_iters : i64;

extern fn md_set_thread_count(thread_count: i32) -> () { set_thread_count(thread_count); }

extern fn md_initialize_grid(
    masses: &[real_t],
    positions: &[Vector3D],
    velocities: &[Vector3D],
    nparticles: i32,
    min: &[real_t],
    max: &[real_t],
    rank_min: &[real_t],
    rank_max: &[real_t],
    cell_spacing: real_t,
    cell_capacity: i32,
    neighborlist_capacity: i32) -> i32 {

    let world_aabb = AABB {
        xmin: min(0),
        xmax: max(0),
        ymin: min(1),
        ymax: max(1),
        zmin: min(2),
        zmax: max(2)
    };

    let rank_aabb = AABB {
        xmin: rank_min(0) - cell_spacing,
        xmax: rank_max(0) + cell_spacing,
        ymin: rank_min(1) - cell_spacing,
        ymax: rank_max(1) + cell_spacing,
        zmin: rank_min(2) - cell_spacing,
        zmax: rank_max(2) + cell_spacing
    };

    grid_ = allocate_grid(world_aabb, rank_aabb, cell_spacing, cell_capacity, neighborlist_capacity);
    initialize_grid(masses, positions, velocities, nparticles, &mut grid_, alloc_cpu);
    initialize_comm_offsets(grid_, &mut comm_offsets_);

    device().warmup();

    grid_.nparticles
}

extern fn md_rescale_grid(min: &[real_t], max: &[real_t]) -> () {
    let aabb = AABB {
        xmin: min(0) - grid_.spacing,
        xmax: max(0) + grid_.spacing,
        ymin: min(1) - grid_.spacing,
        ymax: max(1) + grid_.spacing,
        zmin: min(2) - grid_.spacing,
        zmax: max(2) + grid_.spacing
    };

    rescale_grid(&mut grid_, aabb);
}

extern fn md_get_node_bounding_box(
    min: &[real_t],
    max: &[real_t],
    rank_min: &mut[real_t * 3],
    rank_max: &mut[real_t * 3]) -> () {

    let aabb = AABB {
        xmin: min(0),
        xmax: max(0),
        ymin: min(1),
        ymax: max(1),
        zmin: min(2),
        zmax: max(2)
    };

    let rank_aabb = get_node_bounding_box(aabb);

    rank_min(0) = rank_aabb.xmin;
    rank_min(1) = rank_aabb.ymin;
    rank_min(2) = rank_aabb.zmin;

    rank_max(0) = rank_aabb.xmax;
    rank_max(1) = rank_aabb.ymax;
    rank_max(2) = rank_aabb.zmax;
}

extern fn md_compute_boundary_weights(
    xmin: real_t,
    xmax: real_t,
    ymin: real_t,
    ymax: real_t,
    zmin: real_t,
    zmax: real_t,
    computational_weight: &mut u32,
    communication_weight: &mut u32) -> () {

    let aabb = AABB {
        xmin: xmin,
        xmax: xmax,
        ymin: ymin,
        ymax: ymax,
        zmin: zmin,
        zmax: zmax
    };

    range(0, grid_.nparticles + grid_.nghost, |particle_index| {
        let pos = array_get_host(ParticleDataLayout(), grid_.positions, particle_index);

        if is_within_domain(pos, aabb) {
            if particle_index < grid_.nparticles {
                *computational_weight += 1 as u32;
            } else {
                *communication_weight += 1 as u32;
            }
        }
    });
}

extern fn md_clear_domain(xmin: real_t, xmax: real_t, ymin: real_t, ymax: real_t, zmin: real_t, zmax: real_t) -> () {
    let aabb = AABB {
        xmin: xmin,
        xmax: xmax,
        ymin: ymin,
        ymax: ymax,
        zmin: zmin,
        zmax: zmax
    };

    let mut particle_index = 0;

    while particle_index < grid_.nparticles {
        let pos = array_get(ParticleDataLayout(), grid_.positions, particle_index);

        if is_within_domain(pos, aabb) {
            delete_particle(particle_index, &mut grid_);
        } else {
            particle_index++;
        }
    }
}

extern fn md_copy_data_to_accelerator() -> () { copy_to_accelerator(grid_); }
extern fn md_copy_data_from_accelerator() -> () { copy_from_accelerator(grid_); }
extern fn md_deallocate_grid() -> () { deallocate_grid(&mut grid_); }
extern fn md_integration(dt: real_t) -> () { integration_iters = accelerator_integration(grid_, dt); }
extern fn md_initial_integration(dt: real_t) -> () { integration_iters = accelerator_initial_integration(grid_, dt); }
extern fn md_final_integration(dt: real_t) -> () { integration_iters = accelerator_final_integration(grid_, dt); }

extern fn md_write_grid_data_to_arrays(
    masses: &mut[real_t],
    positions: &mut [Vector3D],
    velocities: &mut [Vector3D],
    forces: &mut [Vector3D]) -> i32 {

    write_grid_data_to_arrays(masses, positions, velocities, forces, &grid_)
}

extern fn md_write_grid_ghost_data_to_arrays(
    masses: &mut[real_t],
    positions: &mut [Vector3D],
    velocities: &mut [Vector3D],
    forces: &mut [Vector3D]) -> i32 {

    write_grid_ghost_data_to_arrays(masses, positions, velocities, forces, &grid_)
}

extern fn md_write_grid_aabb_data_to_arrays(
    masses: &mut[real_t],
    positions: &mut [Vector3D],
    velocities: &mut [Vector3D],
    forces: &mut [Vector3D]) -> i32 {

    write_grid_aabb_data_to_arrays(masses, positions, velocities, forces, &grid_)
}

extern fn md_distribute_particles() -> () { distribute_particles(&mut grid_); }
extern fn md_borders() -> () { borders(&mut grid_, &mut comm_offsets_); }
extern fn md_exchange_particles() -> () { exchange_particles(&mut grid_, &mut comm_offsets_); }
extern fn md_initialize_clusters() -> () { }
extern fn md_assemble_neighborlists(cutoff_distance: real_t) -> () { assemble_neighborlists(&mut grid_, cutoff_distance); }

extern fn md_print_grid() -> () {
    range(0, grid_.nparticles, |particle_index| {
        let pos = array_get_host(ParticleDataLayout(), grid_.positions, particle_index);
        print_real_vector_with_rank("pos_local", pos);
    });
}

extern fn md_print_ghost() -> () {
    range(grid_.nparticles, grid_.nparticles + grid_.nghost, |particle_index| {
        let pos = array_get_host(ParticleDataLayout(), grid_.positions, particle_index);
        print_real_vector_with_rank("pos_ghost", pos);
    });
}

extern fn md_compute_forces(cutoff_distance: real_t, epsilon: real_t, sigma: real_t) -> () {
    let (iforces, irsq) = accelerator_compute_particle_forces(grid_, cutoff_distance * cutoff_distance, epsilon, sigma);
    force_iters = iforces;
    rsq_iters = irsq;
}

extern fn md_compute_total_kinetic_energy() -> real_t { 0.0 as real_t }
extern fn md_mpi_initialize() -> () { mpi_initialize(); }
extern fn md_mpi_finalize() -> () { mpi_finalize(); }
extern fn md_synchronize_ghost_layer() -> () { synchronize_ghost_layer(grid_, comm_offsets_); }
extern fn md_barrier() -> () { barrier(); }
extern fn md_get_world_size() -> i32 { get_world_size() }
extern fn md_get_world_rank() -> i32 { get_process_rank() }
extern fn md_get_number_of_particles() -> i32 { grid_.nparticles }
extern fn md_get_number_of_ghost_particles() -> i32 { grid_.nghost }

extern fn md_get_mass(particle_index: i32) -> real_t { get_real(particle_index, grid_.masses_cpu) }
extern fn md_get_position(particle_index: i32, x: &mut real_t, y: &mut real_t, z: &mut real_t) -> () {
    let pos = array_get_host(ParticleDataLayout(), grid_.positions, particle_index);
    *x = pos.x;
    *y = pos.y;
    *z = pos.z;
}

extern fn md_get_velocity(particle_index: i32, x: &mut real_t, y: &mut real_t, z: &mut real_t) -> () {
    let vel = array_get_host(ParticleDataLayout(), grid_.velocities, particle_index);
    *x = vel.x;
    *y = vel.y;
    *z = vel.z;
}

extern fn md_create_particle(mass: real_t, px: real_t, py: real_t, pz: real_t, vx: real_t, vy: real_t, vz: real_t) -> () {
    let position = Vector3D { x: px, y: py, z: pz };
    let velocity = Vector3D { x: vx, y: vy, z: vz };

    insert_particle(mass, position, velocity, &mut grid_, alloc_cpu);
}

extern fn md_report_iterations() -> () {
    let is_root = get_process_rank() == 0;
    let print_string_once = |s: &[u8]| { print_string_cond(is_root, s); };
    let reduce_and_print = |t: i64| {
        let mut res: i64;
        reduce_i64_sum(t, &mut res);
        print_i64_cond(is_root, res);
        print_string_once(" ");
    };

    barrier();
    print_string_once("ForceIters RsqIters IntegrationIters\n");

    reduce_and_print(force_iters);
    reduce_and_print(rsq_iters);
    reduce_and_print(integration_iters);

    print_string_once("\n");
}

extern fn md_report_particles() -> () {
    let is_root = get_process_rank() == 0;
    let print_string_once = |s: &[u8]| { print_string_cond(is_root, s); };
    let reduce_and_print = |t: i32| {
        let mut res: i32;
        reduce_i32_sum(t, &mut res);
        print_i32_cond(is_root, res);
        print_string_once(" ");
    };

    barrier();
    print_string_once("# Local # Ghost\n");

    reduce_and_print(grid_.nparticles);
    reduce_and_print(grid_.nghost);

    print_string_once("\n");
}

extern fn md_report_time(total_avg: f64, force_avg: f64, neigh_avg: f64, comm_avg: f64, lb_avg: f64, other_avg: f64) -> () {

    let is_root = get_process_rank() == 0;
    let print_string_once = |s: &[u8]| { print_string_cond(is_root, s); };
    let reduce_and_print = |t: f64| {
        let mut res: f64;
        reduce_time(t, &mut res);
        print_f64_cond(is_root, res);
        print_string_once(" ");
    };

    barrier();
    print_string_once("Total Force Neigh Comm Balance Other\n");

    /*
    print_i32(get_process_rank());  print_string("> ");
    print_f64(total_avg);           print_string(", ");
    print_f64(force_avg);           print_string(", ");
    print_f64(neigh_avg);           print_string(", ");
    print_f64(comm_avg);            print_string(", ");
    print_f64(lb_avg);              print_string(", ");
    print_f64(other_avg);           print_string("\n");
    barrier();
    */

    reduce_and_print(total_avg);
    reduce_and_print(force_avg);
    reduce_and_print(neigh_avg);
    reduce_and_print(comm_avg);
    reduce_and_print(lb_avg);
    reduce_and_print(other_avg);

    print_string_once("\n");
}
