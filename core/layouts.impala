struct ArrayData {
    buffer: Buffer,
    size_x: i32,
    size_y: i32
};

struct ArrayLayout {
    index: fn(ArrayData, i32, i32) -> i32
};

fn @get_shift_size(cluster_size: i32) -> i32 {
    if cluster_size > 0 {
        1 + get_shift_size(cluster_size >> 1)
    } else {
        0
    }
}

fn @null_array() -> ArrayData {
    let null_buf = Buffer {
        device: 0,
        data: 0 as &[i8],
        size: 0 as i64
    };

    ArrayData {
        buffer: null_buf,
        size_x: 0,
        size_y: 0
    }
}

fn allocate_array(size_x: i32, size_y: i32, elem_size: i32, allocate: fn(i32) -> Buffer) -> ArrayData {
    ArrayData {
        buffer: allocate(size_x * size_y * elem_size),
        size_x: size_x,
        size_y: size_y,
    }
}

fn @column_major_order_array() -> ArrayLayout {
    ArrayLayout {
        index: @|array, x, y| {
            x * array.size_y + y
        }
    }
}

fn @row_major_order_array() -> ArrayLayout {
    ArrayLayout {
        index: @|array, x, y| {
            y * array.size_x + x
        }
    }
}

fn @clustered_array(cluster_size: i32) -> ArrayLayout {
    let mask = cluster_size - 1;
    let shift = get_shift_size(cluster_size);

    ArrayLayout {
        index: @|array, x, y| {
            let i = x >> shift;
            let j = x & mask;
            cluster_size * (i * array.size_y + y) + j
        }
    }
}

fn reallocate_array(
    array: &mut ArrayData,
    size_x: i32,
    size_y: i32,
    elem_size: i32,
    @preserve: bool,
    allocate: fn(i32) -> Buffer) -> () {

    let new_buffer = allocate(size_x * size_y * elem_size);

    if preserve {
        copy(array.buffer, new_buffer);
    }

    release(array.buffer);

    (*array).buffer = new_buffer;
    (*array).size_x = size_x;
    (*array).size_y = size_y;
}

fn release_array(array: ArrayData) -> () { release(array.buffer); }
fn transfer_array(array_from: ArrayData, array_to: ArrayData) -> () { transfer(array_from.buffer, array_to.buffer); }

fn map_over_vector(vector: Vector3D, func: fn(i32, real_t) -> ()) -> () {
    func(0, vector.x);
    func(1, vector.y);
    func(2, vector.z);
}

fn swap_array_value(@layout: ArrayLayout, array: ArrayData, i: i32, j: i32) -> () {
    range(0, array.size_y, |y| {
        let index_i = layout.index(array, i, y);
        let index_j = layout.index(array, j, y);
        let tmp = bitcast[&[real_t]](array.buffer.data)(index_i);
        bitcast[&mut[real_t]](array.buffer.data)(index_i) = bitcast[&[real_t]](array.buffer.data)(index_j);
        bitcast[&mut[real_t]](array.buffer.data)(index_j) = tmp;
    });
}

fn set_array_value(@layout: ArrayLayout, array: ArrayData, index: i32, vector: Vector3D) -> () {
    map_over_vector(vector, @|v, value| {
        bitcast[&mut[real_t]](array.buffer.data)(layout.index(array, index, v)) = value;
    });
}

fn get_array_value(@layout: ArrayLayout, array: ArrayData, index: i32) -> Vector3D {
    Vector3D {
        x: bitcast[&mut[real_t]](array.buffer.data)(layout.index(array, index, 0)),
        y: bitcast[&mut[real_t]](array.buffer.data)(layout.index(array, index, 1)),
        z: bitcast[&mut[real_t]](array.buffer.data)(layout.index(array, index, 2))
    }
}

fn set_array_value_accelerator(@layout: ArrayLayout, array: ArrayData, index: i32, vector: Vector3D) -> () {
    map_over_vector(vector, @|v, value| {
        bitcast[&mut[1][real_t]](array.buffer.data)(layout.index(array, index, v)) = value;
    });
}

fn get_array_value_accelerator(@layout: ArrayLayout, array: ArrayData, index: i32) -> Vector3D {
    Vector3D {
        x: bitcast[&mut[1][real_t]](array.buffer.data)(layout.index(array, index, 0)),
        y: bitcast[&mut[1][real_t]](array.buffer.data)(layout.index(array, index, 1)),
        z: bitcast[&mut[1][real_t]](array.buffer.data)(layout.index(array, index, 2))
    }
}

fn copy_array_value(@layout: ArrayLayout, src: ArrayData, dest: ArrayData, i: i32, j: i32) -> () {
    bitcast[&mut[real_t]](dest.buffer.data)(layout.index(dest, j, 0)) = bitcast[&[real_t]](src.buffer.data)(layout.index(src, i, 0));
    bitcast[&mut[real_t]](dest.buffer.data)(layout.index(dest, j, 1)) = bitcast[&[real_t]](src.buffer.data)(layout.index(src, i, 1));
    bitcast[&mut[real_t]](dest.buffer.data)(layout.index(dest, j, 2)) = bitcast[&[real_t]](src.buffer.data)(layout.index(src, i, 2));
}
