struct ArrayData {
    buffer: Buffer,
    buffer_host: Buffer,
    size_x: i32,
    size_y: i32,
    host_mirror: bool
};

struct ArrayLayout {
    index: fn(ArrayData, i32, i32) -> i32
};

fn @get_shift_size(cluster_size: i32) -> i32 {
    if cluster_size > 0 {
        1 + get_shift_size(cluster_size >> 1)
    } else {
        0
    }
}

fn @null_array() -> ArrayData {
    let null_buf = Buffer {
        device: 0,
        data: 0 as &[i8],
        size: 0 as i64
    };

    ArrayData {
        buffer: null_buf,
        buffer_host: null_buf,
        size_x: 0,
        size_y: 0,
        host_mirror: false
    }
}

fn allocate_array(size_x: i32, size_y: i32, elem_size: i32, host_mirror: bool) -> ArrayData {
    let dev = device();
    let buffer = dev.alloc(size_x * size_y * elem_size);

    ArrayData {
        buffer: buffer,
        buffer_host: dev.alloc_mirror(buffer, size_x * size_y * elem_size),
        size_x: size_x,
        size_y: size_y,
        host_mirror: host_mirror
    }
}

fn @column_major_order_array() -> ArrayLayout {
    ArrayLayout {
        index: @|array, x, y| {
            x * array.size_y + y
        }
    }
}

fn @row_major_order_array() -> ArrayLayout {
    ArrayLayout {
        index: @|array, x, y| {
            y * array.size_x + x
        }
    }
}

fn @clustered_array(cluster_size: i32) -> ArrayLayout {
    let mask = cluster_size - 1;
    let shift = get_shift_size(cluster_size);

    ArrayLayout {
        index: @|array, x, y| {
            let i = x >> shift;
            let j = x & mask;
            cluster_size * (i * array.size_y + y) + j
        }
    }
}

fn reallocate_array(array: &mut ArrayData, size_x: i32, size_y: i32, elem_size: i32, @preserve: bool) -> () {
    let dev = device();
    let new_buffer = dev.alloc(size_x * size_y * elem_size);
    let new_buffer_host = dev.alloc_mirror(new_buffer, size_x * size_y * elem_size);

    if preserve {
        copy(array.buffer_host, new_buffer_host);
        dev.transfer(new_buffer_host, new_buffer);
    }

    release_array(*array);

    (*array).buffer = new_buffer;
    (*array).buffer_host = new_buffer_host;
    (*array).size_x = size_x;
    (*array).size_y = size_y;
}

fn release_array(array: ArrayData) -> () {
    if !device().cpu_target() {
        release(array.buffer);
    }

    release(array.buffer_host);
}

fn @transfer_array_to_device(array: ArrayData) -> () { device().transfer(array.buffer_host, array.buffer); }
fn @transfer_array_to_host(array: ArrayData) -> () { device().transfer(array.buffer, array.buffer_host); }

fn @array_swap(@layout: ArrayLayout, array: ArrayData, i: i32, j: i32) -> () {
    let data = device().get_mut_array_real(array.buffer);

    range(0, array.size_y, |y| {
        let index_i = layout.index(array, i, y);
        let index_j = layout.index(array, j, y);
        let tmp = data(index_i);
        data(index_i) = data(index_j);
        data(index_j) = tmp;
    });
}

fn @array_swap_host(@layout: ArrayLayout, array: ArrayData, i: i32, j: i32) -> () {
    let data = get_host_mut_array_real(array.buffer_host);

    range(0, array.size_y, |y| {
        let index_i = layout.index(array, i, y);
        let index_j = layout.index(array, j, y);
        let tmp = data(index_i);
        data(index_i) = data(index_j);
        data(index_j) = tmp;
    });
}

fn @array_set(@layout: ArrayLayout, array: ArrayData, index: i32, vector: Vector3D) -> () {
    let data = device().get_mut_array_real(array.buffer);

    data(layout.index(array, index, 0)) = vector.x;
    data(layout.index(array, index, 1)) = vector.y;
    data(layout.index(array, index, 2)) = vector.z;
}

fn @array_set_host(@layout: ArrayLayout, array: ArrayData, index: i32, vector: Vector3D) -> () {
    let data = get_host_mut_array_real(array.buffer_host);

    data(layout.index(array, index, 0)) = vector.x;
    data(layout.index(array, index, 1)) = vector.y;
    data(layout.index(array, index, 2)) = vector.z;
}

fn @array_get(@layout: ArrayLayout, array: ArrayData, index: i32) -> Vector3D {
    let data = device().get_mut_array_real(array.buffer);

    Vector3D {
        x: data(layout.index(array, index, 0)),
        y: data(layout.index(array, index, 1)),
        z: data(layout.index(array, index, 2))
    }
}

fn @array_get_host(@layout: ArrayLayout, array: ArrayData, index: i32) -> Vector3D {
    let data = get_host_mut_array_real(array.buffer_host);

    Vector3D {
        x: data(layout.index(array, index, 0)),
        y: data(layout.index(array, index, 1)),
        z: data(layout.index(array, index, 2))
    }
}

fn @array_copy(@layout: ArrayLayout, src: ArrayData, dest: ArrayData, i: i32, j: i32) -> () {
    let dev = device();
    let src_data = dev.get_mut_array_real(src.buffer);
    let dest_data = dev.get_mut_array_real(dest.buffer);

    dest_data(layout.index(dest, j, 0)) = src_data(layout.index(src, i, 0));
    dest_data(layout.index(dest, j, 1)) = src_data(layout.index(src, i, 1));
    dest_data(layout.index(dest, j, 2)) = src_data(layout.index(src, i, 2));
}

fn @array_copy_host(@layout: ArrayLayout, src: ArrayData, dest: ArrayData, i: i32, j: i32) -> () {
    let dev = device();
    let src_data = get_host_mut_array_real(src.buffer_host);
    let dest_data = get_host_mut_array_real(dest.buffer_host);

    dest_data(layout.index(dest, j, 0)) = src_data(layout.index(src, i, 0));
    dest_data(layout.index(dest, j, 1)) = src_data(layout.index(src, i, 1));
    dest_data(layout.index(dest, j, 2)) = src_data(layout.index(src, i, 2));
}
