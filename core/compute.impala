fn @(?n) pow(x: real_t, n: i32) -> real_t {
    if n == 1 {
        x
    } else if n % 2 == 0 {
        let y = pow(x, n / 2);
        y * y
    } else {
        x * pow(x, n - 1)
    }
}

fn @(?half_nb) compute_potential(
    grid: Grid, @half_nb: i32, rsq_cutoff: real_t,
    potential: fn(i32, i32, Vector3D, Vector3D, Vector3D, real_t) -> Vector3D) -> (i64, i64) {

    let dev = device();
    let mut total_iters = 0 as i64;
    let mut rsq_iters = 0 as i64;

    if half_nb != 0 {
        let vec_null = Vector3D { x: 0.0, y: 0.0, z: 0.0 };

        particles_vec(false, grid, |i, _, _, _| {
            array_set(ParticleDataLayout(), grid.forces, i, vec_null);
        });
    }

    particles_vec(false, grid, |i, neighborlists, nb_list_size, nb_list_offset| {
        let mut force = Vector3D {
            x: 0.0 as real_t,
            y: 0.0 as real_t,
            z: 0.0 as real_t
        };

        let pos_i = get_position(i, grid);

        for n in range(0, nb_list_size) {
            let j = neighborlists(get_neighborlist_index(i, n, grid));
            let pos_j = get_position(j, grid);
            let del = vector_sub(pos_i, pos_j);
            let rsq = vector_len2(del);

            if rsq < rsq_cutoff {
                let f = potential(i, j, pos_i, pos_j, del, rsq);

                if half_nb == 0 {
                    force = vector_add(force, f);
                } else {
                    array_add(ParticleDataLayout(), grid.forces, i, f);

                    if j < grid.nparticles {
                        let nf = Vector3D { x: -f.x, y: -f.y, z: -f.z };
                        array_add(ParticleDataLayout(), grid.forces, j, nf);
                    }
                }

                dev.add_iterator(&mut rsq_iters);
            }

            dev.add_iterator(&mut total_iters);
        }

        if half_nb == 0 {
            set_force(i, grid, force);
        }
    });

    (total_iters, rsq_iters)
}

fn integration(grid: Grid, dt: real_t) -> i64 {
    let dev = device();
    let mut iters = 0 as i64;

    particles_vec(false, grid, |i, _, _, _| {
        let masses = get_masses(grid);
        let inverse_mass = 1.0 as real_t / masses(i);
        let mut position = get_position(i, grid);
        let mut velocity = get_velocity(i, grid);
        let force = get_force(i, grid);

        velocity.x += dt * force.x * inverse_mass;
        velocity.y += dt * force.y * inverse_mass;
        velocity.z += dt * force.z * inverse_mass;

        position.x += dt * velocity.x;
        position.y += dt * velocity.y;
        position.z += dt * velocity.z;

        set_velocity(i, grid, velocity);
        set_position(i, grid, position);

        dev.add_iterator(&mut iters);
    });

    iters
}

fn initial_integration(grid: Grid, dt: real_t) -> i64 {
    let dev = device();
    let mut iters = 0 as i64;
    let dtforce = 0.5 * dt;

    particles_vec(false, grid, |i, _, _, _| {
        let mut position = get_position(i, grid);
        let mut velocity = get_velocity(i, grid);
        let force = get_force(i, grid);

        velocity.x += dtforce * force.x;
        velocity.y += dtforce * force.y;
        velocity.z += dtforce * force.z;

        position.x += dt * velocity.x;
        position.y += dt * velocity.y;
        position.z += dt * velocity.z;

        set_velocity(i, grid, velocity);
        set_position(i, grid, position);

        dev.add_iterator(&mut iters);
    });

    iters
}

fn final_integration(grid: Grid, dt: real_t) -> i64 {
    let dev = device();
    let mut iters = 0 as i64;
    let dtforce = 0.5 * dt;

    particles_vec(false, grid, |i, _, _, _| {
        let mut velocity = get_velocity(i, grid);
        let force = get_force(i, grid);

        velocity.x += dtforce * force.x;
        velocity.y += dtforce * force.y;
        velocity.z += dtforce * force.z;

        set_velocity(i, grid, velocity);

        dev.add_iterator(&mut iters);
    });

    iters
}

fn enforce_pbc(grid: Grid) -> () {
    particles_vec(false, grid, |i, _, _, _| {
        let pos = get_position(i, grid);
        set_position(i, grid, pbc_corrected_position_if(true, pos, grid));
    });
}
