fn integrate_position(grid: &Grid, dt: real_t, outer_loop: fn(i32, i32, fn(i32) -> ()) -> (), inner_loop: fn(i32, i32, fn(i32) -> ()) -> ()) -> () {
   for cell, cell_index in map_over_grid(grid, outer_loop, inner_loop) {
        for i in range(0, cell.size) {
            let mut position = get_vector_from_quantity(i, cell.positions); 
            let velocity = get_vector_from_quantity(i, cell.velocities); 
            /*print_string("i: ");
            print_i32(k);
            print_string("\n");
            print_string("Position: ");
            print_vector(position);
            print_string("\n");*/
            position.x += dt * velocity.x;
            position.y += dt * velocity.y;
            position.z += dt * velocity.z;
            set_quantity(i, cell.positions, position);
        }
        //restrict_to_boundary(cell, grid.aabb);
   }
}

fn restrict_to_boundary(cell: &Cell, aabb: AABB) -> () {
    for i in range(0, cell.size) {
        let mut position = get_vector_from_quantity(i, cell.positions); 
        if(position.x < aabb.min(0)) {
            position.x = aabb.min(0) + EPSILON;
        }
        else if(position.x > aabb.max(0)) {
            position.x = aabb.max(0) - EPSILON;
        }
        if(position.y < aabb.min(1)) {
            position.y = aabb.min(1) + EPSILON;
        }
        else if(position.y > aabb.max(1)) {
            position.y = aabb.max(1) - EPSILON;
        }
        if(position.z < aabb.min(2)) {
            position.z = aabb.min(2) + EPSILON;
        }
        else if(position.z > aabb.max(2)) {
            position.z = aabb.max(2) - EPSILON;
        } 
        set_quantity(i, cell.positions, position);
    }
}

fn integrate_velocity(grid: &Grid, dt: real_t, outer_loop: fn(i32, i32, fn(i32) -> ()) -> (), inner_loop: fn(i32, i32, fn(i32) -> ()) -> ()) -> () {
   for cell, cell_index in map_over_grid(grid, range, range) {
        let masses = get_array_of_reals((*cell).masses);
        for i in range(0, cell.size) {
        //for i in vectorize(get_vector_length(), get_alignment(), 0, cell.size) {
            let inverse_mass = 1.0 as real_t / masses(i);
            let force = get_vector_from_quantity(i, cell.positions); 
            let mut velocity = get_vector_from_quantity(i, cell.positions); 
            velocity.x += dt * force.x * inverse_mass;
            velocity.y += dt * force.y * inverse_mass;
            velocity.z += dt * force.z * inverse_mass;
            set_quantity(i, cell.velocities, velocity);
        }
   }
}
