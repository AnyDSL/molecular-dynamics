fn integrate_position(grid: &Grid, dt: real_t, iterate: fn(i32, i32, fn(i32) -> ()) -> ()) -> () {
   for cell, cell_index in map_over_grid(grid) {
        let positions = get_array_of_vectors((*cell).positions);
        let velocities = get_array_of_vectors((*cell).velocities);
        for i in iterate(0, cell.size) {
            positions(i).x += dt * velocities(i).x;
            positions(i).y += dt * velocities(i).y;
            positions(i).z += dt * velocities(i).z;
        }
        restrict_to_boundary(cell, grid.aabb);
   }
}

fn restrict_to_boundary(cell: &Cell, aabb: AABB) -> () {
    let positions = get_array_of_vectors((*cell).positions);
    for i in range(0, cell.size) {
        if(positions(i).x < aabb.min(0)) {
            positions(i).x = aabb.min(0) + EPSILON;
        }
        else if(positions(i).x > aabb.max(0)) {
            positions(i).x = aabb.max(0) - EPSILON;
        }
        if(positions(i).y < aabb.min(1)) {
            positions(i).y = aabb.min(1) + EPSILON;
        }
        else if(positions(i).y > aabb.max(1)) {
            positions(i).y = aabb.max(1) - EPSILON;
        }
        if(positions(i).z < aabb.min(2)) {
            positions(i).z = aabb.min(2) + EPSILON;
        }
        else if(positions(i).z > aabb.max(2)) {
            positions(i).z = aabb.max(2) - EPSILON;
        } 
    }
}

fn integrate_velocity(grid: &Grid, dt: real_t, iterate: fn(i32, i32, fn(i32) -> ()) -> ()) -> () {
   for cell, cell_index in map_over_grid(grid) {
        let masses = get_array_of_reals((*cell).masses);
        let velocities = get_array_of_vectors((*cell).velocities);
        let forces = get_array_of_vectors((*cell).forces);
        for i in iterate(0, cell.size) {
            let inverse_mass = 1.0 as real_t / masses(i);
            velocities(i).x += dt * forces(i).x * inverse_mass;
            velocities(i).y += dt * forces(i).y * inverse_mass;
            velocities(i).z += dt * forces(i).z * inverse_mass;
        }
   }
}
