fn integrate_position(grid: &Grid, dt: real_t, outer_loop: fn(i32, i32, fn(i32) -> ()) -> (), inner_loop: fn(i32, i32, fn(i32) -> ()) -> ()) -> () {
    let mut k = 0;
   for cell, cell_index in map_over_grid(grid, outer_loop, inner_loop) {
        let positions = get_array_of_vectors((*cell).positions);
        let velocities = get_array_of_vectors((*cell).velocities);
        for i in range(0, cell.size) {

            /*print_string("i: ");
            print_i32(k);
            print_string("\n");
            print_string("Position: ");
            print_vector(positions(i));
            print_string("\n");*/
            positions(i).x += dt * velocities(i).x;
            positions(i).y += dt * velocities(i).y;
            positions(i).z += dt * velocities(i).z;
            ++k;
        }
        //restrict_to_boundary(cell, grid.aabb);
   }
}

fn restrict_to_boundary(cell: &Cell, aabb: AABB) -> () {
    let positions = get_array_of_vectors((*cell).positions);
    for i in range(0, cell.size) {
        if(positions(i).x < aabb.min(0)) {
            positions(i).x = aabb.min(0) + EPSILON;
        }
        else if(positions(i).x > aabb.max(0)) {
            positions(i).x = aabb.max(0) - EPSILON;
        }
        if(positions(i).y < aabb.min(1)) {
            positions(i).y = aabb.min(1) + EPSILON;
        }
        else if(positions(i).y > aabb.max(1)) {
            positions(i).y = aabb.max(1) - EPSILON;
        }
        if(positions(i).z < aabb.min(2)) {
            positions(i).z = aabb.min(2) + EPSILON;
        }
        else if(positions(i).z > aabb.max(2)) {
            positions(i).z = aabb.max(2) - EPSILON;
        } 
    }
}

fn integrate_velocity(grid: &Grid, dt: real_t, outer_loop: fn(i32, i32, fn(i32) -> ()) -> (), inner_loop: fn(i32, i32, fn(i32) -> ()) -> ()) -> () {
   for cell, cell_index in map_over_grid(grid, range, range) {
        let masses = get_array_of_reals((*cell).masses);
        let velocities = get_array_of_vectors((*cell).velocities);
        let forces = get_array_of_vectors((*cell).forces);
        for i in range(0, cell.size) {
        //for i in vectorize(get_vector_length(), get_alignment(), 0, cell.size) {
            let inverse_mass = 1.0 as real_t / masses(i);
            velocities(i).x += dt * forces(i).x * inverse_mass;
            velocities(i).y += dt * forces(i).y * inverse_mass;
            velocities(i).z += dt * forces(i).z * inverse_mass;
        }
   }
}
