fn accelerator_integrate_position(accelerator_grid: &AcceleratorGrid, dt: real_t) -> () {
    let positions = get_array_of_vectors(accelerator_grid.positions_cpu);
    let velocities = get_array_of_vectors(accelerator_grid.velocities_cpu);
    for i in inner_loop(0, accelerator_grid.total_number_of_clusters) {
        let base = i * accelerator_grid.cluster_size;
        //for j in vectorize(get_vector_length(), get_alignment(), 0, accelerator_grid.cluster_size) {
        for j in unroll(0, accelerator_grid.cluster_size) {
            let k = base + j;
            positions(k).x += dt * velocities(k).x;
            positions(k).y += dt * velocities(k).y;
            positions(k).z += dt * velocities(k).z;
        }
    }
}

fn accelerator_integrate_velocity(accelerator_grid: &AcceleratorGrid, dt: real_t) -> () {
    let masses = get_array_of_reals(accelerator_grid.masses_cpu);
    let velocities = get_array_of_vectors(accelerator_grid.velocities_cpu);
    let forces = get_array_of_vectors(accelerator_grid.forces_cpu);
    for i in inner_loop(0, accelerator_grid.total_number_of_clusters) {
        let base = i * accelerator_grid.cluster_size;
        //for j in vectorize(get_vector_length(), get_alignment(), 0, accelerator_grid.cluster_size) {
        for j in unroll(0, accelerator_grid.cluster_size) {
            let k = base + j;
            let inverse_mass = 1.0 as real_t / masses(i);
            velocities(k).x += dt * forces(k).x * inverse_mass;
            velocities(k).y += dt * forces(k).y * inverse_mass;
            velocities(k).z += dt * forces(k).z * inverse_mass;
        }
    }
}
