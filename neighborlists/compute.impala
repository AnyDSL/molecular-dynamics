fn accelerator_compute_forces(accelerator_grid: AcceleratorGrid, squared_cutoff_distance: real_t, @potential: fn(real_t) -> real_t) -> () {
    for i, begin, j, cluster_size, number_of_neighbors, neighborlist_offset, neighborlists in loop_accelerator(accelerator_grid, accelerator_grid.total_number_of_clusters) {
        let force_x = get_forces_x(accelerator_grid);
        let force_y = get_forces_y(accelerator_grid); 
        let force_z = get_forces_z(accelerator_grid); 
        let pos_x = get_positions_x(accelerator_grid);
        let pos_y = get_positions_y(accelerator_grid);
        let pos_z = get_positions_z(accelerator_grid);

        let mut force = Vector3D { x: 0.0, y: 0.0, z: 0.0 };
        let pos = Vector3D { x: pos_x(begin + j), y: pos_y(begin + j), z: pos_z(begin + j) };

        let mask = select(get_mask_value(begin + i, accelerator_grid), -1i64, 0i64);
        for k in unroll(1, cluster_size) {
            let srcLane = (j + k) % cluster_size;
            let pos_neighbor = Vector3D { x: shuffle(pos.x, srcLane, k), y: shuffle(pos.y, srcLane, k), z: shuffle(pos.z, srcLane, k) };
            let diff = vector_sub(pos_neighbor, pos);
            let len2 = vector_len2(diff);
            if bitcast[i64](shuffle(bitcast[f64](mask), srcLane, k)) != 0i64 && len2 < squared_cutoff_distance {
                increase_flops(1);
                force = vector_add(force, vector_scale(potential(len2), diff));
            }
        }
        for n in range(0, number_of_neighbors) {
            let begin_neighbor = neighborlists(neighborlist_offset + n);
            for k in range(0, cluster_size) {
                let pos_neighbor = Vector3D {
                    x: pos_x(begin_neighbor + k),
                    y: pos_y(begin_neighbor + k),
                    z: pos_z(begin_neighbor + k)
                };
                let diff = vector_sub(pos_neighbor, pos);
                let len2 = vector_len2(diff);
                if get_mask_value(begin_neighbor + k, accelerator_grid) && len2 < squared_cutoff_distance {
                    increase_flops(1);
                    force = vector_add(force, vector_scale(potential(len2), diff));
                }
            }
        }

        force_x(begin + j) = force.x; 
        force_y(begin + j) = force.y; 
        force_z(begin + j) = force.z; 
    }
}

fn accelerator_restrict_to_boundary(accelerator_grid: AcceleratorGrid, aabb: AABB) -> () {
    for i, begin, j, cluster_size, number_of_neighbors, neighborlist_offset, neighborlists in loop_accelerator(accelerator_grid, accelerator_grid.total_number_of_clusters) {
        let mut position = get_position(begin + j, accelerator_grid); 
        if(position.x < aabb.min(0)) {
            position.x = aabb.min(0) + EPSILON;
        }
        else if(position.x > aabb.max(0)) {
            position.x = aabb.max(0) - EPSILON;
        }
        if(position.y < aabb.min(1)) {
            position.y = aabb.min(1) + EPSILON;
        }
        else if(position.y > aabb.max(1)) {
            position.y = aabb.max(1) - EPSILON;
        }
        if(position.z < aabb.min(2)) {
            position.z = aabb.min(2) + EPSILON;
        }
        else if(position.z > aabb.max(2)) {
            position.z = aabb.max(2) - EPSILON;
        } 
        set_position(begin + j, accelerator_grid, position);
    }
}

fn accelerator_integration(accelerator_grid: AcceleratorGrid, dt: real_t) -> () {
    for i, begin, j, cluster_size, number_of_neighbors, neighborlist_offset, neighborlists in loop_accelerator(accelerator_grid, accelerator_grid.total_number_of_clusters) {
        let masses = get_masses(accelerator_grid);
        let inverse_mass = 1.0 as real_t / masses(i);
        let mut position = get_position(begin + j, accelerator_grid);
        let mut velocity = get_velocity(begin + j, accelerator_grid);
        let force = get_force(begin + j, accelerator_grid);
        velocity.x += dt * force.x * inverse_mass;
        velocity.y += dt * force.y * inverse_mass;
        velocity.z += dt * force.z * inverse_mass;
        position.x += dt * velocity.x;
        position.y += dt * velocity.y;
        position.z += dt * velocity.z;
        set_velocity(begin + j, accelerator_grid, velocity);
        set_position(begin + j, accelerator_grid, position);
    }
}
