fn accelerator_compute_forces(accelerator_grid: AcceleratorGrid, squared_cutoff_distance: real_t, @potential: fn(real_t) -> real_t) -> () {
    for i in range(0, accelerator_grid.total_number_of_clusters) { 
        let cluster_size = get_cluster_size();
        let begin = i * cluster_size;
        let alignment = 32;
        let number_of_neighbors = get_number_of_neighbors(i, accelerator_grid);
        let neighborlist_offset = get_neighborlist_offset(i, accelerator_grid);
        let neighborlists = get_neighborlists(accelerator_grid);

        for j in vectorize(cluster_size, alignment, 0, cluster_size) {
            let force_x = bitcast[&mut[real_t]](rv_align(accelerator_grid.forces_cpu.x.data, alignment));
            let force_y = bitcast[&mut[real_t]](rv_align(accelerator_grid.forces_cpu.y.data, alignment));
            let force_z = bitcast[&mut[real_t]](rv_align(accelerator_grid.forces_cpu.z.data, alignment));
            let pos_x = bitcast[&mut[real_t]](rv_align(accelerator_grid.positions_cpu.x.data, alignment));
            let pos_y = bitcast[&mut[real_t]](rv_align(accelerator_grid.positions_cpu.y.data, alignment));
            let pos_z = bitcast[&mut[real_t]](rv_align(accelerator_grid.positions_cpu.z.data, alignment));

            let mut force = Vector { x: 0.0, y: 0.0, z: 0.0 };
            let pos = Vector { x: pos_x(begin + j), y: pos_y(begin + j), z: pos_z(begin + j) };
            
            let mask = select(get_mask_value(begin + i, accelerator_grid), -1i64, 0i64);
            for k in unroll(1, cluster_size) {
                let pos_neighbor = Vector { x: rv_shuffle(pos.x, k), y: rv_shuffle(pos.y, k), z: rv_shuffle(pos.z, k) };
                let diff = vector_sub(pos_neighbor, pos);
                let len2 = vector_len2(diff);
                if bitcast[i64](rv_shuffle(bitcast[f64](mask), k)) != 0i64 && len2 < squared_cutoff_distance {
                    force = vector_add(force, vector_scale(potential(len2), diff));
                }
            }
            for n in range(0, number_of_neighbors) {
                let begin_neighbor = neighborlists(neighborlist_offset + n);
                for k in range(0, cluster_size) {
                    let pos_neighbor = Vector {
                        x: pos_x(begin_neighbor + k),
                        y: pos_y(begin_neighbor + k),
                        z: pos_z(begin_neighbor + k)
                    };
                    let diff = vector_sub(pos_neighbor, pos);
                    let len2 = vector_len2(diff);
                    if get_mask_value(begin_neighbor + k, accelerator_grid) && len2 < squared_cutoff_distance {
                        force = vector_add(force, vector_scale(potential(len2), diff));
                    }
                }
            }

            force_x(begin + j) = force.x; 
            force_y(begin + j) = force.y; 
            force_z(begin + j) = force.z; 
        }
    }
}
/*
fn accelerator_compute_forces(accelerator_grid: AcceleratorGrid, squared_cutoff_distance: real_t, potential: fn(real_t) -> real_t) -> () {
    for i, cluster_index, cluster_size in loop_accelerator(accelerator_grid.total_number_of_clusters) {
        reset_force(i, accelerator_grid);
        let begin = cluster_index * cluster_size;
        for jj in unroll(0, cluster_size) {
            let j = begin + jj; 
            // Calculate interactions within cluster
            if(i != j && get_mask_value(j, accelerator_grid) && get_mask_value(i, accelerator_grid)) {
                accelerator_compute_pairwise_forces(accelerator_grid, i, j, squared_cutoff_distance, potential);
            }
        }
        let number_of_neighbors = get_number_of_neighbors(cluster_index, accelerator_grid);
        let neighborlist_offset = get_neighborlist_offset(cluster_index, accelerator_grid);
        let neighborlists = get_neighborlists(accelerator_grid);
        for k in range(0, number_of_neighbors) {
            let begin_neighbor = neighborlists(neighborlist_offset + k);
            for jj in unroll(0, cluster_size) {
                let j = begin_neighbor + jj;
                if(get_mask_value(j, accelerator_grid) && get_mask_value(i, accelerator_grid)) {
                    accelerator_compute_pairwise_forces(accelerator_grid, i, j, squared_cutoff_distance, potential);
                }
            }
        }
    }
}


fn @accelerator_compute_pairwise_forces(accelerator_grid: AcceleratorGrid, i: i32, j: i32, squared_cutoff_distance: real_t, potential: fn(real_t) -> real_t) -> () { 
    let position = get_position(i, accelerator_grid);
    let neighbor_position = get_position(j, accelerator_grid);
    // 3 FLOPS
    let dx = neighbor_position.x - position.x;
    let dy = neighbor_position.y - position.y;
    let dz = neighbor_position.z - position.z;
    // 5 FLOPS
    let squared_distance = dx * dx + dy * dy + dz * dz;
    increase_flops(8);
    if(squared_distance < squared_cutoff_distance) {
        // 8 FLOPS for Lennard-Jones
        let f = potential(squared_distance);
        // 3 FLOPS
        let dF_x = f * dx;
        let dF_y = f * dy;
        let dF_z = f * dz;
        // 3 FLOPS
        add_to_force(i, accelerator_grid, dF_x, dF_y, dF_z);
        increase_flops(14);
    }
}

fn accelerator_set_forces_to_zero(accelerator_grid: AcceleratorGrid) -> () {
    for i, cluster_index, cluster_size in loop_accelerator(accelerator_grid.total_number_of_clusters) {
        reset_force(i, accelerator_grid);
    }
}
*/

fn accelerator_restrict_to_boundary(accelerator_grid: AcceleratorGrid, aabb: AABB) -> () {
    for i, cluster_index, cluster_size in loop_accelerator(accelerator_grid.total_number_of_clusters) {
        let mut position = get_position(i, accelerator_grid); 
        if(position.x < aabb.min(0)) {
            position.x = aabb.min(0) + EPSILON;
        }
        else if(position.x > aabb.max(0)) {
            position.x = aabb.max(0) - EPSILON;
        }
        if(position.y < aabb.min(1)) {
            position.y = aabb.min(1) + EPSILON;
        }
        else if(position.y > aabb.max(1)) {
            position.y = aabb.max(1) - EPSILON;
        }
        if(position.z < aabb.min(2)) {
            position.z = aabb.min(2) + EPSILON;
        }
        else if(position.z > aabb.max(2)) {
            position.z = aabb.max(2) - EPSILON;
        } 
        set_position(i, accelerator_grid, position);
    }
}


fn accelerator_integration(accelerator_grid: AcceleratorGrid, dt: real_t) -> () {
    let masses = get_masses(accelerator_grid);
    for i, cluster_index, cluster_size in loop_accelerator(accelerator_grid.total_number_of_clusters) {
        let inverse_mass = 1.0 as real_t / masses(i);
        let mut position = get_position(i, accelerator_grid);
        let mut velocity = get_velocity(i, accelerator_grid);
        let force = get_force(i, accelerator_grid);
        velocity.x += dt * force.x * inverse_mass;
        velocity.y += dt * force.y * inverse_mass;
        velocity.z += dt * force.z * inverse_mass;
        position.x += dt * velocity.x;
        position.y += dt * velocity.y;
        position.z += dt * velocity.z;
        set_velocity(i, accelerator_grid, velocity);
        set_position(i, accelerator_grid, position);
    }
}
