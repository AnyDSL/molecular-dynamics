/* Three-dimension arrays of struct (reals) layout */

type Array3D = Buffer;

fn @null_3d_array() -> Buffer {
    let null_buf = Buffer {
        device: 0,
        data: 0 as &[i8],
        size: 0 as i64
    };

    null_buf
}

fn allocate_3d_arrays(N: i32, allocate: fn(i32) -> Buffer) -> Buffer {
    allocate(N * 3 * sizeof[real_t]())
}

fn deallocate_3d_arrays(arrays: Buffer) -> () {
    release(arrays);
}


fn @copy_offset_3d_arrays(src: Buffer, offset_src: i32, dest: Buffer, offset_dest: i32, N: i32) -> () {
    let elem_size = 3 * sizeof[real_t]();
    copy_offset(src, offset_src * elem_size, dest, offset_dest * elem_size, N * elem_size);
}

fn set_3d_arrays(i: i32, arrays: Buffer, vector: Vector3D) -> () {
    let idx = i * 3;

    bitcast[&mut[real_t]](arrays.data)(idx) = vector.x;
    bitcast[&mut[real_t]](arrays.data)(idx + 1) = vector.y;
    bitcast[&mut[real_t]](arrays.data)(idx + 2) = vector.z;
}

fn get_vector_from_3d_arrays(i: i32, arrays: Buffer) -> Vector3D {
    let idx = i * 3;

    Vector3D {
        x: bitcast[&mut[real_t]](arrays.data)(idx),
        y: bitcast[&mut[real_t]](arrays.data)(idx + 1),
        z: bitcast[&mut[real_t]](arrays.data)(idx + 2)
    }
}

fn @set_3d_arrays_accelerator(i: i32, arrays: Buffer, vector: Vector3D) -> () {
    let idx = i * 3;

    bitcast[&mut[1][real_t]](arrays.data)(idx) = vector.x;
    bitcast[&mut[1][real_t]](arrays.data)(idx + 1) = vector.y;
    bitcast[&mut[1][real_t]](arrays.data)(idx + 2) = vector.z;
}

fn @get_vector_from_3d_arrays_accelerator(i: i32, arrays: Buffer) -> Vector3D {
    let idx = i * 3;

    Vector3D {
        x: bitcast[&mut[1][real_t]](arrays.data)(idx),
        y: bitcast[&mut[1][real_t]](arrays.data)(idx + 1),
        z: bitcast[&mut[1][real_t]](arrays.data)(idx + 2)
    }
}

fn get_x_component(i: i32, arrays: Buffer) -> real_t {
    bitcast[&mut[real_t]](arrays.data)(i * 3)
}

fn get_y_component(i: i32, arrays: Buffer) -> real_t {
    bitcast[&mut[real_t]](arrays.data)(i * 3 + 1)
}

fn get_z_component(i: i32, arrays: Buffer) -> real_t {
    bitcast[&mut[real_t]](arrays.data)(i * 3 + 2)
}

fn copy_3d_arrays(i: i32, j: i32, src: Buffer, dest: Buffer) -> () {
    let src_idx = i * 3;
    let dest_idx = j * 3;

    bitcast[&mut[real_t]](dest.data)(dest_idx) = bitcast[&[real_t]](src.data)(src_idx);
    bitcast[&mut[real_t]](dest.data)(dest_idx + 1) = bitcast[&[real_t]](src.data)(src_idx + 1);
    bitcast[&mut[real_t]](dest.data)(dest_idx + 2) = bitcast[&[real_t]](src.data)(src_idx + 2);
}

fn swap_3d_arrays(i: i32, j: i32, arrays: Buffer) -> () {
    let first_idx = i * 3;
    let second_idx = j * 3;

    let tmp_x = bitcast[&[real_t]](arrays.data)(first_idx);
    let tmp_y = bitcast[&[real_t]](arrays.data)(first_idx + 1);
    let tmp_z = bitcast[&[real_t]](arrays.data)(first_idx + 2);

    bitcast[&mut[real_t]](arrays.data)(first_idx) = bitcast[&[real_t]](arrays.data)(second_idx);
    bitcast[&mut[real_t]](arrays.data)(first_idx + 1) = bitcast[&[real_t]](arrays.data)(second_idx + 1);
    bitcast[&mut[real_t]](arrays.data)(first_idx + 2) = bitcast[&[real_t]](arrays.data)(second_idx + 2);

    bitcast[&mut[real_t]](arrays.data)(second_idx) = tmp_x;
    bitcast[&mut[real_t]](arrays.data)(second_idx + 1) = tmp_y;
    bitcast[&mut[real_t]](arrays.data)(second_idx + 2) = tmp_z;
}

fn @_transfer_3d_arrays_between_devices(src: Buffer, dest: Buffer, N: i32) -> () {
    copy(src, dest);
}

fn copy_3d_arrays_to_buffer(
    source: Buffer,
    offset_source: i32,
    dest: Buffer,
    offset_dest: i32,
    size: i32) -> i32 {

    let elem_size = 3 * sizeof[real_t]();

    copy_offset(
        source, offset_source * elem_size,
        dest, offset_dest * sizeof[real_t](), size * elem_size);

    size * 3
}

fn copy_buffer_to_3d_arrays(
    source: Buffer,
    offset_source: i32,
    dest: Buffer,
    offset_dest: i32,
    size: i32) -> i32 {

    let elem_size = 3 * sizeof[real_t]();

    copy_offset(
        source, offset_source * sizeof[real_t](),
        dest, offset_dest * elem_size, size * elem_size);

    size * 3
}

