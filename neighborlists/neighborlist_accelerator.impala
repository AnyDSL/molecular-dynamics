fn append_neighbor_accelerator(
    cluster: i32,
    cell_index: i32,
    cell_offset: i32,
    neighbor_cluster: i32,
    neighbor_cell: i32,
    neighbor_offset: i32,
    offset_neighbors: i32,
    accelerator_grid: &mut AcceleratorGrid,
    allocate: fn(i32) -> Buffer) -> () {

    let neighbors_per_cluster = get_array_of_i32(accelerator_grid.neighbors_per_cluster_cpu);
    let neighborlist_offsets = get_array_of_i32(accelerator_grid.neighborlist_offsets_cpu);
    let neighborlists = get_array_of_i32(accelerator_grid.neighborlists_cpu);
    let nb_list_size = neighbors_per_cluster(cell_offset + cluster);

    if(nb_list_size == accelerator_grid.neighborlist_capacity) {
        let adding = nb_list_size / 10 + 1;
        let extension = select(adding < 4, 4, adding);
        let capacity = accelerator_grid.neighborlist_capacity + extension;

        reallocate_accelerator_neighborlist_capacity(accelerator_grid, capacity);
    }

    let buf_idx = offset_neighbors + nb_list_size;
    neighborlists(buf_idx) = neighbor_offset + neighbor_cluster * accelerator_grid.cluster_size;
    neighbors_per_cluster(cell_offset + cluster) += 1;
}

// Redundant computation to get rid of atomics (only works when cluster_size = 1)
fn assemble_particles_full_neighbor_list_accelerator(
    cluster: i32,
    cell_index: i32,
    cell_offset: i32,
    cell_spatial_index: [i32 * 3],
    offset_neighbors: i32,
    grid: &Grid,
    accelerator_grid: &mut AcceleratorGrid,
    cutoff_distance: real_t,
    allocate: fn(i32) -> Buffer) -> () {

    let mut begin : [i32 * 3];
    let mut end : [i32 * 3];
    let nxyz = [grid.nx, grid.ny, grid.nz];

    for i in unroll(0, 3) {
        begin(i) = select(cell_spatial_index(i) > 0, cell_spatial_index(i) - 1, 0);
        end(i) = select(cell_spatial_index(i) < nxyz(i) - 1, cell_spatial_index(i) + 2, nxyz(i));
    }

    let cell_sizes = get_array_of_i32(accelerator_grid.cell_sizes);
    let squared_cutoff_distance = cutoff_distance * cutoff_distance;
    let cluster_index = cell_offset + cluster;
    let mx = get_x_component(cluster_index, accelerator_grid.positions_cpu);
    let my = get_y_component(cluster_index, accelerator_grid.positions_cpu);
    let mz = get_z_component(cluster_index, accelerator_grid.positions_cpu);

    for i in range(begin(0), end(0)) {
        for j in range(begin(1), end(1)) {
            for k in range(begin(2), end(2)) {
                let neighboring_cell_index = flatten_index([i, j, k], grid);
                let same_cell = cell_index == neighboring_cell_index;
                let neighbor_cell_offset = get_accelerator_cell_offset(neighboring_cell_index, accelerator_grid);
                let neighbor_cell_size = cell_sizes(neighboring_cell_index);

                if(same_cell == false) {
                    for z in range(0, neighbor_cell_size) {
                        let neighbor_cluster_index = neighbor_cell_offset + z;
                        let dx = mx - get_x_component(neighbor_cluster_index, accelerator_grid.positions_cpu);
                        let dy = my - get_y_component(neighbor_cluster_index, accelerator_grid.positions_cpu);
                        let dz = mz - get_z_component(neighbor_cluster_index, accelerator_grid.positions_cpu);

                        if(dx * dx + dy * dy + dz * dz <= squared_cutoff_distance) {
                            append_neighbor_accelerator(
                                cluster, cell_index, cell_offset, z, neighboring_cell_index, neighbor_cell_offset,
                                offset_neighbors, accelerator_grid, allocate);
                        }
                    }
                } else {
                    for z in range(0, neighbor_cell_size) {
                        if(cluster != z) {
                            let neighbor_cluster_index = neighbor_cell_offset + z;
                            let dx = mx - get_x_component(neighbor_cluster_index, accelerator_grid.positions_cpu);
                            let dy = my - get_y_component(neighbor_cluster_index, accelerator_grid.positions_cpu);
                            let dz = mz - get_z_component(neighbor_cluster_index, accelerator_grid.positions_cpu);

                            if(dx * dx + dy * dy + dz * dz <= squared_cutoff_distance) {
                                append_neighbor_accelerator(
                                    cluster, cell_index, cell_offset, z, neighboring_cell_index, neighbor_cell_offset,
                                    offset_neighbors, accelerator_grid, allocate);
                            }
                        }
                    }
                }
            }
        }
    }
}

fn accelerator_grid_assemble_neighbor_lists(
    grid: Grid,
    accelerator_grid: &mut AcceleratorGrid,
    cutoff_distance: real_t,
    allocate: fn(i32) -> Buffer,
    assemble: fn(i32, i32, i32, [i32 * 3], i32, &Grid, &mut AcceleratorGrid, real_t, fn(i32) -> Buffer)-> ()) -> () {

    let cell_sizes = get_array_of_i32(accelerator_grid.cell_sizes);
    let neighbors_per_cluster = get_array_of_i32(accelerator_grid.neighbors_per_cluster_cpu);
    let neighborlist_offsets = get_array_of_i32(accelerator_grid.neighborlist_offsets_cpu);
    let mut offset_nbs = 0;

    range(0, accelerator_grid.ncells, |cell_index| {
        let cell_offset = get_accelerator_cell_offset(cell_index, accelerator_grid);
        let cell_size = cell_sizes(cell_index);
        let cell_spatial_index = unflatten_index(cell_index, grid);

        range(0, cell_size, |cluster| {
            neighbors_per_cluster(cell_offset + cluster) = 0;
            assemble(cluster, cell_index, cell_offset, cell_spatial_index, offset_nbs, grid, accelerator_grid, cutoff_distance, allocate);
            neighborlist_offsets(cell_offset + cluster) = offset_nbs;
            offset_nbs += neighbors_per_cluster(cell_offset + cluster);
        });
    });
}
