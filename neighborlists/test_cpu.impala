static mut grid_ : Grid;

extern 
fn cpu_initialize_grid(masses: &[real_t], positions: &[Vector], velocities: &[Vector], 
                       nparticles: i32, min: &[real_t], max: &[real_t], spacing: real_t, cell_capacity: i32) -> () {
    let aabb = AABB {
        min: [min(0), min(1), min(2)],
        max: [max(0), max(1), max(2)],
    };
    grid_ = allocate_grid(aabb, spacing, cell_capacity, 4, alloc_cpu);
    initialize_grid(masses, positions, velocities, nparticles, &mut grid_, alloc_cpu);
}

extern
fn cpu_deallocate_grid() -> () {
    deallocate_grid(grid_);
}

extern 
fn cpu_integrate_position(dt: real_t) -> () {
    integrate_position(&grid_, dt, range);
}


extern 
fn cpu_integrate_velocity(dt: real_t) -> () {
    integrate_velocity(&grid_, dt, range);
}

extern
fn cpu_write_grid_data_to_arrays(masses: &mut[real_t], positions: &mut [Vector], velocities: &mut [Vector], size: i32) -> i32 {
    write_grid_data_to_arrays(masses, positions, velocities, size, &grid_)
}

extern
fn cpu_redistribute_particles() -> () {
    redistribute_particles(grid_, alloc_cpu);
}

extern 
fn cpu_initialize_clusters(neighbor_list_capacity: i32) -> () {
   grid_initialize_clusters(grid_, neighbor_list_capacity, alloc_cpu);  
}

extern
fn cpu_assemble_neighbor_lists(cutoff_distance: real_t) -> () {
    grid_assemble_neighbor_lists(&grid_, cutoff_distance, alloc_cpu)
}

extern
fn cpu_set_forces_to_zero() -> () {
    grid_set_forces_to_zero(grid_);
}

extern
fn cpu_compute_forces(cutoff_distance: real_t, epsilon: real_t, sigma: real_t) -> () {
    let potential = create_potential(sigma, epsilon);
    grid_compute_forces(grid_, cutoff_distance*cutoff_distance, potential, outer_loop, inner_loop);
}

extern
fn cpu_print_grid() -> () {
    print_grid(grid_);
}
