struct AABB {
    min: [real_t * 3],
    max: [real_t * 3]
}

fn print_AABB(aabb: AABB) -> () {
    print_string("x: (");
    print_f64(aabb.min(0) as f64);
    print_string(", ");
    print_f64(aabb.max(0) as f64);
    print_string(")\n");
    print_string("y: (");
    print_f64(aabb.min(1) as f64);
    print_string(", ");
    print_f64(aabb.max(1) as f64);
    print_string(")\n");
    print_string("z: (");
    print_f64(aabb.min(2) as f64);
    print_string(", ");
    print_f64(aabb.max(2) as f64);
    print_string(")\n");
}

struct Cluster {
    neighbor_list: NeighborList,
    aabb: AABB
}

fn print_cluster(cluster: &Cluster) -> () {
    print_string("AABB:\n");
    print_AABB(cluster.aabb);
    print_string("Neighbor list:\n");
    print_neighbor_list(cluster.neighbor_list);
}

struct Cell {
    index: i32,
    masses: Buffer,
    positions: Buffer,
    velocities: Buffer,
    forces: Buffer,
    size: i32,
    padding: i32,
    capacity: i32,
    nclusters: i32,
    clusters: Buffer,
    cluster_size: i32
}

fn allocate_cell(index: i32, size: i32, capacity: i32, @cluster_size: i32, allocate: fn(i32) -> Buffer) -> Cell {
    let N = if(size + 4 > capacity) {size + 4} else {capacity};
    Cell {
        index: index,
        masses: allocate(N * sizeof[real_t]()),
        positions: allocate(N * sizeof[Vector]()),
        velocities: allocate(N * sizeof[Vector]()),
        forces: allocate(N * sizeof[Vector]()),
        capacity: N,
        padding: 0,
        size: size,
        nclusters: 0,
        clusters: Buffer {device: 0, data: 0 as &[i8]},
        cluster_size: cluster_size 
    }
}

fn print_cell(cell: &Cell, index: [i32 * 2]) -> () {
    print_string("Memory address: ");
    print_i64(cell as i64);
    print_string("\nIndex: ");
    print_i32(index(0));
    print_string(" ");
    print_i32(index(1));
    print_string("\nSize: ");
    print_i32(cell.size);
    print_string("\nCapacity: ");
    print_i32(cell.capacity);
    print_string("\nPadding: ");
    print_i32(cell.padding); 
    print_string("\nNumber of clusters: ");
    print_i32(cell.nclusters);
    print_string("\nCluster size: ");
    print_i32(cell.cluster_size); 
    print_string("\n");
    print_string("Positions:\n");
    for i in range(0, cell.size) {
        print_vector(get_vector(i, cell.positions));
        print_string("\n");
    }
    print_string("Forces:\n");
    for i in range(0, cell.size) {
        print_vector(get_vector(i, cell.forces));
        print_string("\n");
    }
    print_string("Velocities:\n");
    for i in range(0, cell.size) {
        print_vector(get_vector(i, cell.velocities));
        print_string("\n");
    }


    print_string("Clusters:\n");
    let clusters = get_array_of_clusters(cell.clusters);
    for i in range(0, cell.nclusters) {
        print_cluster(clusters(i));
        print_string("\n");
    }
    print_string("\n");
}

fn deallocate_cell(cell: &mut Cell) -> () {
    release((*cell).masses);
    release((*cell).positions);
    release((*cell).velocities);
    release((*cell).forces);
    cell.size = 0;
    cell.capacity = 0;
    cell_deallocate_clusters(cell);
}

fn copy_cell(src: &Cell, dest: &mut Cell) -> () {
    for i in range(0, src.size) {
       set_real(i, dest.masses, get_real(i, src.masses)); 
       set_vector(i, dest.positions, get_vector(i, src.positions));
       set_vector(i, dest.velocities, get_vector(i, src.velocities));
    }
}

fn @swap_particles(i: i32, j: i32, cell: &Cell) -> () {
    swap_real(i, j, (*cell).masses);
    swap_vector(i, j, (*cell).positions);
    swap_vector(i, j, (*cell).velocities);
}

fn @copy_particle(i: i32, j: i32, src: &Cell, dest: &Cell) -> () {
    set_real(j, dest.masses, get_real(i, src.masses));
    set_vector(j, dest.positions, get_vector(i, src.positions));
    set_vector(j, dest.velocities, get_vector(i, src.velocities));
}

fn @remove_particle(i: i32, cell: &mut Cell) -> () {
    swap_particles(i, (*cell).size - 1, cell);
    cell.size -= 1;
}

fn move_particle(i: i32, src: &mut Cell, dest: &mut Cell, allocate: fn(i32) -> Buffer) -> () {
    /*if(src as u64 == dest as u64) {
        print_string("Source and destinatin are identical!\n");
    }*/
    if(dest.size + 1 > dest.capacity) {
        reallocate_cell(dest.size + 1, dest, allocate);
    }
    else {
        dest.size += 1;
    }
    let src_last = src.size - 1;
    let dest_last = dest.size - 1;
    copy_particle(i, dest_last, src, dest); 
    if(i < src_last) {
        swap_particles(i, src_last, src);
    }
    src.size -= 1;
}

fn reallocate_cell(new_size: i32, dest: &mut Cell, allocate: fn(i32) -> Buffer) -> () {
    let new_capacity = dest.capacity + (dest.nclusters / 10 + 1) * dest.cluster_size;  
    let mut new_cell = allocate_cell(dest.index, new_size, new_capacity, dest.cluster_size, allocate);
    copy_cell(dest, &mut new_cell);
    deallocate_cell(dest);
    *dest = new_cell;
}

fn append_particle(mass: real_t, position: Vector, velocity: Vector, dest: &mut Cell, allocate: fn(i32) -> Buffer) -> () {
    /*print_string("Mass: ");
    print_f64(mass);
    print_string(" Position: ");
    print_vector(position);
    print_string(" Velocity: ");
    print_vector(velocity);
    print_string("\n");*/
    let new_size = dest.size + 1;
    if(dest.size == dest.capacity) {
        reallocate_cell(new_size, dest, allocate);
    }
    else {
        dest.size = new_size;
    }

    /*print_string("New size: ");
    print_i32(new_size);
    print_string("\n");*/
    set_real(new_size-1, dest.masses, mass);
    set_vector(new_size-1, dest.positions, position);
    set_vector(new_size-1, dest.velocities, velocity);
}

