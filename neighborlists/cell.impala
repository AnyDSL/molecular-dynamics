struct AABB {
    min: [real_t * 3],
    max: [real_t * 3]
}

fn print_AABB(aabb: AABB) -> () {
    print_string("x: (");
    print_f64(aabb.min(0) as f64);
    print_string(", ");
    print_f64(aabb.max(0) as f64);
    print_string(")\n");
    print_string("y: (");
    print_f64(aabb.min(1) as f64);
    print_string(", ");
    print_f64(aabb.max(1) as f64);
    print_string(")\n");
    print_string("z: (");
    print_f64(aabb.min(2) as f64);
    print_string(", ");
    print_f64(aabb.max(2) as f64);
    print_string(")\n");
}

struct Cluster {
    neighbor_list: NeighborList,
    aabb: AABB
}

fn print_cluster(cluster: &Cluster) -> () {
    print_string("AABB:\n");
    print_AABB(cluster.aabb);
    print_string("Neighbor list:\n");
    print_neighbor_list(cluster.neighbor_list);
}

struct Cell {
    index: i32,
    masses: Buffer,
    positions: StructOfArrays3D,
    velocities: StructOfArrays3D,
    forces: StructOfArrays3D,
    size: i32,
    padding: i32,
    capacity: i32,
    nclusters: i32,
    clusters: Buffer,
    cluster_size: i32,
    neighbor_cells: Buffer,
    neighbor_indices: Buffer,
    neighbor_total_capacity: i32
}

fn allocate_cell(index: i32, size: i32, capacity: i32, @cluster_size: i32, allocate: fn(i32) -> Buffer) -> Cell {
    let N = if(size + 4 > capacity) {size + 4} else {capacity};

    add_cell_allocation(N * 10 * sizeof[real_t]());

    Cell {
        index: index,
        masses: allocate(N * sizeof[real_t]()),
        positions: allocate_struct_of_arrays(N),
        velocities: allocate_struct_of_arrays(N),
        forces: allocate_struct_of_arrays(N),
        capacity: N,
        padding: 0,
        size: size,
        nclusters: 0,
        clusters: Buffer {device: 0, data: 0 as &[i8], size: 0 as i64},
        cluster_size: cluster_size,
        neighbor_cells: Buffer {device: 0, data: 0 as &[i8], size: 0 as i64},
        neighbor_indices: Buffer {device: 0, data: 0 as &[i8], size: 0 as i64},
        neighbor_total_capacity: 0
    }
}

// TODO adapt to new data layout
fn print_cell(cell: &Cell, index: [i32 * 3]) -> () {
    print_string("Memory address: ");
    print_i64(cell as i64);
    print_string("\nIndex: ");
    print_i32(index(0));
    print_string(" ");
    print_i32(index(1));
    print_string(" ");
    print_i32(index(2));
    print_string("\nSize: ");
    print_i32(cell.size);
    print_string("\nCapacity: ");
    print_i32(cell.capacity);
    print_string("\nPadding: ");
    print_i32(cell.padding); 
    print_string("\nNumber of clusters: ");
    print_i32(cell.nclusters);
    print_string("\nCluster size: ");
    print_i32(cell.cluster_size); 
    print_string("\n");
    print_string("Positions:\n");
    for i in range(0, cell.size) {
        print_vector(get_vector_from_struct_of_arrays(i, cell.positions));
        print_string("\n");
    }
    print_string("Forces:\n");
    for i in range(0, cell.size) {
        print_vector(get_vector_from_struct_of_arrays(i, cell.forces));
        print_string("\n");
    }
    print_string("Velocities:\n");
    for i in range(0, cell.size) {
        print_vector(get_vector_from_struct_of_arrays(i, cell.velocities));
        print_string("\n");
    }

/*
    print_string("Clusters:\n");
    let clusters = get_array_of_clusters(cell.clusters);
    for i in range(0, cell.nclusters) {
        print_cluster(clusters(i));
        print_string("\n");
    }
    print_string("\n");
    */
}

fn deallocate_cell(cell: &mut Cell) -> () {
    release_host(cell.masses);
    deallocate_struct_of_arrays(cell.positions);
    deallocate_struct_of_arrays(cell.velocities);
    deallocate_struct_of_arrays(cell.forces);
    cell.size = 0;
    cell.capacity = 0;
    cell_deallocate_clusters(cell);
}

fn copy_cell(src: &Cell, dest: &mut Cell) -> () {
    for i in range(0, src.size) {
        copy_particle(i, i, src, dest);
    }
}

fn @swap_particles(i: i32, j: i32, cell: &Cell) -> () {
    swap_real(i, j, (*cell).masses);
    swap_struct_of_arrays(i, j, (*cell).positions);
    swap_struct_of_arrays(i, j, (*cell).velocities);
}

fn @copy_particle(i: i32, j: i32, src: &Cell, dest: &Cell) -> () {
    set_real(j, dest.masses, get_real(i, src.masses));
    copy_struct_of_arrays(i, j, src.positions, dest.positions);
    copy_struct_of_arrays(i, j, src.velocities, dest.velocities);
}

fn @remove_particle(i: i32, cell: &mut Cell) -> () {
    swap_particles(i, (*cell).size - 1, cell);
    cell.size -= 1;
}

fn move_particle(i: i32, src: &mut Cell, dest: &mut Cell, allocate: fn(i32) -> Buffer) -> () {
    /*if(src as u64 == dest as u64) {
        print_string("Source and destinatin are identical!\n");
    }*/
    /*
    print_string("index: ");
    print_i32(dest.index);
    print_string("\nsize: ");
    print_i32(dest.size);
    print_string("\ncapacity: ");
    print_i32(dest.capacity);
    print_string("\n");
    */

    if(dest.size + 1 > dest.capacity) {
        reallocate_cell(dest.size + 1, dest, allocate);
    }
    else {
        dest.size += 1;
    }
    let src_last = src.size - 1;
    let dest_last = dest.size - 1;

    copy_particle(i, dest_last, src, dest); 

    if(i < src_last) {
        swap_particles(i, src_last, src);
    }
    src.size -= 1;
}

fn reallocate_cell(new_size: i32, dest: &mut Cell, allocate: fn(i32) -> Buffer) -> () {
    let new_capacity = dest.capacity + (dest.nclusters / 10 + 1) * dest.cluster_size;  
    let mut new_cell = allocate_cell(dest.index, new_size, new_capacity, dest.cluster_size, allocate);
    copy_cell(dest, &mut new_cell);
    deallocate_cell(dest);
    *dest = new_cell;
}

fn append_particle(mass: real_t, position: Vector3D, velocity: Vector3D, dest: &mut Cell, allocate: fn(i32) -> Buffer) -> () {
    /*print_string("Mass: ");
    print_f64(mass);
    print_string(" Position: ");
    print_vector(position);
    print_string(" Velocity: ");
    print_vector(velocity);
    print_string("\n");*/

    let null_vec = Vector3D { x: 0.0 as real_t, y: 0.0 as real_t, z: 0.0 as real_t };
    let new_size = dest.size + 1;
    if(dest.size == dest.capacity) {
        reallocate_cell(new_size, dest, allocate);
    }
    else {
        dest.size = new_size;
    }

    /*print_string("New size: ");
    print_i32(new_size);
    print_string("\n");*/
    set_real(new_size-1, dest.masses, mass);
    set_struct_of_arrays(new_size-1, dest.positions, position);
    set_struct_of_arrays(new_size-1, dest.velocities, velocity);
    set_struct_of_arrays(new_size-1, dest.forces, null_vec);
}

