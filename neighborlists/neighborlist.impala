fn neighbor_cells(index: i32, nx: i32, ny: i32, ncells: i32, body: fn(i32) -> ()) -> () {
    range(-1, 2, |offset_z| {
        let flat_offset_z = offset_z * nx * ny;

        range(-1, 2, |offset_y| {
            let flat_offset_y = offset_y * nx;

            range(-1, 2, |offset_x| {
                let nb_cell_index = index + flat_offset_z + flat_offset_y + offset_x;

                if nb_cell_index >= 0 && nb_cell_index < ncells {
                    @@body(nb_cell_index);
                }
            });
        });
    });
}

fn append_neighbor(
    cluster: i32,
    cell_index: i32,
    cell_offset: i32,
    neighbor_cluster: i32,
    neighbor_cell: i32,
    neighbor_offset: i32,
    grid: &mut Grid) -> () {

    let neighbors_per_cluster = get_array_of_i32(grid.neighbors_per_cluster_cpu);
    let nb_list_size = neighbors_per_cluster(cell_offset + cluster);

    if nb_list_size == grid.neighborlist_capacity {
        let adding = nb_list_size / 10 + 1;
        let extension = select(adding < 4, 4, adding);
        let capacity = grid.neighborlist_capacity + extension;

        reallocate_neighborlist_capacity(grid, capacity);
    }

    let neighborlists = get_array_of_i32(grid.neighborlists_cpu);
    let buffer_index = grid.neighborlist_capacity * (cell_offset + cluster) + nb_list_size;

    neighborlists(buffer_index) = neighbor_offset + neighbor_cluster * grid.cluster_size;
    neighbors_per_cluster(cell_offset + cluster) += 1;
}

// Redundant computation to get rid of atomics (only works when cluster_size = 1)
fn assemble_particles_full_neighborlist(
    cluster: i32,
    cell_index: i32,
    cell_offset: i32,
    grid: &mut Grid,
    cutoff_distance: real_t) -> () {

    let cell_sizes = get_array_of_i32(grid.cell_sizes);
    let squared_cutoff_distance = cutoff_distance * cutoff_distance;
    let cluster_index = cell_offset + cluster;
    let mx = get_x_component(cluster_index, grid.positions_cpu);
    let my = get_y_component(cluster_index, grid.positions_cpu);
    let mz = get_z_component(cluster_index, grid.positions_cpu);

    neighbor_cells(cell_index, grid.nx, grid.ny, grid.ncells, |neighboring_cell_index| {
        let same_cell = cell_index == neighboring_cell_index;
        let neighbor_cell_offset = get_cell_offset(neighboring_cell_index, grid);
        let neighbor_cell_size = cell_sizes(neighboring_cell_index);

        if same_cell == false {
            for z in range(0, neighbor_cell_size) {
                let neighbor_cluster_index = neighbor_cell_offset + z;
                let dx = mx - get_x_component(neighbor_cluster_index, grid.positions_cpu);
                let dy = my - get_y_component(neighbor_cluster_index, grid.positions_cpu);
                let dz = mz - get_z_component(neighbor_cluster_index, grid.positions_cpu);

                if dx * dx + dy * dy + dz * dz <= squared_cutoff_distance {
                    append_neighbor(cluster, cell_index, cell_offset, z, neighboring_cell_index, neighbor_cell_offset, grid);
                }
            }
        } else {
            for z in range(0, neighbor_cell_size) {
                if cluster != z {
                    let neighbor_cluster_index = neighbor_cell_offset + z;
                    let dx = mx - get_x_component(neighbor_cluster_index, grid.positions_cpu);
                    let dy = my - get_y_component(neighbor_cluster_index, grid.positions_cpu);
                    let dz = mz - get_z_component(neighbor_cluster_index, grid.positions_cpu);

                    if dx * dx + dy * dy + dz * dz <= squared_cutoff_distance {
                        append_neighbor(cluster, cell_index, cell_offset, z, neighboring_cell_index, neighbor_cell_offset, grid);
                    }
                }
            }
        }
    });
}

fn grid_assemble_neighborlists(
    grid: &mut Grid,
    cutoff_distance: real_t,
    assemble: fn(i32, i32, i32, &mut Grid, real_t)-> ()) -> () {

    let cell_sizes = get_array_of_i32(grid.cell_sizes);
    let neighbors_per_cluster = get_array_of_i32(grid.neighbors_per_cluster_cpu);

    range(0, grid.ncells, |cell_index| {
        let cell_offset = get_cell_offset(cell_index, grid);
        let cell_size = cell_sizes(cell_index);

        range(0, cell_size, |cluster| {
            neighbors_per_cluster(cell_offset + cluster) = 0;
            assemble(cluster, cell_index, cell_offset, grid, cutoff_distance);
        });
    });
}
