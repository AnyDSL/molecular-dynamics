fn neighbor_cells(index: i32, nx: i32, ny: i32, ncells: i32, body: fn(i32) -> ()) -> () {
    range(-1, 2, |offset_z| {
        let flat_offset_z = offset_z * nx * ny;

        range(-1, 2, |offset_y| {
            let flat_offset_y = offset_y * nx;

            range(-1, 2, |offset_x| {
                let nb_cell_index = index + flat_offset_z + flat_offset_y + offset_x;

                if nb_cell_index >= 0 && nb_cell_index < ncells {
                    @@body(nb_cell_index);
                }
            });
        });
    });
}

fn append_neighbor(particle_index: i32, neighbor_index: i32, grid: &mut Grid) -> () {
    let neighbors_sizes = get_array_of_i32(grid.neighbors_sizes_cpu);
    let neighborlists = get_array_of_i32(grid.neighborlists_cpu);
    let nb_list_size = neighbors_sizes(particle_index);

    if nb_list_size == grid.neighborlist_capacity {
        let adding = nb_list_size / 10 + 1;
        let extension = select(adding < 4, 4, adding);
        let capacity = grid.neighborlist_capacity + extension;

        reallocate_neighborlist_capacity(grid, capacity);
    }

    neighborlists(grid.neighborlist_capacity * particle_index + nb_list_size) = neighbor_index;
    neighbors_sizes(particle_index)++;
}

fn grid_assemble_neighborlists(grid: &mut Grid, cutoff_distance: real_t) -> () {
    let cell_particles = get_array_of_i32(grid.cell_particles_cpu);
    let cell_sizes = get_array_of_i32(grid.cell_sizes_cpu);
    let neighbors_sizes = get_array_of_i32(grid.neighbors_sizes_cpu);
    let squared_cutoff_distance = cutoff_distance * cutoff_distance;

    let ncells = grid.ncells;
    let cell_capacity = grid.cell_capacity;
    let nx = grid.nx;
    let ny = grid.ny;

    range(0, ncells, |cell_index| {
        let cell_offset = get_cell_offset(cell_index, grid);
        let cell_size = cell_sizes(cell_index);

        range(0, cell_size, |cell_particle_index| {
            let particle_index = cell_particles(cell_offset + cell_particle_index);
            let mx = get_x_component(particle_index, grid.positions_cpu);
            let my = get_y_component(particle_index, grid.positions_cpu);
            let mz = get_z_component(particle_index, grid.positions_cpu);

            neighbors_sizes(particle_index) = 0;

            neighbor_cells(cell_index, nx, ny, ncells, |neighboring_cell_index| {
                let same_cell = cell_index == neighboring_cell_index;

                if same_cell == false {
                    let neighbor_cell_offset = get_cell_offset(neighboring_cell_index, grid);
                    let neighbor_cell_size = cell_sizes(neighboring_cell_index);

                    range(0, neighbor_cell_size, |neighbor_particle_index| {
                        let neighbor_particle_index = cell_particles(neighbor_cell_offset + neighbor_particle_index);
                        let dx = mx - get_x_component(neighbor_particle_index, grid.positions_cpu);
                        let dy = my - get_y_component(neighbor_particle_index, grid.positions_cpu);
                        let dz = mz - get_z_component(neighbor_particle_index, grid.positions_cpu);

                        if dx * dx + dy * dy + dz * dz <= squared_cutoff_distance {
                            @@append_neighbor(particle_index, neighbor_particle_index, grid);
                        }
                    });
                } else {
                    range(0, cell_size, |neighbor_particle_index| {
                        if cell_particle_index != neighbor_particle_index {
                            let neighbor_particle_index = cell_particles(cell_offset + neighbor_particle_index);
                            let dx = mx - get_x_component(neighbor_particle_index, grid.positions_cpu);
                            let dy = my - get_y_component(neighbor_particle_index, grid.positions_cpu);
                            let dz = mz - get_z_component(neighbor_particle_index, grid.positions_cpu);

                            if dx * dx + dy * dy + dz * dz <= squared_cutoff_distance {
                                @@append_neighbor(particle_index, neighbor_particle_index, grid);
                            }
                        }
                    });
                }
            });

        });
    });
}
