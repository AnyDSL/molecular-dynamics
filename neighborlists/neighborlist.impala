/* Insertion sort */
fn cell_sort(cell: &Cell) -> () {
    for i in range(1, cell.size) {
        let mut j = i;
        while (j > 0 && get_z_component(j - 1, cell.positions) > get_z_component(j, cell.positions)) { 
            swap_particles(j, j - 1, cell);
            --j;
        }
    }
}

fn cell_allocate_clusters(cell: &mut Cell, neighbor_list_capacity: i32, allocate: fn(i32) -> Buffer) -> () {
    let mut nclusters = cell.size / cell.cluster_size;
    let rest = cell.size % cell.cluster_size;
    if(rest > 0) {
        nclusters += 1;
    }
    let padding = nclusters * cell.cluster_size - cell.size;
    cell.padding = padding;
    if(nclusters != cell.nclusters) {
        add_cluster_allocation(nclusters * sizeof[Cluster]());
        add_neighbor_list_allocation(neighbor_list_capacity * sizeof[&Cell]());
        add_neighbor_list_allocation(neighbor_list_capacity * sizeof[i32]());

        cell_deallocate_clusters(cell);
        cell.nclusters = nclusters;
        cell.clusters = allocate(nclusters * sizeof[Cluster]());
        cell.neighbor_cells = allocate(neighbor_list_capacity * sizeof[&Cell]());
        cell.neighbor_indices = allocate(neighbor_list_capacity * sizeof[i32]());
        cell.neighbor_total_capacity = neighbor_list_capacity * nclusters;

        let clusters = get_array_of_clusters(cell.clusters);

        for i in range(0, nclusters) {
            let buffer_offset = neighbor_list_capacity * i;

            clusters(i).neighbor_list = NeighborList {
                size: 0,
                capacity: neighbor_list_capacity,
                buffer_offset: buffer_offset
            }
        }
    }
}

fn cell_deallocate_clusters(cell: &mut Cell) -> () {
    let clusters = get_array_of_clusters(cell.clusters);
    if(cell.nclusters > 0) {
        release_host(cell.neighbor_cells);
        release_host(cell.neighbor_indices);
        release_host(cell.clusters);
        cell.nclusters = 0;
    }
}

fn @compute_bounding_box(positions: StructOfArrays3D, base_index: i32, @cluster_size: i32) -> AABB {
    let mut aabb : AABB;
    aabb.min(0) = get_x_component(base_index, positions);
    aabb.min(1) = get_y_component(base_index, positions);
    aabb.min(2) = get_z_component(base_index, positions);
    aabb.max(0) = get_x_component(base_index, positions);
    aabb.max(1) = get_y_component(base_index, positions);
    aabb.max(2) = get_z_component(base_index, positions);
    for j in range(1, cluster_size) {
        let index = base_index + j;
        if(get_x_component(index, positions) < aabb.min(0)) {
            aabb.min(0) = get_x_component(index, positions);
        }
        else if(get_x_component(index, positions) > aabb.max(0)) {
            aabb.max(0) = get_x_component(index, positions);
        }
        if(get_y_component(index, positions) < aabb.min(1)) {
            aabb.min(1) = get_y_component(index, positions);
        }
        else if(get_y_component(index, positions) > aabb.max(1)) {
            aabb.max(1) = get_y_component(index, positions);
        }
        if(get_z_component(index, positions) < aabb.min(2)) {
            aabb.min(2) = get_z_component(index, positions);
        }
        else if(get_z_component(index, positions) > aabb.max(2)) {
            aabb.max(2) = get_z_component(index, positions);
        }
    }
    //print_AABB(aabb);
    aabb
}

fn cell_compute_bounding_boxes(cell: &Cell) -> () {
    let nclusters = cell.nclusters;
    let cluster_size = cell.cluster_size;
    let clusters = get_array_of_clusters(cell.clusters);
    for i in range(0, nclusters - 1) {
        clusters(i).aabb = compute_bounding_box(cell.positions, i * cluster_size, cluster_size);
    }
    let i = nclusters - 1;
    clusters(i).aabb = compute_bounding_box(cell.positions, i * cluster_size, cluster_size - cell.padding);  
}

fn grid_initialize_clusters(grid: &Grid, neighbor_list_capacity: i32, allocate: fn(i32) -> Buffer, outer_loop: fn(i32, i32, fn(i32) -> ()) -> (), middle_loop: fn(i32, i32, fn(i32) -> ()) -> (), inner_loop: fn(i32, i32, fn(i32) -> ()) -> ()) -> () {
    for cell, cell_index in map_over_grid(grid, outer_loop, middle_loop, inner_loop) {
        if(cell.size > 0) {
            cell_sort(cell);
            cell_allocate_clusters(cell, neighbor_list_capacity, allocate);
            cell_compute_bounding_boxes(cell);
        }
        else {
            cell_deallocate_clusters(cell);
        }
    }
}

struct NeighborList {
    size: i32,
    capacity: i32,
    buffer_offset: i32
}

fn print_neighbor_list(neighbor_list: &NeighborList) -> () {
    print_string("Size: ");
    print_i32(neighbor_list.size);
    print_string("\nCapacity: ");
    print_i32(neighbor_list.capacity);
    print_string("\nOffset: ");
    print_i32(neighbor_list.buffer_offset);
    print_string("\n");

    /*
    let cells = get_array_of_cell_pointers(neighbor_list.cells);
    let indices = get_array_of_i32(neighbor_list.indices);
    for i in range(0, neighbor_list.size) {
        print_string("Cell address: ");
        print_i64(cells(i) as i64);
        print_string(" Index: ");
        print_i32(indices(i));
        print_string("\n");
    }
    */
}

fn append_neighbor(cell: &mut Cell, cluster_index: i32, neighbor_cell: &Cell, index: i32, allocate: fn(i32) -> Buffer) -> () {
    let clusters = get_array_of_clusters(cell.clusters);
    let neighbor_list = clusters(cluster_index).neighbor_list;

    let new_size = neighbor_list.size;
    if(neighbor_list.size == neighbor_list.capacity) {
        let adding = new_size / 10 + 1;
        let extension = if(adding < 4) {4} else {adding};
        let new_capacity = new_size + extension;

        cell.neighbor_total_capacity += extension;

        add_neighbor_list_allocation(extension * sizeof[&Cell]());
        add_neighbor_list_allocation(extension * sizeof[i32]());

        let neighbor_cells = allocate(cell.neighbor_total_capacity * sizeof[&Cell]());
        let neighbor_indices = allocate(cell.neighbor_total_capacity * sizeof[i32]());
        let mut buffer_offset = 0;

        for i in range(0, cell.nclusters) {
            for j in range(0, clusters(i).neighbor_list.size) {
                set_cell_pointer(buffer_offset + j, neighbor_cells,
                    get_cell_pointer(neighbor_list.buffer_offset + j, cell.neighbor_cells));

                set_i32(buffer_offset + j, neighbor_indices, get_i32(neighbor_list.buffer_offset + j, cell.neighbor_indices));
            }

            if(i == cluster_index) {
                set_cell_pointer(buffer_offset + neighbor_list.size, neighbor_cells, neighbor_cell);
                set_i32(buffer_offset + neighbor_list.size, neighbor_indices, index);

                clusters(i).neighbor_list.size += 1;
                clusters(i).neighbor_list.capacity = new_capacity;
            }

            clusters(i).neighbor_list.buffer_offset = buffer_offset;
            buffer_offset += clusters(i).neighbor_list.capacity;
        }

        release_host(cell.neighbor_cells);
        release_host(cell.neighbor_indices);

        cell.neighbor_cells = neighbor_cells;
        cell.neighbor_indices = neighbor_indices;
    }
}

fn @compute_distance(a: AABB, b: AABB, dimension: i32) -> real_t {
    if(a.min(dimension) > b.max(dimension)) {
        a.min(dimension) - b.max(dimension)
    }
    else if(b.min(dimension) > a.max(dimension)) {
        b.min(dimension) - a.max(dimension)
    }
    else {
        0.0 as real_t
    }
}

fn assemble_half_neighbor_list(cluster: &mut Cluster, cluster_index: i32, cell: &mut Cell, cell_index: [i32 * 3], grid: &Grid, cutoff_distance: real_t, allocate: fn(i32) -> Buffer)-> () {
    cluster.neighbor_list.size = 0;
    let mut begin : [i32 * 3];
    let mut end : [i32 * 3];
    let nxyz = [grid.nx, grid.ny, grid.nz];
    for i in unroll(0, 3) {
        begin(i) = cell_index(i);
        end(i) = if(cell_index(i) < nxyz(i) - 1) { cell_index(i) + 2} else { nxyz(i) };
    }
    let squared_cutoff_distance = cutoff_distance * cutoff_distance;
    let cells = get_array_of_cells(grid.cells);
    for i in range(begin(0), end(0)) {
        for j in range(begin(1), end(1)) {
            for k in range(begin(2), end(2)) {
                let neighboring_cell_index = [i,j,k];
                let neighboring_cell = &cells(flatten_index(neighboring_cell_index, grid));
                if(neighboring_cell.nclusters > 0) {
                    let mut z = 0;
                    if(flatten_index(neighboring_cell_index, grid) == flatten_index(cell_index, grid)) {
                        while(z <= cluster_index){ ++z; }
                    }
                    let clusters = get_array_of_clusters(cell.clusters);
                    let mut z_distance = compute_distance(cluster.aabb, clusters(0).aabb, 2);
                    while(z < neighboring_cell.nclusters - 1 && z_distance > cutoff_distance) {
                        ++z;
                        z_distance = compute_distance(cluster.aabb, clusters(z).aabb, 2);
                    }
                    while(z < neighboring_cell.nclusters && z_distance < cutoff_distance) {
                        let x_distance = compute_distance(cluster.aabb, clusters(z).aabb, 0); 
                        let y_distance = compute_distance(cluster.aabb, clusters(z).aabb, 1); 
                        let squared_distance = x_distance*x_distance + y_distance*y_distance + z_distance*z_distance;
                        let difference = squared_cutoff_distance - squared_distance;
                        if(difference > 0.0 as real_t) {
                            // TODO check distance to individual particles if the distance is below a certain threshold
                            append_neighbor(cell, cluster_index, neighboring_cell, z, allocate);
                        }
                        ++z;
                        /* TODO: should be neighboring_cell.nclusters here instead? */
                        if(z < cell.nclusters) {
                            z_distance = compute_distance(cluster.aabb, clusters(z).aabb, 2); 
                        }
                    }
                }
            }
        } 
    }
}

// redundant computation to get rid of atomics
fn assemble_full_neighbor_list(cluster: &mut Cluster, cluster_index: i32, cell: &mut Cell, cell_index: [i32 * 3], grid: &Grid, cutoff_distance: real_t, allocate: fn(i32) -> Buffer)-> () {
    cluster.neighbor_list.size = 0;
    let mut begin : [i32 * 3];
    let mut end : [i32 * 3];
    let nxyz = [grid.nx, grid.ny, grid.nz];
    for i in unroll(0, 3) {
        begin(i) = if(cell_index(i) > 0) {cell_index(i) - 1} else { 0 };
        end(i) = if(cell_index(i) < nxyz(i) - 1) { cell_index(i) + 2} else { nxyz(i) };
    }
    let squared_cutoff_distance = cutoff_distance * cutoff_distance;
    let cells = get_array_of_cells(grid.cells);
    let flat_cell_index = flatten_index(cell_index, grid);
    for i in range(begin(0), end(0)) {
        for j in range(begin(1), end(1)) {
            for k in range(begin(2), end(2)) {
                let neighboring_cell_index = [i,j,k];
                let flat_neighboring_cell_index = flatten_index(neighboring_cell_index, grid);
                let same_cell = flat_cell_index == flat_neighboring_cell_index;
                let neighboring_cell = &cells(flat_neighboring_cell_index);
                if(neighboring_cell.nclusters > 0) {
                    let mut z = 0;
                    let clusters = get_array_of_clusters(neighboring_cell.clusters);
                    let mut z_distance = compute_distance(cluster.aabb, clusters(0).aabb, 2);
                    while(z < neighboring_cell.nclusters - 1 && z_distance > cutoff_distance) {
                        ++z;
                        z_distance = compute_distance(cluster.aabb, clusters(z).aabb, 2);
                    }
                    while(z < neighboring_cell.nclusters && z_distance < cutoff_distance) {
                        if(same_cell == false || cluster_index != z) {
                            let x_distance = compute_distance(cluster.aabb, clusters(z).aabb, 0); 
                            let y_distance = compute_distance(cluster.aabb, clusters(z).aabb, 1); 
                            let squared_distance = x_distance*x_distance + y_distance*y_distance + z_distance*z_distance;
                            if(squared_distance < squared_cutoff_distance) {
                                append_neighbor(cell, cluster_index, neighboring_cell, z, allocate);
                            }
                        }
                        ++z;
                        /* TODO: should be neighboring_cell.nclusters here instead? */
                        if(z < cell.nclusters) {
                            z_distance = compute_distance(cluster.aabb, clusters(z).aabb, 2); 
                        }
                    }
                }
            }
        } 
    }
}

fn individual_particles_are_in_distance(squared_cutoff_distance: real_t, cluster_index1: i32, cell1: &Cell, cluster_index2: i32, cell2: &Cell) -> bool {
    let cluster_size1 = cell1.cluster_size;
    let cluster_size2 = cell2.cluster_size;
    let begin1 = cluster_index1 * cluster_size1;
    let end1 = begin1 + cluster_size1;
    let begin2 = cluster_index2 * cluster_size2;
    let end2 = begin2 + cluster_size2;
    let mut retval = false;
    let mut count = 0;
    for i in unroll(begin1, end1) {
        for j in unroll(begin2, end2) {
            let dx = get_x_component(j, cell2.positions) - get_x_component(i, cell1.positions);
            let dy = get_y_component(j, cell2.positions) - get_y_component(i, cell1.positions);
            let dz = get_z_component(j, cell2.positions) - get_z_component(i, cell1.positions);
            let squared_distance = (dx*dx + dy*dy + dz*dz) as real_t;

            if(squared_distance < squared_cutoff_distance) {
                if(squared_distance < (0.9 as real_t) * squared_cutoff_distance) {
                    retval = true;
                    break()
                }
                ++count;
            }
            if(count > (PRUNING_THRESHOLD * ((cell1.cluster_size * cell2.cluster_size) as real_t)) as i32)  {
                retval = true;
                break()
            }
        }
        if(retval == false) {
            break()
        }
    }
    retval
}

fn cell_assemble_neighbor_lists(cell: &mut Cell, cell_index: [i32 * 3], grid: &Grid, cutoff_distance: real_t, allocate: fn(i32) -> Buffer) -> () {
    let clusters = get_array_of_clusters(cell.clusters);
    for i in range(0, cell.nclusters) {
        assemble_full_neighbor_list(&mut clusters(i), i, cell, cell_index, grid, cutoff_distance, allocate);
    }
}

fn grid_assemble_neighbor_lists(grid: &Grid, cutoff_distance: real_t, allocate: fn(i32) -> Buffer, outer_loop: fn(i32, i32, fn(i32) -> ()) -> (), middle_loop: fn(i32, i32, fn(i32) -> ()) -> (), inner_loop: fn(i32, i32, fn(i32) -> ()) -> ()) -> () {
    for cell, cell_index in map_over_grid(grid, outer_loop, middle_loop, inner_loop) {
        if(cell.size > 0) {
            cell_assemble_neighbor_lists(cell, cell_index, grid, cutoff_distance, allocate);
        }
    }
}
