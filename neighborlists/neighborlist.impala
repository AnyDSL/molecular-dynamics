/* Insertion sort */
fn cell_sort(cell: &Cell) -> () {
    for i in range(1, cell.size) {
        let mut j = i;
        while (j > 0 && get_z_component(j - 1, cell.positions) > get_z_component(j, cell.positions)) { 
            swap_particles(j, j - 1, cell);
            --j;
        }
    }
}

fn cell_allocate_clusters(cell: &mut Cell, neighbor_list_capacity: i32, allocate: fn(i32) -> Buffer) -> () {
    let mut nclusters = cell.size / cell.cluster_size;
    let rest = cell.size % cell.cluster_size;
    if(rest > 0) {
        nclusters += 1;
    }
    let padding = nclusters * cell.cluster_size - cell.size;
    cell.padding = padding;
    if(nclusters != cell.nclusters) {
        cell_deallocate_clusters(cell);
        cell.nclusters = nclusters;
        cell.clusters = allocate(nclusters * sizeof[Cluster]());
        let clusters = get_array_of_clusters(cell.clusters);
        for i in range(0, nclusters) {
            clusters(i).neighbor_list = allocate_neighbor_list(0, neighbor_list_capacity, allocate);
        }
    }
}

fn cell_deallocate_clusters(cell: &mut Cell) -> () {
    let clusters = get_array_of_clusters(cell.clusters);
    if(cell.nclusters > 0) {
        for i in range(0, cell.nclusters) {
            deallocate_neighbor_list(&mut clusters(i).neighbor_list);
        }
        release(cell.clusters);
        cell.nclusters = 0;
    }
}

fn @compute_bounding_box(positions: StructOfArrays3D, base_index: i32, @cluster_size: i32) -> AABB {
    let mut aabb : AABB;
    aabb.min(0) = get_x_component(base_index, positions);
    aabb.min(1) = get_y_component(base_index, positions);
    aabb.min(2) = get_z_component(base_index, positions);
    aabb.max(0) = get_x_component(base_index, positions);
    aabb.max(1) = get_y_component(base_index, positions);
    aabb.max(2) = get_z_component(base_index, positions);
    for j in range(1, cluster_size) {
        let index = base_index + j;
        if(get_x_component(index, positions) < aabb.min(0)) {
            aabb.min(0) = get_x_component(index, positions);
        }
        else if(get_x_component(index, positions) > aabb.max(0)) {
            aabb.max(0) = get_x_component(index, positions);
        }
        if(get_y_component(index, positions) < aabb.min(1)) {
            aabb.min(1) = get_y_component(index, positions);
        }
        else if(get_y_component(index, positions) > aabb.max(1)) {
            aabb.max(1) = get_y_component(index, positions);
        }
        if(get_z_component(index, positions) < aabb.min(2)) {
            aabb.min(2) = get_z_component(index, positions);
        }
        else if(get_z_component(index, positions) > aabb.max(2)) {
            aabb.max(2) = get_z_component(index, positions);
        }
    }
    //print_AABB(aabb);
    aabb
}

fn cell_compute_bounding_boxes(cell: &Cell) -> () {
    let nclusters = cell.nclusters;
    let cluster_size = cell.cluster_size;
    let clusters = get_array_of_clusters(cell.clusters);
    for i in range(0, nclusters - 1) {
        clusters(i).aabb = compute_bounding_box(cell.positions, i * cluster_size, cluster_size);
    }
    let i = nclusters - 1;
    clusters(i).aabb = compute_bounding_box(cell.positions, i * cluster_size, cluster_size - cell.padding);  
}

fn grid_initialize_clusters(grid: &Grid, neighbor_list_capacity: i32, allocate: fn(i32) -> Buffer, outer_loop: fn(i32, i32, fn(i32) -> ()) -> (), middle_loop: fn(i32, i32, fn(i32) -> ()) -> (), inner_loop: fn(i32, i32, fn(i32) -> ()) -> ()) -> () {
    for cell, cell_index in map_over_grid(grid, outer_loop, middle_loop, inner_loop) {
        if(cell.size > 0) {
            cell_sort(cell);
            cell_allocate_clusters(cell, neighbor_list_capacity, allocate);
            cell_compute_bounding_boxes(cell);
        }
        else {
            cell_deallocate_clusters(cell);
        }
    }
}

struct NeighborList {
    size: i32,
    capacity: i32,
    cells: Buffer,
    indices: Buffer
}

fn print_neighbor_list(neighbor_list: &NeighborList) -> () {
    print_string("Size: ");
    print_i32(neighbor_list.size);
    print_string("\nCapacity: ");
    print_i32(neighbor_list.capacity);
    print_string("\n");
    let cells = get_array_of_cell_pointers(neighbor_list.cells);
    let indices = get_array_of_i32(neighbor_list.indices);
    for i in range(0, neighbor_list.size) {
        print_string("Cell address: ");
        print_i64(cells(i) as i64);
        print_string(" Index: ");
        print_i32(indices(i));
        print_string("\n");
    }
}

fn @allocate_neighbor_list(size: i32, capacity: i32, allocate: fn(i32) -> Buffer) -> NeighborList {
    NeighborList {
        size: size,
        capacity: capacity,
        cells: allocate(capacity * sizeof[&Cell]()),
        indices: allocate(capacity * sizeof[i32]())
    }
}

fn copy_neighbor_list(src: &NeighborList, dest: &NeighborList) -> () {
    for i in range(0, src.size) {
        set_cell_pointer(i, dest.cells, get_cell_pointer(i, src.cells));
        set_i32(i, dest.indices, get_i32(i, src.indices));
    }
}

fn append_neighbor(neighbor_list: &mut NeighborList, cell: &Cell, index: i32, allocate: fn(i32) -> Buffer) -> () {
    let new_size = neighbor_list.size;
    if(neighbor_list.size == neighbor_list.capacity) {
        let extension = new_size / 10 + 1;
        let new_capacity = new_size + if(extension < 4) {4} else {extension};
        let dest = allocate_neighbor_list(new_size, new_capacity, allocate);
        copy_neighbor_list(neighbor_list, &dest);
        deallocate_neighbor_list(neighbor_list);
        *neighbor_list = dest;
    }
    set_cell_pointer(neighbor_list.size, neighbor_list.cells, cell);
    set_i32(neighbor_list.size, neighbor_list.indices, index);
    neighbor_list.size += 1;
}

fn deallocate_neighbor_list(neighbor_list: &mut NeighborList) -> () {
    release(neighbor_list.cells);
    release(neighbor_list.indices);
    neighbor_list.size = 0;
    neighbor_list.capacity = 0;
}

fn @compute_distance(a: AABB, b: AABB, dimension: i32) -> real_t {
    if(a.min(dimension) > b.max(dimension)) {
        a.min(dimension) - b.max(dimension)
    }
    else if(b.min(dimension) > a.max(dimension)) {
        b.min(dimension) - a.max(dimension)
    }
    else {
        0.0 as real_t
    }
}

fn assemble_half_neighbor_list(cluster: &mut Cluster, cluster_index: i32, cell: &Cell, cell_index: [i32 * 3], grid: &Grid, cutoff_distance: real_t, allocate: fn(i32) -> Buffer)-> () { 
    cluster.neighbor_list.size = 0;
    let mut begin : [i32 * 3];
    let mut end : [i32 * 3];
    let nxyz = [grid.nx, grid.ny, grid.nz];
    for i in unroll(0, 3) {
        begin(i) = cell_index(i);
        end(i) = if(cell_index(i) < nxyz(i) - 1) { cell_index(i) + 2} else { nxyz(i) };
    }
    let squared_cutoff_distance = cutoff_distance * cutoff_distance;
    let cells = get_array_of_cells(grid.cells);
    for i in range(begin(0), end(0)) {
        for j in range(begin(1), end(1)) {
            for k in range(begin(2), end(2)) {
                let neighboring_cell_index = [i,j,k];
                let neighboring_cell = &cells(flatten_index(neighboring_cell_index, grid));
                if(neighboring_cell.nclusters > 0) {
                    let mut z = 0;
                    if(flatten_index(neighboring_cell_index, grid) == flatten_index(cell_index, grid)) {
                        while(z <= cluster_index){ ++z; }
                    }
                    let clusters = get_array_of_clusters(cell.clusters);
                    let mut z_distance = compute_distance(cluster.aabb, clusters(0).aabb, 2);
                    while(z < neighboring_cell.nclusters - 1 && z_distance > cutoff_distance) {
                        ++z;
                        z_distance = compute_distance(cluster.aabb, clusters(z).aabb, 2);
                    }
                    while(z < neighboring_cell.nclusters && z_distance < cutoff_distance) {
                        let x_distance = compute_distance(cluster.aabb, clusters(z).aabb, 0); 
                        let y_distance = compute_distance(cluster.aabb, clusters(z).aabb, 1); 
                        let squared_distance = x_distance*x_distance + y_distance*y_distance + z_distance*z_distance;
                        let difference = squared_cutoff_distance - squared_distance;
                        if(difference > 0.0 as real_t) {
                            // TODO check distance to individual particles if the distance is below a certain threshold
                            append_neighbor(&mut cluster.neighbor_list, neighboring_cell, z, allocate);
                        }
                        ++z;
                        if(z < cell.nclusters) {
                            z_distance = compute_distance(cluster.aabb, clusters(z).aabb, 2); 
                        }
                    }
                }
            }
        } 
    }
}

// redundant computation to get rid of atomics
fn assemble_full_neighbor_list(cluster: &mut Cluster, cluster_index: i32, cell: &Cell, cell_index: [i32 * 3], grid: &Grid, cutoff_distance: real_t, allocate: fn(i32) -> Buffer)-> () { 
    cluster.neighbor_list.size = 0;
    let mut begin : [i32 * 3];
    let mut end : [i32 * 3];
    let nxyz = [grid.nx, grid.ny, grid.nz];
    for i in unroll(0, 3) {
        begin(i) = if(cell_index(i) > 0) {cell_index(i) - 1} else { 0 };
        end(i) = if(cell_index(i) < nxyz(i) - 1) { cell_index(i) + 2} else { nxyz(i) };
    }
    let squared_cutoff_distance = cutoff_distance * cutoff_distance;
    let cells = get_array_of_cells(grid.cells);
    let flat_cell_index = flatten_index(cell_index, grid);
    for i in range(begin(0), end(0)) {
        for j in range(begin(1), end(1)) {
            for k in range(begin(2), end(2)) {
                let neighboring_cell_index = [i,j,k];
                let flat_neighboring_cell_index = flatten_index(neighboring_cell_index, grid);
                let same_cell = flat_cell_index == flat_neighboring_cell_index;
                let neighboring_cell = &cells(flat_neighboring_cell_index);
                if(neighboring_cell.nclusters > 0) {
                    let mut z = 0;
                    let clusters = get_array_of_clusters(neighboring_cell.clusters);
                    let mut z_distance = compute_distance(cluster.aabb, clusters(0).aabb, 2);
                    while(z < neighboring_cell.nclusters - 1 && z_distance > cutoff_distance) {
                        ++z;
                        z_distance = compute_distance(cluster.aabb, clusters(z).aabb, 2);
                    }
                    while(z < neighboring_cell.nclusters && z_distance < cutoff_distance) {
                        if(same_cell == false || cluster_index != z) {
                            let x_distance = compute_distance(cluster.aabb, clusters(z).aabb, 0); 
                            let y_distance = compute_distance(cluster.aabb, clusters(z).aabb, 1); 
                            let squared_distance = x_distance*x_distance + y_distance*y_distance + z_distance*z_distance;
                            if(squared_distance < squared_cutoff_distance) {
                                append_neighbor(&mut cluster.neighbor_list, neighboring_cell, z, allocate);
                            }
                        }
                        ++z;
                        if(z < cell.nclusters) {
                            z_distance = compute_distance(cluster.aabb, clusters(z).aabb, 2); 
                        }
                    }
                }
            }
        } 
    }
}

fn individual_particles_are_in_distance(squared_cutoff_distance: real_t, cluster_index1: i32, cell1: &Cell, cluster_index2: i32, cell2: &Cell) -> bool {
    let cluster_size1 = cell1.cluster_size;
    let cluster_size2 = cell2.cluster_size;
    let begin1 = cluster_index1 * cluster_size1;
    let end1 = begin1 + cluster_size1;
    let begin2 = cluster_index2 * cluster_size2;
    let end2 = begin2 + cluster_size2;
    let mut retval = false;
    let mut count = 0;
    for i in unroll(begin1, end1) {
        for j in unroll(begin2, end2) {
            let dx = get_x_component(j, cell2.positions) - get_x_component(i, cell1.positions);
            let dy = get_y_component(j, cell2.positions) - get_y_component(i, cell1.positions);
            let dz = get_z_component(j, cell2.positions) - get_z_component(i, cell1.positions);
            let squared_distance = dx*dx + dy*dy + dz*dz;

            if(squared_distance < squared_cutoff_distance) {
                if(squared_distance < 0.9 * squared_cutoff_distance) {
                    retval = true;
                    break()
                }
                ++count;
            }
            if(count > (PRUNING_THRESHOLD * (cell1.cluster_size * cell2.cluster_size) as real_t) as i32)  {
                retval = true;
                break()
            }
        }
        if(retval == false) {
            break()
        }
    }
    retval
}

fn cell_assemble_neighbor_lists(cell: &Cell, cell_index: [i32 * 3], grid: &Grid, cutoff_distance: real_t, allocate: fn(i32) -> Buffer) -> () {
    let clusters = get_array_of_clusters(cell.clusters);
    for i in range(0, cell.nclusters) {
        assemble_full_neighbor_list(&mut clusters(i), i, cell, cell_index, grid, cutoff_distance, allocate);
    }
}

fn grid_assemble_neighbor_lists(grid: &Grid, cutoff_distance: real_t, allocate: fn(i32) -> Buffer, outer_loop: fn(i32, i32, fn(i32) -> ()) -> (), middle_loop: fn(i32, i32, fn(i32) -> ()) -> (), inner_loop: fn(i32, i32, fn(i32) -> ()) -> ()) -> () {
    for cell, cell_index in map_over_grid(grid, outer_loop, middle_loop, inner_loop) {
        if(cell.size > 0) {
            cell_assemble_neighbor_lists(cell, cell_index, grid, cutoff_distance, allocate);
        }
    }
}
