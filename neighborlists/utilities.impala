
fn @set_thread_count(thread_count: i32) -> () {
    THREAD_COUNT = thread_count;
}

fn @get_thread_count() -> i32 { THREAD_COUNT }

fn @outer_loop_cpu(lower: i32, upper: i32, body: fn(i32) -> ()) -> () {
    for i in parallel(get_thread_count(), lower, upper) {
        @@body(i);
    }
}

fn @middle_loop_cpu(lower: i32, upper: i32, body: fn(i32) -> ()) -> () {
    range(lower, upper, body)
}

fn @inner_loop_cpu(lower: i32, upper: i32, body: fn(i32) -> ()) -> () {
    range(lower, upper, body)
}

struct StructOfArrays3D {
    x: Buffer,
    y: Buffer,
    z: Buffer
}

fn alloc_unaligned_cpu(size: i32) -> Buffer {
    alloc_host(0, size)
}

fn @release_host(buf: Buffer) -> () {
    runtime_release_host(buf.device, buf.data)
}

fn allocate_struct_of_arrays(N: i32) -> StructOfArrays3D {
    let struct_of_arrays = StructOfArrays3D {
        x: alloc_unaligned_cpu(N * sizeof[real_t]()),
        y: alloc_unaligned_cpu(N * sizeof[real_t]()),
        z: alloc_unaligned_cpu(N * sizeof[real_t]())
    };
    struct_of_arrays
}

fn deallocate_struct_of_arrays(struct_of_arrays: StructOfArrays3D) -> () {
    release_host(struct_of_arrays.x);
    release_host(struct_of_arrays.y);
    release_host(struct_of_arrays.z);
}


fn @copy_offset_struct_of_arrays(src: StructOfArrays3D, offset_src: i32, dest: StructOfArrays3D, offset_dest: i32, N: i32) -> () { 
    copy_offset(src.x, offset_src * sizeof[real_t](), dest.x, offset_dest * sizeof[real_t](), N * sizeof[real_t]());
    copy_offset(src.y, offset_src * sizeof[real_t](), dest.y, offset_dest * sizeof[real_t](), N * sizeof[real_t]());
    copy_offset(src.z, offset_src * sizeof[real_t](), dest.z, offset_dest * sizeof[real_t](), N * sizeof[real_t]());
}

fn set_struct_of_arrays(i: i32, struct_of_arrays: StructOfArrays3D, vector: Vector3D) -> () {
    bitcast[&mut[real_t]](struct_of_arrays.x.data)(i) = vector.x;
    bitcast[&mut[real_t]](struct_of_arrays.y.data)(i) = vector.y;
    bitcast[&mut[real_t]](struct_of_arrays.z.data)(i) = vector.z;
}

fn get_vector_from_struct_of_arrays(i: i32, struct_of_arrays: StructOfArrays3D) -> Vector3D {
    Vector3D {
        x: bitcast[&mut[real_t]](struct_of_arrays.x.data)(i), 
        y: bitcast[&mut[real_t]](struct_of_arrays.y.data)(i), 
        z: bitcast[&mut[real_t]](struct_of_arrays.z.data)(i) 
    }
}

fn get_x_component(i: i32, struct_of_arrays: StructOfArrays3D) -> real_t {
    bitcast[&mut[real_t]](struct_of_arrays.x.data)(i)
}

fn get_y_component(i: i32, struct_of_arrays: StructOfArrays3D) -> real_t {
    bitcast[&mut[real_t]](struct_of_arrays.y.data)(i)
}

fn get_z_component(i: i32, struct_of_arrays: StructOfArrays3D) -> real_t {
    bitcast[&mut[real_t]](struct_of_arrays.z.data)(i)
}

fn copy_struct_of_arrays(i: i32, j: i32, src: StructOfArrays3D, dest: StructOfArrays3D) -> () {
   bitcast[&mut[real_t]](dest.x.data)(j) = bitcast[&[real_t]](src.x.data)(i);  
   bitcast[&mut[real_t]](dest.y.data)(j) = bitcast[&[real_t]](src.y.data)(i);  
   bitcast[&mut[real_t]](dest.z.data)(j) = bitcast[&[real_t]](src.z.data)(i);  
}

fn swap_struct_of_arrays(i: i32, j: i32, struct_of_arrays: StructOfArrays3D) -> () {
   let tmp_x = bitcast[&[real_t]](struct_of_arrays.x.data)(i);  
   let tmp_y = bitcast[&[real_t]](struct_of_arrays.y.data)(i);  
   let tmp_z = bitcast[&[real_t]](struct_of_arrays.z.data)(i);  
   bitcast[&mut[real_t]](struct_of_arrays.x.data)(i) = bitcast[&[real_t]](struct_of_arrays.x.data)(j);  
   bitcast[&mut[real_t]](struct_of_arrays.y.data)(i) = bitcast[&[real_t]](struct_of_arrays.y.data)(j);  
   bitcast[&mut[real_t]](struct_of_arrays.z.data)(i) = bitcast[&[real_t]](struct_of_arrays.z.data)(j);  
   bitcast[&mut[real_t]](struct_of_arrays.x.data)(j) = tmp_x;  
   bitcast[&mut[real_t]](struct_of_arrays.y.data)(j) = tmp_y;  
   bitcast[&mut[real_t]](struct_of_arrays.z.data)(j) = tmp_z;  
}

struct Vector3D {
    x: real_t,
    y: real_t,
    z: real_t
}

fn @print_vector(vector: Vector3D) -> () {
    print_f64(vector.x as f64);
    print_string("\t");
    print_f64(vector.y as f64);
    print_string("\t");
    print_f64(vector.z as f64);
}

fn @print_index(index: [i32 * 2]) -> () {
    print_i32(index(0));
    print_string(" ");
    print_i32(index(1));
}

fn @swap_real(i: i32, j: i32, buf: Buffer) -> () {
    let tmp = get_real(i, buf);
    set_real(i, buf, get_real(j, buf));
    set_real(j, buf, tmp);
}


fn @get_real(i: i32, buf: Buffer) -> real_t {
    bitcast[&[real_t]](buf.data)(i)
}

fn @set_real(i: i32, buf: Buffer, value: real_t) -> () { 
    bitcast[&mut[real_t]](buf.data)(i) = value;
}

fn @get_array_of_reals(buf: Buffer) -> &mut[real_t] {
    bitcast[&mut[real_t]](buf.data)
}

fn @get_i32(i: i32, buf: Buffer) -> i32 {
    bitcast[&[i32]](buf.data)(i)
}

fn @set_i32(i: i32, buf: Buffer, value: i32) -> () {
    bitcast[&mut[i32]](buf.data)(i) = value;
}

fn @get_i64(i: i32, buf: Buffer) -> i64 {
    bitcast[&[i64]](buf.data)(i)
}

fn @set_i64(i: i32, buf: Buffer, value: i64) -> () {
    bitcast[&mut[i64]](buf.data)(i) = value;
}

fn @get_array_of_i32(buf: Buffer) -> &mut[i32] {
    bitcast[&mut[i32]](buf.data)
}

fn @get_bool(i: i32, buf: Buffer) -> bool {
    bitcast[&[bool]](buf.data)(i)
}

fn @set_bool(i: i32, buf: Buffer, value: bool) -> () { 
    bitcast[&mut[bool]](buf.data)(i) = value;
}

fn @get_cell_pointer(i: i32, buf: Buffer) -> &Cell {
    bitcast[&[&Cell]](buf.data)(i)
}

fn @set_cell_pointer(i: i32, buf: Buffer, value: &Cell) -> () { 
    bitcast[&mut[&Cell]](buf.data)(i) = value;
}

fn @get_array_of_cell_pointers(buf: Buffer) -> &mut[&Cell] {
    bitcast[&mut[&Cell]](buf.data)
}


fn @get_array_of_cells(buf: Buffer) -> &mut[Cell] {
    bitcast[&mut[Cell]](buf.data)
}

fn @get_array_of_clusters(buf: Buffer) -> &mut[Cluster] {
    bitcast[&mut[Cluster]](buf.data)
}

fn @min_i32(a: i32, b: i32) -> i32 {
    if(a < b) {a} else {b}
}

fn @vector_map(a: Vector3D, f: fn (real_t) -> real_t) -> Vector3D { Vector3D { x: f(a.x), y: f(a.y), z: f(a.z) } }
fn @vector_zip(a: Vector3D, b: Vector3D, f: fn (real_t, real_t) -> real_t) -> Vector3D { Vector3D { x: f(a.x, b.x), y: f(a.y, b.y), z: f(a.z, b.z) } }
fn @vector_add(a: Vector3D, b: Vector3D) -> Vector3D { vector_zip(a, b, @ |x, y| x + y) }
fn @vector_sub(a: Vector3D, b: Vector3D) -> Vector3D { vector_zip(a, b, @ |x, y| x - y) }
fn @vector_mul(a: Vector3D, b: Vector3D) -> Vector3D { vector_zip(a, b, @ |x, y| x * y) }
fn @vector_div(a: Vector3D, b: Vector3D) -> Vector3D { vector_zip(a, b, @ |x, y| x / y) }
fn @vector_dot(a: Vector3D, b: Vector3D) -> real_t { a.x * b.x + a.y * b.y + a.z * b.z }
fn @vector_len2(a: Vector3D) -> real_t { vector_dot(a, a) }
fn @vector_scale(a: real_t, b: Vector3D) -> Vector3D { vector_map(b, @ |x| x * a) }


