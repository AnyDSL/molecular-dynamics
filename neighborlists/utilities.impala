
fn @set_thread_count(thread_count: i32) -> () {
    THREAD_COUNT = thread_count;
}

fn @get_thread_count() -> i32 { THREAD_COUNT }

fn @outer_loop_cpu(lower: i32, upper: i32, body: fn(i32) -> ()) -> () {
    for i in parallel(get_thread_count(), lower, upper) {
        @@body(i);
    }
}

fn @inner_loop_cpu(lower: i32, upper: i32, body: fn(i32) -> ()) -> () {
    range(lower, upper, body)
}

struct Quantity3D {
    x: Buffer,
    y: Buffer,
    z: Buffer
}

fn allocate_quantity(N: i32) -> Quantity3D {
    Quantity3D {
        x: alloc_cpu(N * sizeof[real_t]()),
        y: alloc_cpu(N * sizeof[real_t]()),
        z: alloc_cpu(N * sizeof[real_t]())
    }
}

fn deallocate_quantity(quantity: Quantity3D) -> () {
    release(quantity.x);
    release(quantity.y);
    release(quantity.z);
}


fn @copy_offset_quantity(src: Quantity3D, offset_src: i32, dest: Quantity3D, offset_dest: i32, N: i32) -> () { 
    copy_offset(src.x, offset_src * sizeof[real_t](), dest.x, offset_dest * sizeof[real_t](), N * sizeof[real_t]());
    copy_offset(src.y, offset_src * sizeof[real_t](), dest.y, offset_dest * sizeof[real_t](), N * sizeof[real_t]());
    copy_offset(src.z, offset_src * sizeof[real_t](), dest.z, offset_dest * sizeof[real_t](), N * sizeof[real_t]());
}

fn set_quantity(i: i32, quantity: Quantity3D, vector: Vector) -> () {
    bitcast[&mut[real_t]](quantity.x)(i) = vector.x;
    bitcast[&mut[real_t]](quantity.y)(i) = vector.y;
    bitcast[&mut[real_t]](quantity.z)(i) = vector.z;
}

fn get_vector_from_quantity(i: i32, quantity: Quantity3D) -> Vector {
    Vector {
        x: bitcast[&mut[real_t]](quantity.x)(i), 
        y: bitcast[&mut[real_t]](quantity.y)(i), 
        z: bitcast[&mut[real_t]](quantity.z)(i) 
    }
}

fn get_x_component(i: i32, quantity: Quantity3D) -> real_t {
    bitcast[&mut[real_t]](quantity.x)(i)
}

fn get_y_component(i: i32, quantity: Quantity3D) -> real_t {
    bitcast[&mut[real_t]](quantity.y)(i)
}

fn get_z_component(i: i32, quantity: Quantity3D) -> real_t {
    bitcast[&mut[real_t]](quantity.z)(i)
}

fn copy_quantity(i: i32, j: i32, src: Quantity3D, dest: Quantity3D) -> () {
   bitcast[&mut[real_t]](dest.x)(j) = bitcast[&[real_t]](src.x)(i);  
   bitcast[&mut[real_t]](dest.y)(j) = bitcast[&[real_t]](src.y)(i);  
   bitcast[&mut[real_t]](dest.z)(j) = bitcast[&[real_t]](src.z)(i);  
}

fn swap_quantity(i: i32, j: i32, quantity: Quantity3D) -> () {
   let tmp_x = bitcast[&[real_t]](quantity.x)(i);  
   let tmp_y = bitcast[&[real_t]](quantity.y)(i);  
   let tmp_z = bitcast[&[real_t]](quantity.z)(i);  
   bitcast[&mut[real_t]](quantity.x)(i) = bitcast[&[real_t]](quantity.x)(j);  
   bitcast[&mut[real_t]](quantity.y)(i) = bitcast[&[real_t]](quantity.y)(j);  
   bitcast[&mut[real_t]](quantity.z)(i) = bitcast[&[real_t]](quantity.z)(j);  
   bitcast[&mut[real_t]](quantity.x)(j) = tmp_x;  
   bitcast[&mut[real_t]](quantity.y)(j) = tmp_y;  
   bitcast[&mut[real_t]](quantity.z)(j) = tmp_z;  
}

struct Vector {
    x: real_t,
    y: real_t,
    z: real_t
}

fn @print_vector(vector: Vector) -> () {
    print_f64(vector.x as f64);
    print_string(" ");
    print_f64(vector.y as f64);
    print_string(" ");
    print_f64(vector.z as f64);
}

fn @print_index(index: [i32 * 2]) -> () {
    print_i32(index(0));
    print_string(" ");
    print_i32(index(1));
}

fn @swap_real(i: i32, j: i32, buf: Buffer) -> () {
    let tmp = get_real(i, buf);
    set_real(i, buf, get_real(j, buf));
    set_real(j, buf, tmp);
}


fn @get_real(i: i32, buf: Buffer) -> real_t {
    bitcast[&[real_t]](buf.data)(i)
}

fn @set_real(i: i32, buf: Buffer, value: real_t) -> () { 
    bitcast[&mut[real_t]](buf.data)(i) = value;
}

fn @get_array_of_reals(buf: Buffer) -> &mut[real_t] {
    bitcast[&mut[real_t]](buf.data)
}

fn @get_i32(i: i32, buf: Buffer) -> i32 {
    bitcast[&[i32]](buf.data)(i)
}

fn @set_i32(i: i32, buf: Buffer, value: i32) -> () {
    bitcast[&mut[i32]](buf.data)(i) = value;
}

fn @get_i64(i: i32, buf: Buffer) -> i64 {
    bitcast[&[i64]](buf.data)(i)
}

fn @set_i64(i: i32, buf: Buffer, value: i64) -> () {
    bitcast[&mut[i64]](buf.data)(i) = value;
}

fn @get_array_of_i32(buf: Buffer) -> &mut[i32] {
    bitcast[&mut[i32]](buf.data)
}

fn @get_bool(i: i32, buf: Buffer) -> bool {
    bitcast[&[bool]](buf.data)(i)
}

fn @set_bool(i: i32, buf: Buffer, value: bool) -> () { 
    bitcast[&mut[bool]](buf.data)(i) = value;
}

fn @get_cell_pointer(i: i32, buf: Buffer) -> &Cell {
    bitcast[&[&Cell]](buf.data)(i)
}

fn @set_cell_pointer(i: i32, buf: Buffer, value: &Cell) -> () { 
    bitcast[&mut[&Cell]](buf.data)(i) = value;
}

fn @get_array_of_cell_pointers(buf: Buffer) -> &mut[&Cell] {
    bitcast[&mut[&Cell]](buf.data)
}


fn @get_array_of_cells(buf: Buffer) -> &mut[Cell] {
    bitcast[&mut[Cell]](buf.data)
}

fn @get_array_of_clusters(buf: Buffer) -> &mut[Cluster] {
    bitcast[&mut[Cluster]](buf.data)
}

fn @min_i32(a: i32, b: i32) -> i32 {
    if(a < b) {a} else {b}
}



