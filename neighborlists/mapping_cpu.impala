fn @is_nvvm() -> bool { false }
fn @is_cuda() -> bool { false }
fn @is_opencl() -> bool { false }
fn @is_amdgpu() -> bool { false }
fn @has_ldg() -> bool { false }

fn @shuffle(x: real_t, src_lane: i32, laneOffset: i32) -> real_t {
    rv_shuffle(x as f32, laneOffset) as real_t
}

fn @align(ptr: &[i8], alignment: i32) -> &[i8] {
    rv_align(ptr as &i8, alignment) as &[i8]
}

fn @accelerator_allocate(size: i32) -> Buffer {
    Buffer {
        device: 0,
        data: 0 as &[i8],
        size: 0 as i64
    }
}

fn @accelerator_allocate_3d_arrays(N: i32) -> Array3D {
    null_3d_array()
}

fn @transfer_between_devices(source: Buffer, destination: Buffer, size: i32) -> () {}
fn @transfer_3d_arrays_between_devices(source: Array3D, destination: Array3D, N: i32) -> () {}

fn loop_accelerator(accelerator_grid: AcceleratorGrid, body: fn(i32, i32, i32, i32, i32, &mut[i32]) -> ()) -> () {
    for i in outer_loop_cpu(0, accelerator_grid.total_number_of_clusters) { 
        let cluster_size = get_cluster_size();
        let begin = i * cluster_size;
        let number_of_neighbors = get_number_of_neighbors(i, accelerator_grid);
        let neighborlist_offset = get_neighborlist_offset(i, accelerator_grid);
        let neighborlists = get_neighborlists(accelerator_grid);

        for j in vectorize(cluster_size) {
            body(i, begin, j, number_of_neighbors, neighborlist_offset, neighborlists);
        }
    }
}

fn @get_number_of_neighbors(cluster_index: i32, accelerator_grid: AcceleratorGrid) -> i32 {
    get_i32(cluster_index, accelerator_grid.neighbors_per_cluster_cpu)
}

fn @get_neighborlist_offset(cluster_index: i32, accelerator_grid: AcceleratorGrid) -> i32 {
    get_i32(cluster_index, accelerator_grid.neighborlist_offsets_cpu)
}

fn @get_neighborlists(accelerator_grid: AcceleratorGrid) -> &mut[i32] {
    get_array_of_i32(accelerator_grid.neighborlists_cpu)
}

fn @get_masses(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    get_array_of_reals(accelerator_grid.masses_cpu)
}

fn @get_position(i: i32, accelerator_grid: AcceleratorGrid) -> Vector3D {
    get_vector_from_3d_arrays(i, accelerator_grid.positions_cpu)
}

fn @set_position(i: i32, accelerator_grid: AcceleratorGrid, position: Vector3D) -> () {
    set_3d_arrays(i, accelerator_grid.positions_cpu, position)
}

fn @get_velocity(i: i32, accelerator_grid: AcceleratorGrid) -> Vector3D {
    get_vector_from_3d_arrays(i, accelerator_grid.velocities_cpu)
}

fn @set_velocity(i: i32, accelerator_grid: AcceleratorGrid, velocity: Vector3D) -> () {
    set_3d_arrays(i, accelerator_grid.velocities_cpu, velocity)
}

fn @get_force(i: i32, accelerator_grid: AcceleratorGrid) -> Vector3D {
    get_vector_from_3d_arrays(i, accelerator_grid.forces_cpu)
}

fn @set_force(i: i32, accelerator_grid: AcceleratorGrid, force: Vector3D) -> () {
    set_3d_arrays(i, accelerator_grid.forces_cpu, force)
}

fn @reset_force(i: i32, accelerator_grid: AcceleratorGrid) -> () {
    set_3d_arrays(i, accelerator_grid.forces_cpu, Vector3D {x: 0.0 as real_t, y: 0.0 as real_t, z: 0.0 as real_t});
}

fn @add_to_force(i: i32, accelerator_grid: AcceleratorGrid, dF_x: real_t, dF_y: real_t, dF_z: real_t) -> () {
    let mut force = get_vector_from_3d_arrays(i, accelerator_grid.forces_cpu);
    force.x += dF_x;
    force.y += dF_y;
    force.z += dF_z;
    set_3d_arrays(i, accelerator_grid.forces_cpu, force);
}

fn @get_mask(i: i32, accelerator_grid: AcceleratorGrid) -> mask_t {
    get_mask_t(i, accelerator_grid.interaction_mask_cpu)
}

fn alloc_comm_offsets(comm_offsets: &mut CommOffsets, world_size: i32, neighs: i32, send_capacity: i32, recv_capacity: i32) -> () {
    let null_buf = Buffer {
        device: 0,
        data: 0 as &[i8],
        size: 0 as i64
    };

    *comm_offsets = CommOffsets {
        // Host send data
        send_rank_offsets: null_buf,
        send_starts: null_buf,
        send_sizes: null_buf,
        send_offsets: null_buf,
        send_capacity: 0,
        send_noffsets: 0,

        // Host receive data
        recv_rank_offsets: null_buf,
        recv_starts: null_buf,
        recv_sizes: null_buf,
        recv_offsets: null_buf,
        recv_capacity: 0,
        recv_noffsets: 0,

        // Accelerator send data
        send_buffer_accelerator: null_buf,
        send_rank_offsets_accelerator: null_buf,
        send_starts_accelerator: null_buf,
        send_sizes_accelerator: null_buf,
        send_offsets_accelerator: null_buf,

        // Accelerator receive data
        recv_buffer_accelerator: null_buf,
        recv_rank_offsets_accelerator: null_buf,
        recv_starts_accelerator: null_buf,
        recv_sizes_accelerator: null_buf,
        recv_offsets_accelerator: null_buf,

        // Number of neighbor ranks
        neighs: 0
    };
}

// Build offsets used by scatter and gather kernels on GPU
fn build_comm_offsets(
    world_size: i32,
    rank: i32,
    grid: &Grid,
    accelerator_grid: &AcceleratorGrid,
    comm_offsets: &mut CommOffsets) -> () {}

fn release_comm_offsets(comm_offsets: CommOffsets) -> () {}

fn gather_ghost_layer_cells(comm_buffer: Buffer, comm_offsets: &CommOffsets, accelerator_grid: AcceleratorGrid) -> () {}

fn scatter_ghost_layer_cells(comm_buffer: Buffer, comm_offsets: &CommOffsets, accelerator_grid: AcceleratorGrid) -> () {}

// Pack ghost layer cells in the CPU
fn pack_ghost_layer_cells(
    comm_buffer: Buffer,
    grid: &mut Grid,
    accelerator_grid: AcceleratorGrid,
    begin_x: i32,
    begin_y: i32,
    begin_z: i32,
    end_x: i32,
    end_y: i32,
    end_z: i32) -> () {

    let mut buffer_ptr = 0;

    for cell, index in
        map_over_grid_subdomain(
            grid,
            begin_x, begin_y, begin_z,
            end_x, end_y, end_z,
            range, range, range) {

        let flat_index = flatten_index(index, grid);
        let cell_offsets = get_array_of_i32(accelerator_grid.cell_offsets);
        let offset = cell_offsets(flat_index);
        let nparticles = cell.size;

        if(nparticles > 0) {
            buffer_ptr += copy_3d_arrays_to_buffer(
                accelerator_grid.positions_cpu, offset * sizeof[real_t](),
                comm_buffer, buffer_ptr,
                nparticles * sizeof[real_t]());
        }
    }
}

// Unpack ghost layer cells in the CPU
fn unpack_ghost_layer_cells(
    comm_buffer: Buffer,
    grid: &mut Grid,
    accelerator_grid: AcceleratorGrid,
    begin_x: i32,
    begin_y: i32,
    begin_z: i32,
    end_x: i32,
    end_y: i32,
    end_z: i32) -> () {

    let mut buffer_ptr = 0;

    for cell, index in
        map_over_grid_subdomain(
            grid,
            begin_x, begin_y, begin_z,
            end_x, end_y, end_z,
            range, range, range) {

        let flat_index = flatten_index(index, grid);
        let cell_offsets = get_array_of_i32(accelerator_grid.cell_offsets);
        let offset = cell_offsets(flat_index);
        let nparticles = cell.size;

        if(nparticles > 0) {
            buffer_ptr += copy_buffer_to_3d_arrays(
                comm_buffer, buffer_ptr,
                accelerator_grid.positions_cpu, offset * sizeof[real_t](),
                nparticles * sizeof[real_t]());
        }
    }
}

// Communication buffer sizes
fn get_comm_buffer_sizes(neighs: i32, max_send_particles: i32, max_recv_particles: i32) -> (i32, i32) {
    (max_send_particles * 3, max_recv_particles * 3)
}

// Start positions for communication buffer
fn get_comm_buffer_starts(exchange_rank: i32, comm_offsets: &CommOffsets) -> (i32, i32) { (0, 0) }
