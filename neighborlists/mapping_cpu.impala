fn @is_nvvm() -> bool { false }
fn @is_cuda() -> bool { false }
fn @is_opencl() -> bool { false }
fn @is_amdgpu() -> bool { false }
fn @has_ldg() -> bool { false }

extern "C" {
    fn rv_align(&[i8], i32) -> &[i8];
    fn rv_shuffle(real_t, i32) -> real_t;
}

fn @shuffle(x: real_t, i: i32) -> real_t {
    rv_shuffle(x, i)
}

fn @align(ptr: &[i8], alignment: i32) -> &[i8] {
    rv_align(ptr, alignment)
}

fn @accelerator_allocate(size: i32) -> Buffer {
    Buffer {
        device: 0,
        data: 0 as &[i8]
    }
}

fn @accelerator_allocate_quantity(N: i32) -> Quantity3D {
    let null_buf = Buffer {
        device: 0,
        data: 0 as &[i8]
    };
    Quantity3D {
        x: null_buf, 
        y: null_buf,
        z: null_buf
    }
}

fn @transfer_between_devices(source: Buffer, destination: Buffer, size: i32) -> () {}
fn @transfer_quantity_between_devices(source: Quantity3D, destination: Quantity3D, N: i32) -> () {}



fn loop_accelerator(accelerator_grid: AcceleratorGrid, size: i32, body: fn(i32, i32, i32, i32, i32, i32, &mut[i32]) -> ()) -> () {
    for i in outer_loop_cpu(0, accelerator_grid.total_number_of_clusters) { 
        let cluster_size = get_cluster_size();
        let begin = i * cluster_size;
        let alignment = get_alignment();
        let number_of_neighbors = get_number_of_neighbors(i, accelerator_grid);
        let neighborlist_offset = get_neighborlist_offset(i, accelerator_grid);
        let neighborlists = get_neighborlists(accelerator_grid);
        for j in vectorize(cluster_size, alignment, 0, cluster_size) {
            @@body(i, begin, j, cluster_size, number_of_neighbors, neighborlist_offset, neighborlists);
        }
    }
}
 /*
    for cluster_index in outer_loop_cpu(0, size) {
        let cluster_size = get_cluster_size();
        let begin = cluster_index * cluster_size;
        //for ii in vectorize(get_vector_length(), get_alignment(), 0, cluster_size) {
        for ii in unroll(0, cluster_size) {
            let i = begin + ii; 
            @@body(i, cluster_index, cluster_size)
        } 
    }
}*/

fn @get_number_of_neighbors(cluster_index: i32, accelerator_grid: AcceleratorGrid) -> i32 {
    get_i32(cluster_index, accelerator_grid.neighbors_per_cluster_cpu)
}

fn @get_neighborlist_offset(cluster_index: i32, accelerator_grid: AcceleratorGrid) -> i32 {
    get_i32(cluster_index, accelerator_grid.neighborlist_offsets_cpu)
}

fn @get_neighborlists(accelerator_grid: AcceleratorGrid) -> &mut[i32] {
    get_array_of_i32(accelerator_grid.neighborlists_cpu)
}

fn @get_masses(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    get_array_of_reals(accelerator_grid.masses_cpu)
}

fn @get_position(i: i32, accelerator_grid: AcceleratorGrid) -> Vector {
    get_vector_from_quantity(i, accelerator_grid.positions_cpu)
}

fn @set_position(i: i32, accelerator_grid: AcceleratorGrid, position: Vector) -> () {
    set_quantity(i, accelerator_grid.positions_cpu, position)
}

fn @get_velocity(i: i32, accelerator_grid: AcceleratorGrid) -> Vector {
    get_vector_from_quantity(i, accelerator_grid.velocities_cpu)
}

fn @set_velocity(i: i32, accelerator_grid: AcceleratorGrid, velocity: Vector) -> () {
    set_quantity(i, accelerator_grid.velocities_cpu, velocity)
}

fn @get_force(i: i32, accelerator_grid: AcceleratorGrid) -> Vector {
    get_vector_from_quantity(i, accelerator_grid.forces_cpu)
}

fn @set_force(i: i32, accelerator_grid: AcceleratorGrid, force: Vector) -> () {
    set_quantity(i, accelerator_grid.forces_cpu, force)
}



fn @reset_force(i: i32, accelerator_grid: AcceleratorGrid) -> () {
    set_quantity(i, accelerator_grid.forces_cpu, Vector {x: 0.0 as real_t, y: 0.0 as real_t, z: 0.0 as real_t});
}

fn @add_to_force(i: i32, accelerator_grid: AcceleratorGrid, dF_x: real_t, dF_y: real_t, dF_z: real_t) -> () {
    let mut force = get_vector_from_quantity(i, accelerator_grid.forces_cpu);
    force.x += dF_x;
    force.y += dF_y;
    force.z += dF_z;
    set_quantity(i, accelerator_grid.forces_cpu, force);
}

fn @get_mask_value(i: i32, accelerator_grid: AcceleratorGrid) -> bool {
    get_bool(i, accelerator_grid.interaction_mask_cpu)
}
