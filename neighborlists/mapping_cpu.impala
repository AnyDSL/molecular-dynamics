fn @is_nvvm() -> bool { false }
fn @is_cuda() -> bool { false }
fn @is_opencl() -> bool { false }
fn @is_amdgpu() -> bool { false }
fn @has_ldg() -> bool { false }

extern "C" {
    fn rv_align(&[i8], i32) -> &[i8];
    fn rv_shuffle(real_t, i32) -> real_t;
}

fn @shuffle(x: real_t, srcLane: i32, laneOffset: i32) -> real_t {
    rv_shuffle(x, laneOffset)
}

fn @align(ptr: &[i8], alignment: i32) -> &[i8] {
    rv_align(ptr, alignment)
}

fn @accelerator_allocate(size: i32) -> Buffer {
    Buffer {
        device: 0,
        data: 0 as &[i8],
        size: 0 as i64
    }
}

fn @accelerator_allocate_struct_of_arrays(N: i32) -> StructOfArrays3D {
    let null_buf = Buffer {
        device: 0,
        data: 0 as &[i8],
        size: 0 as i64
    };
    StructOfArrays3D {
        x: null_buf, 
        y: null_buf,
        z: null_buf
    }
}

fn @transfer_between_devices(source: Buffer, destination: Buffer, size: i32) -> () {}
fn @transfer_struct_of_arrays_between_devices(source: StructOfArrays3D, destination: StructOfArrays3D, N: i32) -> () {}



fn loop_accelerator(accelerator_grid: AcceleratorGrid, size: i32, body: fn(i32, i32, i32, i32, i32, &mut[i32]) -> ()) -> () {
    for i in outer_loop_cpu(0, accelerator_grid.total_number_of_clusters) { 
        let cluster_size = get_cluster_size();
        let begin = i * cluster_size;
        let alignment = get_alignment();
        let number_of_neighbors = get_number_of_neighbors(i, accelerator_grid);
        let neighborlist_offset = get_neighborlist_offset(i, accelerator_grid);
        let neighborlists = get_neighborlists(accelerator_grid);

        for j in vectorize(cluster_size) {             
            body(i, begin, j, number_of_neighbors, neighborlist_offset, neighborlists);
        }
    }
}

fn @get_number_of_neighbors(cluster_index: i32, accelerator_grid: AcceleratorGrid) -> i32 {
    get_i32(cluster_index, accelerator_grid.neighbors_per_cluster_cpu)
}

fn @get_neighborlist_offset(cluster_index: i32, accelerator_grid: AcceleratorGrid) -> i32 {
    get_i32(cluster_index, accelerator_grid.neighborlist_offsets_cpu)
}

fn @get_neighborlists(accelerator_grid: AcceleratorGrid) -> &mut[i32] {
    get_array_of_i32(accelerator_grid.neighborlists_cpu)
}

fn @get_masses(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    get_array_of_reals(accelerator_grid.masses_cpu)
}

fn @get_position(i: i32, accelerator_grid: AcceleratorGrid) -> Vector3D {
    get_vector_from_struct_of_arrays(i, accelerator_grid.positions_cpu)
}

fn @set_position(i: i32, accelerator_grid: AcceleratorGrid, position: Vector3D) -> () {
    set_struct_of_arrays(i, accelerator_grid.positions_cpu, position)
}

fn @get_velocity(i: i32, accelerator_grid: AcceleratorGrid) -> Vector3D {
    get_vector_from_struct_of_arrays(i, accelerator_grid.velocities_cpu)
}

fn @set_velocity(i: i32, accelerator_grid: AcceleratorGrid, velocity: Vector3D) -> () {
    set_struct_of_arrays(i, accelerator_grid.velocities_cpu, velocity)
}

fn @get_force(i: i32, accelerator_grid: AcceleratorGrid) -> Vector3D {
    get_vector_from_struct_of_arrays(i, accelerator_grid.forces_cpu)
}

fn @set_force(i: i32, accelerator_grid: AcceleratorGrid, force: Vector3D) -> () {
    set_struct_of_arrays(i, accelerator_grid.forces_cpu, force)
}

fn @reset_force(i: i32, accelerator_grid: AcceleratorGrid) -> () {
    set_struct_of_arrays(i, accelerator_grid.forces_cpu, Vector3D {x: 0.0 as real_t, y: 0.0 as real_t, z: 0.0 as real_t});
}

fn @add_to_force(i: i32, accelerator_grid: AcceleratorGrid, dF_x: real_t, dF_y: real_t, dF_z: real_t) -> () {
    let mut force = get_vector_from_struct_of_arrays(i, accelerator_grid.forces_cpu);
    force.x += dF_x;
    force.y += dF_y;
    force.z += dF_z;
    set_struct_of_arrays(i, accelerator_grid.forces_cpu, force);
}

fn @get_mask_value(i: i32, accelerator_grid: AcceleratorGrid) -> bool {
    get_bool(i, accelerator_grid.interaction_mask_cpu)
}

fn @get_forces_x(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    bitcast[&mut[real_t]](align(accelerator_grid.forces_cpu.x.data, get_alignment()))
}
fn @get_forces_y(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    bitcast[&mut[real_t]](align(accelerator_grid.forces_cpu.y.data, get_alignment()))
}
fn @get_forces_z(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    bitcast[&mut[real_t]](align(accelerator_grid.forces_cpu.z.data, get_alignment()))
}
fn @get_positions_x(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    bitcast[&mut[real_t]](align(accelerator_grid.positions_cpu.x.data, get_alignment()))
}
fn @get_positions_y(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    bitcast[&mut[real_t]](align(accelerator_grid.positions_cpu.y.data, get_alignment()))
}
fn @get_positions_z(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    bitcast[&mut[real_t]](align(accelerator_grid.positions_cpu.z.data, get_alignment()))
}
fn @get_velocities_x(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    bitcast[&mut[real_t]](align(accelerator_grid.velocities_cpu.x.data, get_alignment()))
}
fn @get_velocities_y(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    bitcast[&mut[real_t]](align(accelerator_grid.velocities_cpu.y.data, get_alignment()))
}
fn @get_velocities_z(accelerator_grid: AcceleratorGrid) -> &mut[real_t] {
    bitcast[&mut[real_t]](align(accelerator_grid.velocities_cpu.z.data, get_alignment()))
}

