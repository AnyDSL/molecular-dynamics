fn redistribute_particles(grid: &mut Grid, allocate: fn(i32) -> Buffer) -> () {
    let cells = get_array_of_cells(grid.cells);
    for cell, cell_index in map_over_grid(grid, range, range, range) {
        let mut i = 0;
        while(i < cell.size) {
            let position = get_vector_from_3d_arrays(i, cell.positions);
            if(is_within_domain(position, grid)) {
                //print_string("is in domain\n");
                let new_cell_index = compute_cell_position(position, grid);
                /*print_string("Old cell index: ");
                print_i32(cell_index(0));
                print_string(" ");
                print_i32(cell_index(1));
                print_string(" ");
                print_i32(cell_index(2));
                print_string("\nNew cell index: ");
                print_i32(new_cell_index(0));
                print_string(" ");
                print_i32(new_cell_index(1));
                print_string(" ");
                print_i32(new_cell_index(2));
                print_string("\ni: ");
                print_i32(i);
                print_string("\n");
                print_string("ny: ");
                print_i32(grid.ny);
                print_string("\n");*/
                if(new_cell_index(0) != cell_index(0) || new_cell_index(1) != cell_index(1) || new_cell_index(2) != cell_index(2)) {
                    //print_string("move particle\n");
                    /*if(flatten_index(new_cell_index, grid) == flatten_index(cell_index, grid)) {
                        print_string("flattened indices are identical!\n");
                    }
                    print_string("move_particle from ");
                    print_string("<");
                    print_i32(cell_index(0));
                    print_string(", ");
                    print_i32(cell_index(1));
                    print_string(", ");
                    print_i32(cell_index(2));
                    print_string("> to <");
                    print_i32(new_cell_index(0));
                    print_string(", ");
                    print_i32(new_cell_index(1));
                    print_string(", ");
                    print_i32(new_cell_index(2));
                    print_string(">\nflatten_index = ");
                    print_i32(flatten_index(new_cell_index, grid));
                    print_string("\n");
                    print_flush();
                    */
                    move_particle(i, cell, &mut cells(flatten_index(new_cell_index, grid)), allocate);
                }
                else {
                    ++i;
                }
            }
            else {
                /*print_string("remove particle\n");
                let position = get_vector(i, cell.positions);
                print_string("Position: ");
                print_vector(position);
                print_string("\n");*/
                //remove_particle(i, cell);
                ++i;
            }
            /*print_string("i: ");
            print_i32(i);
            print_string("\n");
            print_string("size: ");
            print_i32(cell.size);
            print_string("\n");*/
        }
    }
}
