static mut grid_ : Grid;
static mut accelerator_grid_ : AcceleratorGrid;
static mut world_size : i32;
static mut world_rank : i32;
extern 
fn md_set_thread_count(thread_count: i32) -> () {
    set_thread_count(thread_count);
}
extern 
fn md_initialize_grid(
  masses: &[real_t], positions: &[Vector3D], velocities: &[Vector3D], 
  nparticles: i32, min: &[real_t], max: &[real_t], cell_spacing: real_t,
  cell_capacity: i32) -> i32 {
    let aabb = AABB {
        min: [min(0), min(1), min(2)],
        max: [max(0), max(1), max(2)],
    };
    let cluster_size = get_cluster_size();
    let rank_aabb = mpi_get_rank_bounding_box(world_size, world_rank, cell_spacing, aabb);

    grid_ = allocate_grid(rank_aabb, cell_spacing, cell_capacity, cluster_size, alloc_cpu);
    initialize_grid(masses, positions, velocities, nparticles, &mut grid_, alloc_cpu);

    /*
    if(world_rank == 0) {
      for i in range(0, nparticles) {
        print_f64(positions(i).x);
        print_string(", ");
        print_f64(positions(i).y);
        print_string(", ");
        print_f64(positions(i).z);
        print_string("\n");
      }

      for cell, index in map_over_grid(grid_, range, range, range) {
        if(cell.size > 0) {
          print_string("<");
          print_i32(index(0));
          print_string(", ");
          print_i32(index(1));
          print_string(", ");
          print_i32(index(2));
          print_string(">: ");
          print_i32(cell.size);

          print_string(" (");

          for i in range(0, cell.size) {
            print_f64(get_z_component(i, cell.positions));
            print_string(", ");
          }

          print_string(")\n");
        }
      }
    }
    */

    let capacity = nparticles / 4 + 128;
    accelerator_grid_ = allocate_accelerator_grid(grid_.nx, grid_.ny, grid_.nz, capacity, cluster_size, capacity * 64); 

    grid_.nparticles
}
extern fn md_copy_data_to_accelerator() -> () {
    copy_to_accelerator(grid_, &mut accelerator_grid_);
}
extern fn md_copy_data_from_accelerator() -> () {
    copy_from_accelerator(accelerator_grid_, grid_);
}
extern
fn md_deallocate_grid() -> () {
    deallocate_grid(grid_);
    deallocate_accelerator_grid(accelerator_grid_);
}
extern 
fn md_integration(dt: real_t) -> () {
    accelerator_integration(accelerator_grid_, dt);
}

extern
fn md_write_grid_data_to_arrays(masses: &mut[real_t], positions: &mut [Vector3D], velocities: &mut [Vector3D], forces: &mut [Vector3D], size: i32) -> i32 {
    write_grid_data_to_arrays(masses, positions, velocities, forces, size, &grid_)
}

extern
fn md_redistribute_particles() -> () {
    redistribute_particles(grid_, alloc_cpu);
}

extern 
fn md_initialize_clusters(neighbor_list_capacity: i32) -> () {
   grid_initialize_clusters(grid_, neighbor_list_capacity, alloc_cpu, outer_loop_cpu, middle_loop_cpu, inner_loop_cpu);
}

extern
fn md_assemble_neighbor_lists(cutoff_distance: real_t) -> () {
    grid_assemble_neighbor_lists(&grid_, cutoff_distance, alloc_cpu, outer_loop_cpu, middle_loop_cpu, inner_loop_cpu);
}

extern
fn md_compute_forces(cutoff_distance: real_t, epsilon: real_t, sigma: real_t) -> () {
    let potential = create_potential(sigma, epsilon);
    accelerator_compute_forces(accelerator_grid_, cutoff_distance*cutoff_distance, potential);
}

extern
fn md_compute_total_kinetic_energy() -> real_t {
    // TODO fix this function
   //compute_total_kinetic_energy(grid_, outer_loop_cpu, inner_loop_cpu)
   0.0
}

extern
fn md_print_grid() -> () {
    print_grid(grid_);
}

extern
fn md_mpi_initialize() -> () {
  mpi_initialize(&mut world_size, &mut world_rank);
}

extern
fn md_mpi_finalize() -> () {
  mpi_finalize();
}

extern
fn md_get_comm_time_steps() -> i32 {
  get_comm_time_steps()
}

extern
fn md_synchronize_ghost_zone() -> () {
  mpi_synchronize_ghost_zone(&mut grid_, accelerator_grid_, world_size, world_rank);
}
