static mut grid_ : Grid;
static mut accelerator_grid_ : AcceleratorGrid;
static mut comm_offsets_ : CommOffsets;
static mut world_size : i32;
static mut world_rank : i32;

extern fn md_set_thread_count(thread_count: i32) -> () {
    set_thread_count(thread_count);
}

extern fn md_initialize_grid(
  masses: &[real_t], positions: &[Vector3D], velocities: &[Vector3D], 
  nparticles: i32, min: &[real_t], max: &[real_t], rank_min: &[real_t],
  rank_max: &[real_t], cell_spacing: real_t, cell_capacity: i32,
  neighbor_list_capacity: i32) -> i32 {

    let aabb = AABB {
        xmin: min(0),
        xmax: max(0),
        ymin: min(1),
        ymax: max(1),
        zmin: min(2),
        zmax: max(2)
    };

    let rank_aabb = AABB {
        xmin: rank_min(0),
        xmax: rank_max(0),
        ymin: rank_min(1),
        ymax: rank_max(1),
        zmin: rank_min(2),
        zmax: rank_max(2)
    };

    let cluster_size = get_cluster_size();
    //let rank_aabb = get_node_bounding_box(
    //  world_size, world_rank, cell_spacing, aabb);

    /*
    print_i32(world_rank);
    print_string("> aabb.min = {");
    print_f64(rank_aabb.xmin);
    print_string(", ");
    print_f64(rank_aabb.ymin);
    print_string(", ");
    print_f64(rank_aabb.zmin);
    print_string("}\n");

    print_i32(world_rank);
    print_string("> aabb.max = {");
    print_f64(rank_aabb.xmax);
    print_string(", ");
    print_f64(rank_aabb.ymax);
    print_string(", ");
    print_f64(rank_aabb.zmax);
    print_string("}\n");
    */

    print_string("allocate_grid\n");
    print_flush();
    grid_ = allocate_grid(rank_aabb, cell_spacing, cell_capacity, neighbor_list_capacity, cluster_size, alloc_unaligned_cpu);

    print_string("allocate_accelerator_grid\n");
    print_flush();
    accelerator_grid_ = allocate_accelerator_grid(grid_.nx, grid_.ny, grid_.nz, cluster_size, cell_capacity, neighbor_list_capacity);

    /*
    print_i32(world_rank);
    print_string("> nx, ny, nz = ");
    print_i32(grid_.nx);
    print_string(" ");
    print_i32(grid_.ny);
    print_string(" ");
    print_i32(grid_.nz);
    print_string("\n");
    */

    if store_particles_once() {
        print_string("initialize_accelerator_grid\n");
        print_flush();
        initialize_accelerator_grid(masses, positions, velocities, nparticles, &mut grid_, &mut accelerator_grid_, alloc_cpu);
    } else {
        print_string("initialize_grid\n");
        print_flush();
        initialize_grid(masses, positions, velocities, nparticles, &mut grid_, alloc_unaligned_cpu);
    }

    print_string("initialize_grid_comm\n");
    print_flush();
    initialize_grid_comm(grid_, accelerator_grid_, &mut comm_offsets_, world_size, world_rank);

    grid_.nparticles
}

extern fn md_get_node_bounding_box(
    cell_spacing: real_t, min: &[real_t], max: &[real_t], rank_min: &mut[real_t * 3], rank_max: &mut[real_t * 3]) -> () {

    let aabb = AABB {
        xmin: min(0),
        xmax: max(0),
        ymin: min(1),
        ymax: max(1),
        zmin: min(2),
        zmax: max(2)
    };

    let rank_aabb = get_node_bounding_box(world_size, world_rank, cell_spacing, aabb);

    rank_min(0) = rank_aabb.xmin;
    rank_min(1) = rank_aabb.ymin;
    rank_min(2) = rank_aabb.zmin;

    rank_max(0) = rank_aabb.xmax;
    rank_max(1) = rank_aabb.ymax;
    rank_max(2) = rank_aabb.zmax;
}

extern fn md_copy_data_to_accelerator() -> () {
    if !store_particles_once() {
        transfer_grid_to_accelerator_buffers(grid_, &mut accelerator_grid_);
    }

    copy_to_accelerator(accelerator_grid_);

    // Build communication offsets (GPU only)
    build_comm_offsets(world_size, world_rank, grid_, accelerator_grid_, &mut comm_offsets_);
}

extern fn md_copy_data_from_accelerator() -> () {
    if !store_particles_once() {
        transfer_accelerator_buffers_to_grid(accelerator_grid_, grid_);
    }

    copy_from_accelerator(accelerator_grid_);
}

extern fn md_deallocate_grid() -> () {
    deallocate_grid(grid_);
    deallocate_accelerator_grid(accelerator_grid_);
}

extern fn md_integration(dt: real_t) -> () {
    accelerator_integration(accelerator_grid_, dt);
}

extern fn md_write_grid_data_to_arrays(
    masses: &mut[real_t], positions: &mut [Vector3D], velocities: &mut [Vector3D], forces: &mut [Vector3D]) -> i32 {

    write_accelerator_grid_data_to_arrays(masses, positions, velocities, forces, &accelerator_grid_)
}

extern fn md_redistribute_particles() -> () {
    if store_particles_once() {
        redistribute_particles_accelerator(grid_, &mut accelerator_grid_, alloc_cpu);
    } else {
        redistribute_particles(&mut grid_, alloc_unaligned_cpu);
    }
}

extern fn md_exchange_ghost_layer() -> () {
    exchange_ghost_layer_particles(&mut grid_, &mut accelerator_grid_, world_size, world_rank);
}

extern fn md_initialize_clusters() -> () {
    grid_initialize_clusters(grid_, outer_loop_cpu, middle_loop_cpu, inner_loop_cpu);
}

extern fn md_assemble_neighbor_lists(cutoff_distance: real_t) -> () {
    if store_particles_once() {
        accelerator_grid_assemble_neighbor_lists(
            grid_, &mut accelerator_grid_, cutoff_distance, alloc_cpu, assemble_particles_full_neighbor_list_accelerator);
    } else {
        if(get_cluster_size() == 1) {
            grid_assemble_neighbor_lists(
                &grid_, cutoff_distance, alloc_unaligned_cpu, outer_loop_cpu, middle_loop_cpu, inner_loop_cpu,
                assemble_particles_full_neighbor_list);
        } else {
            grid_assemble_neighbor_lists(
                &grid_, cutoff_distance, alloc_unaligned_cpu, outer_loop_cpu, middle_loop_cpu, inner_loop_cpu,
                assemble_clusters_full_neighbor_list);
        }
    }
}

extern fn md_compute_forces(cutoff_distance: real_t, epsilon: real_t, sigma: real_t) -> () {
    let potential = create_potential(sigma, epsilon);

    if(get_cluster_size() == 1) {
        accelerator_compute_particle_forces(accelerator_grid_, cutoff_distance*cutoff_distance, potential);
    } else {
        accelerator_compute_cluster_forces(accelerator_grid_, cutoff_distance*cutoff_distance, potential);
    }
}

extern fn md_compute_total_kinetic_energy() -> real_t {
    // TODO fix this function
   //compute_total_kinetic_energy(grid_, outer_loop_cpu, inner_loop_cpu)
   0.0 as real_t
}

extern fn md_print_grid() -> () {
    print_grid(grid_);
}

extern fn md_mpi_initialize() -> () {
    mpi_initialize(&mut world_size, &mut world_rank);
}

extern fn md_mpi_finalize() -> () {
    mpi_finalize();
}

extern fn md_get_sync_timesteps() -> i32 {
    get_sync_timesteps()
}

extern fn md_synchronize_ghost_layer() -> () {
    synchronize_ghost_layer_cells(&mut grid_, accelerator_grid_, comm_offsets_, world_size, world_rank);
}

extern fn md_get_world_rank() -> i32 {
    world_rank
}

extern fn md_get_number_of_particles() -> i32 {
    grid_.nparticles
}

extern fn md_report_memory_allocation() -> () {
    report_memory_allocation();
}
