fn @is_x86() -> bool { false }
fn @is_sse() -> bool { false }
fn @is_avx() -> bool { false }
fn @is_avx2() -> bool { false }

fn @get_alignment() -> i32 {4}

fn @nvvm_shfldown_i32(var: i32, delta: i32, width: i32) -> i32 {
    let mut res: i32;
    let warp_size = 32; 
    let c = ((warp_size - width) << 8) | 0x1f;
    asm("shfl.down.b32 $0, $1, $2, $3;" : "=r"(res) : "r"(var), "r"(delta as u32), "r"(c));
    res 
}

fn @nvvm_shfldown_f64(var: f64, delta: i32, width: i32) -> f64 {
    let mut res = var;
    let mut lo: u32;
    let mut hi: u32;
    asm("mov.b64 { $0, $1 }, $2;" : "=r"(lo), "=r"(hi) : "d"(res));
    hi = nvvm_shfldown_i32(hi as i32, delta, width) as u32;
    lo = nvvm_shfldown_i32(lo as i32, delta, width) as u32;
    asm("mov.b64 $0, { $1, $2 };" : "=d"(res) : "r"(lo), "r"(hi));
    res 
}

fn @nvvm_shfl_i32(var: i32, srcLane: i32, width: i32) -> i32 {
    let mut res: i32;
    let warp_size = 32; 
    let c = ((warp_size - width) << 8) | 0x1f;
	  asm("shfl.idx.b32 $0, $1, $2, $3;" : "=r"(res) : "r"(var), "r"(srcLane as u32), "r"(c));
    res 
}

fn @nvvm_shfl_f64(var: f64, srcLane: i32, width: i32) -> f64 {
    let mut res = var;
    let mut lo: u32;
    let mut hi: u32;
    asm("mov.b64 { $0, $1 }, $2;" : "=r"(lo), "=r"(hi) : "d"(res));
    hi = nvvm_shfl_i32(hi as i32, srcLane, width) as u32;
    lo = nvvm_shfl_i32(lo as i32, srcLane, width) as u32;
    asm("mov.b64 $0, { $1, $2 };" : "=d"(res) : "r"(lo), "r"(hi));
    res 
}


fn @shuffle(x: real_t, srcLane: i32, laneOffset: i32) -> real_t {
	  nvvm_shfl_f64(x, srcLane, get_cluster_size()) 
}

fn @align(ptr: &[i8], alignment: i32) -> &[i8] {
    ptr
}

fn @accelerator_allocate(size: i32) -> Buffer {
    let acc = accelerator(device_id);
    acc.alloc(size)
}

fn @accelerator_allocate_3d_arrays(size: i32) -> Array3D {
    let acc = accelerator(device_id);
    allocate_3d_arrays(size, acc.alloc)
}

fn @transfer_between_devices(source: Buffer, destination: Buffer, size: i32) -> () {
    //copy(source, destination, size);
    copy(source, destination);
}

fn @transfer_3d_arrays_between_devices(source: Array3D, destination: Array3D, N: i32) -> () {
    _transfer_3d_arrays_between_devices(source, destination, N);
}

fn @get_cluster_size() -> i32 {32}

fn loop_accelerator(accelerator_grid: AcceleratorGrid, body: fn(i32, i32, i32, i32, i32, &mut[1][i32]) -> ()) -> () {
    let cluster_size = get_cluster_size();
    let acc = accelerator(device_id);
    let grid = (accelerator_grid.total_number_of_clusters, 1, 1);
    let block = (cluster_size, 1, 1);

    for work_item in acc.exec(grid, block) {
        let i = work_item.bidx();
        let j = work_item.tidx();
        let cluster_size = work_item.bdimx();
        let begin = i * cluster_size;
        let number_of_neighbors = get_number_of_neighbors(i, accelerator_grid);
        let neighborlist_offset = get_neighborlist_offset(i, accelerator_grid);
        let neighborlists = get_neighborlists(accelerator_grid);

        @@body(i, begin, j, number_of_neighbors, neighborlist_offset, neighborlists);
    }

    acc.sync();
}

fn @get_number_of_neighbors(cluster_index: i32, accelerator_grid: AcceleratorGrid) -> i32 {
    get_i32_accelerator(cluster_index, accelerator_grid.neighbors_per_cluster_accelerator)
}

fn @get_neighborlist_offset(cluster_index: i32, accelerator_grid: AcceleratorGrid) -> i32 {
    get_i32_accelerator(cluster_index, accelerator_grid.neighborlist_offsets_accelerator)
}

fn @get_neighborlists(accelerator_grid: AcceleratorGrid) -> &mut[1][i32] {
    get_array_of_i32_accelerator(accelerator_grid.neighborlists_accelerator)
}

fn @get_masses(accelerator_grid: AcceleratorGrid) -> &mut[1][real_t] {
    get_array_of_reals_accelerator(accelerator_grid.masses_accelerator)
}

fn @get_position(i: i32, accelerator_grid: AcceleratorGrid) -> Vector3D {
    get_vector_from_3d_arrays_accelerator(i, accelerator_grid.positions_accelerator)
}

fn @set_position(i: i32, accelerator_grid: AcceleratorGrid, position: Vector3D) -> () {
    set_3d_arrays_accelerator(i, accelerator_grid.positions_accelerator, position)
}

fn @get_velocity(i: i32, accelerator_grid: AcceleratorGrid) -> Vector3D {
    get_vector_from_3d_arrays_accelerator(i, accelerator_grid.velocities_accelerator)
}

fn @set_velocity(i: i32, accelerator_grid: AcceleratorGrid, velocity: Vector3D) -> () {
    set_3d_arrays_accelerator(i, accelerator_grid.velocities_accelerator, velocity)
}

fn @get_force(i: i32, accelerator_grid: AcceleratorGrid) -> Vector3D {
    get_vector_from_3d_arrays_accelerator(i, accelerator_grid.forces_accelerator)
}

fn @set_force(i: i32, accelerator_grid: AcceleratorGrid, force: Vector3D) -> () {
    set_3d_arrays_accelerator(i, accelerator_grid.forces_accelerator, force)
}

fn @reset_force(i: i32, accelerator_grid: AcceleratorGrid) -> () {
    set_3d_arrays_accelerator(i, accelerator_grid.forces_accelerator, Vector3D {x: 0.0 as real_t, y: 0.0 as real_t, z: 0.0 as real_t});
}

fn @add_to_force(i: i32, accelerator_grid: AcceleratorGrid, dF_x: real_t, dF_y: real_t, dF_z: real_t) -> () {
    let mut force = get_vector_from_3d_arrays_accelerator(i, accelerator_grid.forces_accelerator);
    force.x += dF_x;
    force.y += dF_y;
    force.z += dF_z;
    set_3d_arrays_accelerator(i, accelerator_grid.forces_accelerator, force);
}

fn @get_mask_value(i: i32, accelerator_grid: AcceleratorGrid) -> bool {
    get_bool_accelerator(i, accelerator_grid.interaction_mask_accelerator)
}

fn alloc_comm_offsets(world_size: i32, neighs: i32, send_capacity: i32, recv_capacity: i32) -> CommOffsets {
    let null_buf = Buffer {
        device: 0,
        data: 0 as &[i8],
        size: 0 as i64
    };

    CommOffsets {
        // Host send data
        send_rank_offsets: alloc_unaligned_cpu(world_size * sizeof[i32]()),
        send_starts: alloc_unaligned_cpu(send_capacity * sizeof[i32]()),
        send_sizes: alloc_unaligned_cpu(send_capacity * sizeof[i32]()),
        send_offsets: alloc_unaligned_cpu(send_capacity * sizeof[i32]()),
        send_capacity: send_capacity,
        send_noffsets: 0,

        // Host receive data
        recv_rank_offsets: alloc_unaligned_cpu(world_size * sizeof[i32]()),
        recv_starts: alloc_unaligned_cpu(recv_capacity * sizeof[i32]()),
        recv_sizes: alloc_unaligned_cpu(recv_capacity * sizeof[i32]()),
        recv_offsets: alloc_unaligned_cpu(recv_capacity * sizeof[i32]()),
        recv_capacity: recv_capacity,
        recv_noffsets: 0,

        // Accelerator send data
        send_buffer_accelerator: null_buf,
        send_rank_offsets_accelerator: accelerator_allocate(world_size * sizeof[i32]()),
        send_starts_accelerator: accelerator_allocate(send_capacity * sizeof[i32]()),
        send_sizes_accelerator: accelerator_allocate(send_capacity * sizeof[i32]()),
        send_offsets_accelerator: accelerator_allocate(send_capacity * sizeof[i32]()),

        // Accelerator receive data
        recv_buffer_accelerator: null_buf,
        recv_rank_offsets_accelerator: accelerator_allocate(world_size * sizeof[i32]()),
        recv_starts_accelerator: accelerator_allocate(recv_capacity * sizeof[i32]()),
        recv_sizes_accelerator: accelerator_allocate(recv_capacity * sizeof[i32]()),
        recv_offsets_accelerator: accelerator_allocate(recv_capacity * sizeof[i32]()),

        // Number of neighbor ranks
        neighs: neighs
    }
}

fn release_comm_offsets(comm_offsets: CommOffsets) -> () {
    if comm_offsets.send_capacity > 0 {
        release(comm_offsets.send_buffer_accelerator);
        release(comm_offsets.send_rank_offsets);
        release(comm_offsets.send_starts);
        release(comm_offsets.send_sizes);
        release(comm_offsets.send_offsets);
        release(comm_offsets.send_rank_offsets_accelerator);
        release(comm_offsets.send_starts_accelerator);
        release(comm_offsets.send_sizes_accelerator);
        release(comm_offsets.send_offsets_accelerator);
    }

    if comm_offsets.recv_capacity > 0 {
        release(comm_offsets.recv_buffer_accelerator);
        release(comm_offsets.recv_rank_offsets);
        release(comm_offsets.recv_starts);
        release(comm_offsets.recv_sizes);
        release(comm_offsets.recv_offsets);
        release(comm_offsets.recv_rank_offsets_accelerator);
        release(comm_offsets.recv_starts_accelerator);
        release(comm_offsets.recv_sizes_accelerator);
        release(comm_offsets.recv_offsets_accelerator);
    }
}

fn build_comm_offsets_accelerator(grid: &Grid, accelerator_grid: &AcceleratorGrid, comm_offsets: &mut CommOffsets) -> () {
    build_comm_offsets(grid, accelerator_grid, comm_offsets);
}

fn @get_comm_send_starts_accelerator(index: i32, comm_offsets: &CommOffsets) -> i32 {
    get_i32_accelerator(index, comm_offsets.send_starts_accelerator)
}

fn @get_comm_send_offsets_accelerator(index: i32, comm_offsets: &CommOffsets) -> i32 {
    get_i32_accelerator(index, comm_offsets.send_offsets_accelerator)
}

fn @get_comm_send_sizes_accelerator(index: i32, comm_offsets: &CommOffsets) -> i32 {
    get_i32_accelerator(index, comm_offsets.send_sizes_accelerator)
}

fn @get_comm_recv_starts_accelerator(index: i32, comm_offsets: &CommOffsets) -> i32 {
    get_i32_accelerator(index, comm_offsets.recv_starts_accelerator)
}

fn @get_comm_recv_offsets_accelerator(index: i32, comm_offsets: &CommOffsets) -> i32 {
    get_i32_accelerator(index, comm_offsets.recv_offsets_accelerator)
}

fn @get_comm_recv_sizes_accelerator(index: i32, comm_offsets: &CommOffsets) -> i32 {
    get_i32_accelerator(index, comm_offsets.recv_sizes_accelerator)
}

fn gather_ghost_layer_cells(comm_buffer: Buffer, comm_offsets: &CommOffsets, accelerator_grid: AcceleratorGrid) -> () {
    let acc = accelerator(device_id);
    let grid = (comm_offsets.send_noffsets * 64, 1, 1);
    let block = (64, 1, 1);
    let buffer_gpu = comm_offsets.send_buffer_accelerator;

    if comm_offsets.send_noffsets > 0 {
        for work_item in acc.exec(grid, block) {
            let th_idx = work_item.bidx() * work_item.bdimx() + work_item.tidx();

            if th_idx < comm_offsets.send_noffsets {
                let start = get_comm_send_starts_accelerator(th_idx, comm_offsets);
                let offset = get_comm_send_offsets_accelerator(th_idx, comm_offsets);
                let size = get_comm_send_sizes_accelerator(th_idx, comm_offsets);

                for i in range(0, size) {
                    let linear_idx = i * 3;
                    let pos = get_position(offset + i, accelerator_grid);

                    set_real_accelerator(start + linear_idx,     buffer_gpu, pos.x);
                    set_real_accelerator(start + linear_idx + 1, buffer_gpu, pos.y);
                    set_real_accelerator(start + linear_idx + 2, buffer_gpu, pos.z);
                }
            }
        }

        acc.sync();
        copy(buffer_gpu, comm_buffer);
    }
}

fn scatter_ghost_layer_cells(comm_buffer: Buffer, comm_offsets: &CommOffsets, accelerator_grid: AcceleratorGrid) -> () {
    let acc = accelerator(device_id);
    let grid = (comm_offsets.recv_noffsets * 64, 1, 1);
    let block = (64, 1, 1);
    let buffer_gpu = comm_offsets.recv_buffer_accelerator;

    if comm_offsets.recv_noffsets > 0 {
        copy(comm_buffer, buffer_gpu);

        for work_item in acc.exec(grid, block) {
            let th_idx = work_item.bidx() * work_item.bdimx() + work_item.tidx();

            if th_idx < comm_offsets.recv_noffsets {
                let start = get_comm_recv_starts_accelerator(th_idx, comm_offsets);
                let offset = get_comm_recv_offsets_accelerator(th_idx, comm_offsets);
                let size = get_comm_recv_sizes_accelerator(th_idx, comm_offsets);

                for i in range(0, size) {
                    let linear_idx = i * 3;
                    let pos = Vector3D {
                        x: get_real_accelerator(start + linear_idx,     buffer_gpu),
                        y: get_real_accelerator(start + linear_idx + 1, buffer_gpu),
                        z: get_real_accelerator(start + linear_idx + 2, buffer_gpu),
                    };

                    set_position(offset + i, accelerator_grid, pos);
                }
            }
        }

        acc.sync();
    }
}

// Synchronize ghost layer cells with neighbor ranks
fn synchronize_ghost_layer_cells(
    grid: &mut Grid,
    accelerator_grid: AcceleratorGrid,
    comm_offsets: &CommOffsets,
    world_size: i32,
    world_rank: i32) -> () {

    let mpih = mpi();
    let mut request: MPI_Request;
    let mut status: MPIStatus;

    let rank_send_ptr = bitcast[&mut[i32]](rank_send_particles.data);
    let rank_recv_ptr = bitcast[&mut[i32]](rank_recv_particles.data);

    let send_rank_offsets = get_array_of_i32(comm_offsets.send_rank_offsets);
    let recv_rank_offsets = get_array_of_i32(comm_offsets.recv_rank_offsets);
    let send_starts = get_array_of_i32(comm_offsets.send_starts);
    let recv_starts = get_array_of_i32(comm_offsets.recv_starts);

    resize_comm_buffers(comm_offsets.neighs * max_send_particles * 3, comm_offsets.neighs * max_recv_particles * 3);
    gather_ghost_layer_cells(comm_send_buffer, comm_offsets, accelerator_grid);

    for exchange_rank,
        send_begin_x, send_begin_y, send_begin_z,
        send_end_x, send_end_y, send_end_z,
        recv_begin_x, recv_begin_y, recv_begin_z,
        recv_end_x, recv_end_y, recv_end_z in
        communication_nodes(world_size, world_rank, grid) {

        if(rank_recv_ptr(exchange_rank) > 0) {
            let recv_offset = recv_rank_offsets(exchange_rank);
            let start = recv_starts(recv_offset);

            mpih.irecv(
                bitcast[&mut[real_t]](&comm_recv_buffer.data(start)) as MPI_MutBuf,
                rank_recv_ptr(exchange_rank) * 3,
                mpih.double_t, exchange_rank, 0, mpih.comms.world, &mut request);
        }

        if(rank_send_ptr(exchange_rank) > 0) {
            let send_offset = send_rank_offsets(exchange_rank);
            let start = send_starts(send_offset);

            mpih.send(
                bitcast[&mut[real_t]](&comm_send_buffer.data(start)) as MPI_MutBuf,
                rank_send_ptr(exchange_rank) * 3,
                mpih.double_t, exchange_rank, 0, mpih.comms.world);
        }

        if(rank_recv_ptr(exchange_rank) > 0) {
            mpih.wait(&mut request, &mut status);
        }
    }

    scatter_ghost_layer_cells(comm_recv_buffer, comm_offsets, accelerator_grid);
}
