fn @is_x86() -> bool { false }
fn @is_sse() -> bool { false }
fn @is_avx() -> bool { false }
fn @is_avx2() -> bool { false }

fn @get_alignment() -> i32 {4}

fn @nvvm_shfldown_i32(var: i32, delta: i32, width: i32) -> i32 {
    let mut res: i32;
    let warp_size = 32; 
    let c = ((warp_size - width) << 8) | 0x1f;
    asm("shfl.down.b32 $0, $1, $2, $3;" : "=r"(res) : "r"(var), "r"(delta as u32), "r"(c));
    res 
}

fn @nvvm_shfldown_f64(var: f64, delta: i32, width: i32) -> f64 {
    let mut res = var;
    let mut lo: u32;
    let mut hi: u32;
    asm("mov.b64 { $0, $1 }, $2;" : "=r"(lo), "=r"(hi) : "d"(res));
    hi = nvvm_shfldown_i32(hi as i32, delta, width) as u32;
    lo = nvvm_shfldown_i32(lo as i32, delta, width) as u32;
    asm("mov.b64 $0, { $1, $2 };" : "=d"(res) : "r"(lo), "r"(hi));
    res 
}

fn @nvvm_shfl_i32(var: i32, srcLane: i32, width: i32) -> i32 {
    let mut res: i32;
    let warp_size = 32; 
    let c = ((warp_size - width) << 8) | 0x1f;
	asm("shfl.idx.b32 $0, $1, $2, $3;" : "=r"(res) : "r"(var), "r"(srcLane as u32), "r"(c));
    res 
}

fn @nvvm_shfl_f64(var: f64, srcLane: i32, width: i32) -> f64 {
    let mut res = var;
    let mut lo: u32;
    let mut hi: u32;
    asm("mov.b64 { $0, $1 }, $2;" : "=r"(lo), "=r"(hi) : "d"(res));
    hi = nvvm_shfl_i32(hi as i32, srcLane, width) as u32;
    lo = nvvm_shfl_i32(lo as i32, srcLane, width) as u32;
    asm("mov.b64 $0, { $1, $2 };" : "=d"(res) : "r"(lo), "r"(hi));
    res 
}


fn @shuffle(x: real_t, srcLane: i32, laneOffset: i32) -> real_t {
	nvvm_shfl_f64(x, srcLane, get_cluster_size()) 
}

fn @align(ptr: &[i8], alignment: i32) -> &[i8] {
    ptr
}


fn @accelerator_allocate(size: i32) -> Buffer {
    let acc = accelerator(device_id);
    acc.alloc(size)
}
fn @accelerator_allocate_quantity(N: i32) -> Quantity3D {
    let acc = accelerator(device_id);
    let size = N * sizeof[real_t]();
    Quantity3D {
        x: acc.alloc(size),
        y: acc.alloc(size),
        z: acc.alloc(size)
    }

}


fn @transfer_between_devices(source: Buffer, destination: Buffer, size: i32) -> () {
    copy(source, destination, size);
}


fn @transfer_quantity_between_devices(src: Quantity3D, dest: Quantity3D, N: i32) -> () {
    copy(src.x, dest.x, N * sizeof[real_t]());
    copy(src.y, dest.y, N * sizeof[real_t]());
    copy(src.z, dest.z, N * sizeof[real_t]());
}

fn @get_cluster_size() -> i32 {32}

fn loop_accelerator(accelerator_grid: AcceleratorGrid, size: i32, body: fn(i32, i32, i32, i32, i32, i32, &mut[1][i32]) -> ()) -> () {
    let cluster_size = get_cluster_size();
    let acc = accelerator(device_id);
    let grid = (size*cluster_size, 1, 1);
    let block = (cluster_size, 1, 1);
	print_string("Grid size: ");
	print_i32(size * cluster_size);
	print_string("\nBlock size: ");
	print_i32(cluster_size);
	print_string("\n");

    
    for tid, bid, bdim, gdim, gid in acc.exec(grid, block) {
        let (tidx, _, _) = tid;
        let j = tidx();
        let (bidx, _, _) = bid;
        let i = bidx();
        let (bdimx, _, _) = bdim;
        let cluster_size = bdimx();
        let begin = i * cluster_size;
        let number_of_neighbors = get_number_of_neighbors(i, accelerator_grid);
        let neighborlist_offset = get_neighborlist_offset(i, accelerator_grid);
        let neighborlists = get_neighborlists(accelerator_grid);
        @@body(i, begin, j, cluster_size, number_of_neighbors, neighborlist_offset, neighborlists);
    }
    acc.sync();
}

fn @get_number_of_neighbors(cluster_index: i32, accelerator_grid: AcceleratorGrid) -> i32 {
    get_i32_accelerator(cluster_index, accelerator_grid.neighbors_per_cluster_accelerator)
}

fn @get_neighborlist_offset(cluster_index: i32, accelerator_grid: AcceleratorGrid) -> i32 {
    get_i32_accelerator(cluster_index, accelerator_grid.neighborlist_offsets_accelerator)
}

fn @get_neighborlists(accelerator_grid: AcceleratorGrid) -> &mut[1][i32] {
    get_array_of_i32_accelerator(accelerator_grid.neighborlists_accelerator)
}

fn @get_masses(accelerator_grid: AcceleratorGrid) -> &mut[1][real_t] {
    get_array_of_reals_accelerator(accelerator_grid.masses_accelerator)
}

fn @get_position(i: i32, accelerator_grid: AcceleratorGrid) -> Vector {
    get_vector_from_quantity_accelerator(i, accelerator_grid.positions_accelerator)
}

fn @set_position(i: i32, accelerator_grid: AcceleratorGrid, position: Vector) -> () {
    set_quantity_accelerator(i, accelerator_grid.positions_accelerator, position)
}

fn @get_velocity(i: i32, accelerator_grid: AcceleratorGrid) -> Vector {
    get_vector_from_quantity_accelerator(i, accelerator_grid.velocities_accelerator)
}

fn @set_velocity(i: i32, accelerator_grid: AcceleratorGrid, velocity: Vector) -> () {
    set_quantity_accelerator(i, accelerator_grid.velocities_accelerator, velocity)
}

fn @get_force(i: i32, accelerator_grid: AcceleratorGrid) -> Vector {
    get_vector_from_quantity_accelerator(i, accelerator_grid.forces_accelerator)
}

fn @set_force(i: i32, accelerator_grid: AcceleratorGrid, force: Vector) -> () {
    set_quantity_accelerator(i, accelerator_grid.forces_accelerator, force)
}

fn @reset_force(i: i32, accelerator_grid: AcceleratorGrid) -> () {
    set_quantity_accelerator(i, accelerator_grid.forces_accelerator, Vector {x: 0.0 as real_t, y: 0.0 as real_t, z: 0.0 as real_t});
}

fn @add_to_force(i: i32, accelerator_grid: AcceleratorGrid, dF_x: real_t, dF_y: real_t, dF_z: real_t) -> () {
    let mut force = get_vector_from_quantity_accelerator(i, accelerator_grid.forces_accelerator);
    force.x += dF_x;
    force.y += dF_y;
    force.z += dF_z;
    set_quantity_accelerator(i, accelerator_grid.forces_accelerator, force);

}

fn @get_mask_value(i: i32, accelerator_grid: AcceleratorGrid) -> bool {
    get_bool_accelerator(i, accelerator_grid.interaction_mask_accelerator)
}

fn @get_forces_x(accelerator_grid: AcceleratorGrid) -> &mut[1][real_t] {
    bitcast[&mut[1][real_t]](align(accelerator_grid.forces_accelerator.x.data, get_alignment()))
}
fn @get_forces_y(accelerator_grid: AcceleratorGrid) -> &mut[1][real_t] {
    bitcast[&mut[1][real_t]](align(accelerator_grid.forces_accelerator.y.data, get_alignment()))
}
fn @get_forces_z(accelerator_grid: AcceleratorGrid) -> &mut[1][real_t] {
    bitcast[&mut[1][real_t]](align(accelerator_grid.forces_accelerator.z.data, get_alignment()))
}
fn @get_positions_x(accelerator_grid: AcceleratorGrid) -> &mut[1][real_t] {
    bitcast[&mut[1][real_t]](align(accelerator_grid.positions_accelerator.x.data, get_alignment()))
}
fn @get_positions_y(accelerator_grid: AcceleratorGrid) -> &mut[1][real_t] {
    bitcast[&mut[1][real_t]](align(accelerator_grid.positions_accelerator.y.data, get_alignment()))
}
fn @get_positions_z(accelerator_grid: AcceleratorGrid) -> &mut[1][real_t] {
    bitcast[&mut[1][real_t]](align(accelerator_grid.positions_accelerator.z.data, get_alignment()))
}

