struct Grid {
    aabb: AABB,
    nx: i32,
    ny: i32,
    nz: i32,
    spacing: real_t,
    cells: Buffer,
    nparticles: i32
}

fn allocate_grid(aabb: AABB, cell_spacing: real_t, initial_cell_capacity: i32, initial_neighbor_list_capacity: i32, @cluster_size: i32, allocate: fn(i32) -> Buffer) -> Grid {
    let lastx = last_dimension_node(0);
    let lasty = last_dimension_node(1);
    let lastz = last_dimension_node(2);

    let mut nx = real_floor(((aabb.xmax - aabb.xmin + (cell_spacing / (2.0 as real_t))) / cell_spacing)) as i32;
    let mut ny = real_floor(((aabb.ymax - aabb.ymin + (cell_spacing / (2.0 as real_t))) / cell_spacing)) as i32;
    let mut nz = real_floor(((aabb.zmax - aabb.zmin + (cell_spacing / (2.0 as real_t))) / cell_spacing)) as i32;

    if(lastx) {
        nx += 1;
    }

    if(lasty) {
        ny += 1;
    }

    if(lastz) {
        nz += 1;
    }

    add_grid_allocation(nx * ny * nz * sizeof[Cell]());

    let grid = Grid {
        aabb: aabb,
        nx: nx,
        ny: ny,
        nz: nz,
        spacing: cell_spacing,
        cells: allocate(nx * ny * nz * sizeof[Cell]()),
        nparticles: 0
    }; 

    for cell, cell_index in map_over_grid(grid, range, range, range) {
        *cell = allocate_cell(flatten_index(cell_index, grid), 0, initial_cell_capacity, initial_neighbor_list_capacity, cluster_size, allocate);
    }

    grid 
}

fn grid_count_clusters_and_neighbors(grid: &Grid) -> [i32 * 2] {
    let mut cluster_count = 0;
    let mut neighbor_count = 0;

    for cell, index in map_over_grid(grid, range, range, range) {
        if(cell.size > 0) {
            let clusters = get_array_of_clusters(cell.clusters);

            cluster_count += cell.nclusters;

            for i in range(0, cell.nclusters) {
                neighbor_count += clusters(i).nb_list_size;
            }
        }
    }

    [cluster_count, neighbor_count]
}

fn deallocate_grid(grid: &Grid) -> () {
    for cell, index in map_over_grid(grid, range, range, range) {
        deallocate_cell(cell);
    }

    release((*grid).cells);
}

fn @compute_cell_position(position: Vector3D, grid: &Grid) -> [i32 * 3] {
    let i = real_floor(((position.x - grid.aabb.xmin) / grid.spacing) as real_t) as i32;
    let j = real_floor(((position.y - grid.aabb.ymin) / grid.spacing) as real_t) as i32;
    let k = real_floor(((position.z - grid.aabb.zmin) / grid.spacing) as real_t) as i32;

    [i, j, k]
}

fn is_within_domain(position: Vector3D, grid: &Grid) -> bool {
    let aabb = (*grid).aabb;

    position.x >= aabb.xmin && position.x <= aabb.xmax &&
    position.y >= aabb.ymin && position.y <= aabb.ymax &&
    position.z >= aabb.zmin && position.z <= aabb.zmax
}


fn @insert_particle(mass: real_t, position: Vector3D, velocity: Vector3D, grid: &Grid, allocate: fn(i32) -> Buffer) -> () {
    /*print_string("Mass: ");
    print_f64(mass);
    print_string(" Position: ");
    print_vector(position);
    print_string(" Velocity: ");
    print_vector(velocity);
    print_string("\n");
    */

    let cell_index = compute_cell_position(position, grid);
    /*print_string("Cell index: ");
    print_i32(cell_index(0));
    print_string(" ");
    print_i32(cell_index(1));
    print_string(" ");
    print_i32(cell_index(2));
    print_string("\n");*/

    let cells = get_array_of_cells((*grid).cells);
    let cell = &mut cells(flatten_index(cell_index, grid));
    append_particle(mass, position, velocity, cell, allocate);
}

fn initialize_grid(masses: &[real_t], positions: &[Vector3D], velocities: &[Vector3D], nparticles: i32, grid: &mut Grid, allocate: fn(i32) -> Buffer) -> () {
    let mut particles = 0;

    for i in range(0, nparticles) {
      if(is_within_domain(positions(i), grid)) {
        insert_particle(masses(i), positions(i), velocities(i), grid, allocate);
        particles++;
      }
    }

    grid.nparticles = particles;
}

fn map_over_grid(grid: &Grid, iterate_outer: fn(i32, i32, fn(i32) -> ()) -> (), iterate_middle: fn(i32, i32, fn(i32) -> ()) -> (), iterate_inner: fn(i32, i32, fn(i32) -> ()) -> (), f: fn(&mut Cell, [i32 * 3]) -> ()) -> () {
    let cells = get_array_of_cells((*grid).cells);
    for i in iterate_outer(0, grid.nx) {
        for j in iterate_middle(0, grid.ny) {
            for k in iterate_inner(0, grid.nz) {
                let cell_index = [i,j,k];
                f(&mut cells(flatten_index(cell_index, grid)), cell_index, continue)
            }
        }
    }
}

fn map_over_grid_subdomain(
    grid: &Grid,
    xbegin: i32,
    ybegin: i32,
    zbegin: i32,
    xend: i32,
    yend: i32,
    zend: i32,
    iterate_outer: fn(i32, i32, fn(i32) -> ()) -> (),
    iterate_middle: fn(i32, i32, fn(i32) -> ()) -> (),
    iterate_inner: fn(i32, i32, fn(i32) -> ()) -> (),
    body: fn(&mut Cell, [i32 * 3]) -> ()) -> () {

    let cells = get_array_of_cells((*grid).cells);
    for i in iterate_outer(xbegin, xend) {
        for j in iterate_middle(ybegin, yend) {
            for k in iterate_inner(zbegin, zend) {
                let cell_index = [i,j,k];
                body(&mut cells(flatten_index(cell_index, grid)), cell_index, continue)
            }
        }
    }
}

fn @flatten_index(cell_index: [i32 * 3], grid: &Grid) -> i32 {
    (cell_index(2) * grid.ny + cell_index(1)) * grid.nx + cell_index(0)
}

fn write_grid_data_to_arrays(masses: &mut[real_t], positions: &mut [Vector3D], velocities: &mut [Vector3D], forces: &mut [Vector3D], grid: &Grid) -> i32 {
    let mut array_index = 0;
    for cell, cell_index in map_over_grid(grid, range, range, range) {
        for k in range(0, cell.size) {
            /*print_string("Mass: ");
            print_f64(get_real(k, (*cell).masses));
            print_string("Position: ");
            print_vector(get_vector(k, (*cell).positions));
            print_string("Velocity: ");
            print_vector(get_vector(k, (*cell).velocities));
            */
            masses(array_index) = get_real(k, (*cell).masses);
            positions(array_index) = get_vector_from_3d_arrays(k, (*cell).positions);
            velocities(array_index) = get_vector_from_3d_arrays(k, (*cell).velocities);
            forces(array_index) = get_vector_from_3d_arrays(k, (*cell).forces);

            ++array_index;
        }
    }
    array_index
}

fn print_grid(grid: &Grid) -> () {
    for cell, cell_index in map_over_grid(grid, range, range, range) {
        if(cell.size > 0) {
            print_cell(cell, cell_index);
        }
    }
}
