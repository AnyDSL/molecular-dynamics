struct Grid {
    aabb: AABB,
    nx: i32,
    ny: i32,
    spacing: real_t,
    cells: Buffer,
    nparticles: i32
}

fn allocate_grid(aabb: AABB, cell_spacing: real_t, initial_cell_capacity: i32, @cluster_size: i32, allocate: fn(i32) -> Buffer) -> Grid {    
    let nx = math.floor(((aabb.max(0) - aabb.min(0)) / cell_spacing) as f64) as i32 + 1;
    let ny = math.floor(((aabb.max(1) - aabb.min(1)) / cell_spacing) as f64) as i32 + 1;
    let grid = Grid {
        aabb: aabb,
        nx: nx,
        ny: ny,
        spacing: cell_spacing,
        cells: allocate(nx * ny * sizeof[Cell]()),
        nparticles: 0
    }; 
    for cell, cell_index in map_over_grid(grid, range, range) {
        *cell = allocate_cell(flatten_index(cell_index, grid), 0, initial_cell_capacity, cluster_size, allocate);
    }
    grid 
}

fn grid_count_clusters_and_neighbors(grid: &Grid) -> [i32 * 2] {
    let mut cluster_count = 0;
    let mut neighbor_count = 0;
    for cell, index in map_over_grid(grid, range, range) {
        cluster_count += cell.nclusters;
        let clusters = get_array_of_clusters(cell.clusters);
        for i in range(0, cell.nclusters) {
           let neighborlist = clusters(i).neighbor_list;
           neighbor_count += neighborlist.size;
        }
    }
    [cluster_count, neighbor_count]
}

fn deallocate_grid(grid: &Grid) -> () {
    for cell, index in map_over_grid(grid, range, range) {
        deallocate_cell(cell);
    }
    release((*grid).cells);
}

fn @compute_cell_position(position: Vector, grid: &Grid) -> [i32 * 2] {
    let i = math.floor(((position.x - grid.aabb.min(0)) / grid.spacing) as f64) as i32;
    let j = math.floor(((position.y - grid.aabb.min(1)) / grid.spacing) as f64) as i32;
    [i, j]
}

fn @is_within_domain(position: Vector, grid: &Grid) -> bool {
    let aabb = (*grid).aabb;
    position.x > aabb.min(0) && position.x < aabb.max(0) &&
    position.y > aabb.min(1) && position.y < aabb.max(1) &&
    position.z > aabb.min(2) && position.z < aabb.max(2)
}


fn @insert_particle(mass: real_t, position: Vector, velocity: Vector, grid: &Grid, allocate: fn(i32) -> Buffer) -> () {
    /*print_string("Mass: ");
    print_f64(mass);
    print_string(" Position: ");
    print_vector(position);
    print_string(" Velocity: ");
    print_vector(velocity);
    print_string("\n");
    */

    let cell_index = compute_cell_position(position, grid);
    /*print_string("Cell index: ");
    print_i32(cell_index(0));
    print_string(" ");
    print_i32(cell_index(1));
    print_string("\n");*/
    let cells = get_array_of_cells((*grid).cells);
    let cell = &mut cells(flatten_index(cell_index, grid));
    append_particle(mass, position, velocity, cell, allocate);
}

fn initialize_grid(masses: &[real_t], positions: &[Vector], velocities: &[Vector], nparticles: i32, grid: &mut Grid, allocate: fn(i32) -> Buffer) -> () { 
    for i in range(0, nparticles) {
       insert_particle(masses(i), positions(i), velocities(i), grid, allocate);
    }
    grid.nparticles = nparticles;
}

fn map_over_grid(grid: &Grid, iterate_outer: fn(i32, i32, fn(i32) -> ()) -> (), iterate_inner: fn(i32, i32, fn(i32) -> ()) -> (), f: fn(&mut Cell, [i32 * 2]) -> ()) -> () {
    let cells = get_array_of_cells((*grid).cells);
    for i in iterate_outer(0, grid.nx) {
        for j in iterate_inner(0, grid.ny) {
            let cell_index = [i,j];
            f(&mut cells(flatten_index(cell_index, grid)), cell_index, continue)
        }
    }
}

fn map_over_grid_subdomain(grid: &Grid, begin: [i32 * 2], end: [i32 * 2], iterate_outer: fn(i32, i32, fn(i32) -> ()) -> (), iterate_inner: fn(i32, i32, fn(i32) -> ()) -> (), body: fn(&mut Cell, [i32 * 2]) -> ()) -> () {
    let cells = get_array_of_cells((*grid).cells);
    for i in iterate_outer(begin(0), end(0)) {
        for j in iterate_inner(begin(1), end(1)) {
            let cell_index = [i,j];
            body(&mut cells(flatten_index(cell_index, grid)), cell_index, continue)
        }
    }
}

fn @flatten_index(cell_index: [i32 * 2], grid: &Grid) -> i32 {
    cell_index(0) * grid.ny + cell_index(1)
}

fn write_grid_data_to_arrays(masses: &mut[real_t], positions: &mut [Vector], velocities: &mut [Vector], size: i32, grid: &Grid) -> i32 {
    if(size < (*grid).nparticles) {
        print_string("The arrays are too small for storing ");
        print_i32(grid.nparticles);
        print_string(" particles!\n");
        0
    }
    else {
        let mut array_index = 0;
        for cell, cell_index in map_over_grid(grid, range, range) {
            for k in range(0, cell.size) {
                /*print_string("Mass: ");
                print_f64(get_real(k, (*cell).masses));
                print_string("Position: ");
                print_vector(get_vector(k, (*cell).positions));
                print_string("Velocity: ");
                print_vector(get_vector(k, (*cell).velocities));
                */
                masses(array_index) = get_real(k, (*cell).masses);
                positions(array_index) = get_vector_from_quantity(k, (*cell).positions);
                velocities(array_index) = get_vector_from_quantity(k, (*cell).velocities);
                ++array_index;
            }
        }
        array_index
    }
}

fn print_grid(grid: &Grid) -> () {
    for cell, cell_index in map_over_grid(grid, range, range) {
        if(cell.size > 0) {
            print_cell(cell, cell_index);
        }
    }
}
