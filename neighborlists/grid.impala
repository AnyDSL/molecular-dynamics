struct Grid {
    aabb: AABB,
    nx: i32,
    ny: i32,
    nz: i32,
    spacing: real_t,
    cells: Buffer,
    nparticles: i32
}

fn allocate_grid(aabb: AABB, cell_spacing: real_t, initial_cell_capacity: i32, @cluster_size: i32, allocate: fn(i32) -> Buffer) -> Grid {    
    let nx = math.floor(((aabb.max(0) - aabb.min(0)) / cell_spacing) as f64) as i32 + 1;
    let ny = math.floor(((aabb.max(1) - aabb.min(1)) / cell_spacing) as f64) as i32 + 1;
    let nz = math.floor(((aabb.max(2) - aabb.min(2) + (cell_spacing / 2.0)) / cell_spacing) as f64) as i32;

    let grid = Grid {
        aabb: aabb,
        nx: nx,
        ny: ny,
        nz: nz,
        spacing: cell_spacing,
        cells: allocate(nx * ny * nz * sizeof[Cell]()),
        nparticles: 0
    }; 

    for cell, cell_index in map_over_grid(grid, range, range, range) {
        *cell = allocate_cell(flatten_index(cell_index, grid), 0, initial_cell_capacity, cluster_size, allocate);
    }

    grid 
}

fn grid_count_clusters_and_neighbors(grid: &Grid) -> [i32 * 2] {
    let mut cluster_count = 0;
    let mut neighbor_count = 0;
    for cell, index in map_over_grid(grid, range, range, range) {
        cluster_count += cell.nclusters;
        let clusters = get_array_of_clusters(cell.clusters);
        for i in range(0, cell.nclusters) {
           let neighborlist = clusters(i).neighbor_list;
           neighbor_count += neighborlist.size;
        }
    }
    [cluster_count, neighbor_count]
}

fn deallocate_grid(grid: &Grid) -> () {
    for cell, index in map_over_grid(grid, range, range, range) {
        deallocate_cell(cell);
    }

    release((*grid).cells);
}

fn @compute_cell_position(position: Vector3D, grid: &Grid) -> [i32 * 3] {
    let i = math.floor(((position.x - grid.aabb.min(0)) / grid.spacing) as f64) as i32;
    let j = math.floor(((position.y - grid.aabb.min(1)) / grid.spacing) as f64) as i32;
    let k = math.floor(((position.z - grid.aabb.min(2)) / grid.spacing) as f64) as i32;

    [i, j, k]
}

fn @is_within_domain(position: Vector3D, grid: &Grid) -> bool {
    let aabb = (*grid).aabb;
    position.x >= aabb.min(0) && position.x <= aabb.max(0) &&
    position.y >= aabb.min(1) && position.y <= aabb.max(1) &&
    position.z >= aabb.min(2) && position.z <= aabb.max(2)
}


fn @insert_particle(mass: real_t, position: Vector3D, velocity: Vector3D, grid: &Grid, allocate: fn(i32) -> Buffer) -> () {
    /*print_string("Mass: ");
    print_f64(mass);
    print_string(" Position: ");
    print_vector(position);
    print_string(" Velocity: ");
    print_vector(velocity);
    print_string("\n");
    */

    let cell_index = compute_cell_position(position, grid);
    /*print_string("Cell index: ");
    print_i32(cell_index(0));
    print_string(" ");
    print_i32(cell_index(1));
    print_string("\n");
    print_i32(cell_index(2));
    print_string("\n");*/

    if(
      cell_index(0) < grid.nx &&
      cell_index(1) < grid.ny &&
      cell_index(2) < grid.nz
    ) {
      let cells = get_array_of_cells((*grid).cells);
      let cell = &mut cells(flatten_index(cell_index, grid));
      append_particle(mass, position, velocity, cell, allocate);
    } else {
      print_string("INVALID INDEX!\n");
      print_string("index = ");
      print_i32(cell_index(0));
      print_string(",");
      print_i32(cell_index(1));
      print_string(",");
      print_i32(cell_index(2));
      print_string(" and nx, ny, nz = ");
      print_i32(grid.nx);
      print_string(",");
      print_i32(grid.ny);
      print_string(",");
      print_i32(grid.nz);
      print_string("\n");
      print_flush();
    }
}

fn initialize_grid(masses: &[real_t], positions: &[Vector3D], velocities: &[Vector3D], nparticles: i32, grid: &mut Grid, allocate: fn(i32) -> Buffer) -> () {
    let mut particles = 0;

    for i in range(0, nparticles) {
      if(is_within_domain(positions(i), grid)) {
        insert_particle(masses(i), positions(i), velocities(i), grid, allocate);
        particles++;
      }
    }

    grid.nparticles = particles;
}

fn map_over_grid(grid: &Grid, iterate_outer: fn(i32, i32, fn(i32) -> ()) -> (), iterate_middle: fn(i32, i32, fn(i32) -> ()) -> (), iterate_inner: fn(i32, i32, fn(i32) -> ()) -> (), f: fn(&mut Cell, [i32 * 3]) -> ()) -> () {
    let cells = get_array_of_cells((*grid).cells);
    for i in iterate_outer(0, grid.nx) {
        for j in iterate_middle(0, grid.ny) {
            for k in iterate_inner(0, grid.nz) {
                let cell_index = [i,j,k];
                f(&mut cells(flatten_index(cell_index, grid)), cell_index, continue)
            }
        }
    }
}

fn map_over_grid_subdomain(grid: &Grid, begin: [i32 * 3], end: [i32 * 3], iterate_outer: fn(i32, i32, fn(i32) -> ()) -> (), iterate_middle: fn(i32, i32, fn(i32) -> ()) -> (), iterate_inner: fn(i32, i32, fn(i32) -> ()) -> (), body: fn(&mut Cell, [i32 * 3]) -> ()) -> () {
    let cells = get_array_of_cells((*grid).cells);
    for i in iterate_outer(begin(0), end(0)) {
        for j in iterate_middle(begin(1), end(1)) {
            for k in iterate_inner(begin(2), end(2)) {
                let cell_index = [i,j,k];
                body(&mut cells(flatten_index(cell_index, grid)), cell_index, continue)
            }
        }
    }
}

fn @flatten_index(cell_index: [i32 * 3], grid: &Grid) -> i32 {
    (cell_index(2) * grid.ny + cell_index(1)) * grid.nx + cell_index(0)
}

fn write_grid_data_to_arrays(masses: &mut[real_t], positions: &mut [Vector3D], velocities: &mut [Vector3D], forces: &mut [Vector3D], grid: &Grid) -> i32 {
    let mut array_index = 0;
    for cell, cell_index in map_over_grid(grid, range, range, range) {
        for k in range(0, cell.size) {
            /*print_string("Mass: ");
            print_f64(get_real(k, (*cell).masses));
            print_string("Position: ");
            print_vector(get_vector(k, (*cell).positions));
            print_string("Velocity: ");
            print_vector(get_vector(k, (*cell).velocities));
            */
            masses(array_index) = get_real(k, (*cell).masses);
            positions(array_index) = get_vector_from_struct_of_arrays(k, (*cell).positions);
            velocities(array_index) = get_vector_from_struct_of_arrays(k, (*cell).velocities);
            forces(array_index) = get_vector_from_struct_of_arrays(k, (*cell).forces);

            ++array_index;
        }
    }
    array_index
}

fn print_grid(grid: &Grid) -> () {
    for cell, cell_index in map_over_grid(grid, range, range, range) {
        if(cell.size > 0) {
            print_cell(cell, cell_index);
        }
    }
}
